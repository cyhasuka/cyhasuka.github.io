{"posts":[{"title":"CentOS yum install æŠ¥é”™ï¼šCould not retrieve mirrorlist *** çš„è§£å†³æ–¹æ³•","text":"æœ‰æ—¶ä½¿ç”¨ yum install ç»™ linux æœåŠ¡å™¨å®‰è£…åŒ…çš„æ—¶å€™ä¼šæœ‰ä¸Šè¿°æŠ¥é”™ï¼ŒåŸå› æ˜¯è¯¥é•œåƒç½‘å€æ— æ³•è®¿é—®ã€‚ Centos 7 è‡ª 2024 å¹´ 7 æœˆ 1 æ—¥ å·²è¾¾åˆ° EOLï¼ˆç”Ÿå‘½å‘¨æœŸç»“æŸï¼‰ï¼Œå› æ­¤ mirrorlist.centos.org é•œåƒç«™å·²åœæ­¢è¿è¡Œã€‚å¦‚æœæŠ¥é”™åŒ…å«è¯¥é•œåƒç«™ï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢çš„å‘½ä»¤æ›´æ”¹æ‰€æœ‰åŒ…å«è¯¥é•œåƒç«™çš„åœ°å€åˆ° vault.centos.orgã€‚ 123sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.reposed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.reposed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo å¦‚æœæŠ¥é”™åŒ…å«å…¶ä»–é•œåƒç«™ï¼Œå¯å°†æ— æ³•è®¿é—®çš„é•œåƒç«™æš‚æ—¶å±è”½ï¼Œéœ€è¦æ—¶å†å¤„ç†. 12cd /etc/yum.repos.dmv microsoft.repo microsoft.repo.bak &lt;= ä»…ä¸ºç¤ºä¾‹ï¼Œæ¢æˆæ— æ³•è®¿é—®çš„repo","link":"/posts/d650b297/"},{"title":"FastPillars-è®ºæ–‡ç¬”è®°-æ¿€å…‰é›·è¾¾ç‚¹äº‘æ„ŸçŸ¥ç®—æ³•","text":"12è®ºæ–‡é“¾æ¥ï¼šhttps://arxiv.org/abs/2302.02367githubï¼šhttps://github.com/StiphyJay/FastPillars 1 å¼•è¨€ç›®å‰åŸºäºæ¿€å…‰é›·è¾¾çš„ä¸»æµæ–¹æ³•åˆ†ä¸ºåŸºäºç‚¹äº‘çš„æ–¹æ³•å’ŒåŸºäºä½“ç´ çš„æ–¹æ³•ã€‚å‰è€…èƒ½ä¿ç•™æœ€å¤šçš„å‡ ä½•ä¿¡æ¯ï¼Œä½†é€ç‚¹æŸ¥è¯¢å’Œéå†è¾ƒä¸ºè€—æ—¶ï¼›åè€…ä½¿ç”¨3D/2Då·ç§¯å¤„ç†ä½“ç´ åŒ–ç‚¹äº‘ï¼Œä½†ç”¨äºæé«˜æ•ˆç‡çš„3Dç¨€ç–å·ç§¯å¯¹å®é™…éƒ¨ç½²ä¸å‹å¥½ã€‚ PointPillarsä½œä¸ºdeploy-friendlyçš„æ–¹æ³•ï¼Œä½¿ç”¨å¯¹éƒ¨ç½²æœ‰åˆ©çš„2Då·ç§¯ã€‚ä½†ç”±äºå…¶ä½¿ç”¨æœ€å¤§æ± åŒ–æå–æ¯ä¸ªæŸ±ä½“å†…ç‚¹çš„ç‰¹å¾ï¼Œæ— æ³•è·å–ç»†ç²’åº¦ç‰¹å¾ï¼Œå½±å“æœ€ç»ˆæ€§èƒ½ï¼ˆç‰¹åˆ«æ˜¯å¯¹äºå°ç‰©ä½“ï¼‰ã€‚æ­¤å¤–ï¼Œå…¶neckç½‘ç»œFPNç›´æ¥èåˆå¤šå°ºåº¦ç‰¹å¾ï¼Œç¼ºå°‘å……åˆ†çš„ç‰¹å¾äº¤äº’ã€‚å°½ç®¡PillarNetæé«˜äº†PointPillarsçš„æ€§èƒ½ï¼Œä½†å…¶ä½¿ç”¨äº†éƒ¨ç½²å›°éš¾çš„ç¨€ç–å·ç§¯ã€‚ è®ºæ–‡æå‡ºFastPillarsï¼ŒåŸºäºæ ‡å‡†å·ç§¯ï¼Œå®¹æ˜“éƒ¨ç½²ã€‚ç½‘ç»œåŒ…å«4ä¸ªéƒ¨åˆ†ï¼špilleræŸ±ä½“ç¼–ç ã€ç‰¹å¾æå–ã€ç‰¹å¾èåˆå’Œ3Dè¾¹ç•Œæ¡†å›å½’ã€‚å¯¹äºpillerç¼–ç ï¼Œæå‡ºæœ€å¤§-æ³¨æ„åŠ›æŸ±ä½“ç¼–ç ï¼ˆMAPEï¼‰æ¨¡å—ï¼Œåœ¨ä¸å¼•å…¥é¢å¤–è®¡ç®—æ—¶é—´çš„æƒ…å†µä¸‹è‡ªåŠ¨å­¦ä¹ å±€éƒ¨å‡ ä½•æ¨¡å¼ã€‚å¯¹äºç‰¹å¾æå–ï¼Œæå‡ºç´§å‡‘è€Œé«˜æ•ˆçš„ä¸»å¹²ç½‘ç»œCRVNetã€‚ç‰¹å¾èåˆæ¨¡å—ä¸­ï¼Œé€šè¿‡å±‚æ¬¡èåˆä¸åŒå°ºåº¦å’Œæ„Ÿå—é‡çš„ç‰¹å¾ä¸°å¯Œè¯­ä¹‰ç‰¹å¾ã€‚3Dè¾¹ç•Œæ¡†å›å½’ä½¿ç”¨åŸºäºä¸­å¿ƒçš„æ–¹æ³•ã€‚ 2 ç›¸å…³å·¥ä½œ3Dç›®æ ‡æ£€æµ‹ä¸­çš„å·¥ä¸šçº§è½»é‡ç½‘ç»œç»“æ„ï¼šYOLOç³»åˆ—ä½¿ç”¨CSPNetï¼Œåœ¨ç‹¬ç«‹çš„ä¸¤ä¸ªåˆ†æ”¯ä¸­å¤„ç†éƒ¨åˆ†ç‰¹å¾ï¼Œè¾¾åˆ°æ›´ä¸°å¯Œçš„æ¢¯åº¦ç»„åˆï¼Œä»è€Œå‡å°å­˜å‚¨å’Œè®¡ç®—å¹¶æé«˜æ€§èƒ½ã€‚ RepVGGä½¿ç”¨é‡å‚æ•°åŒ–ç»“æ„ï¼Œä½¿ç”¨3ä¸ªåˆ†æ”¯æ›¿ä»£VGGä¸­çš„Conv-BN-ReLUç»“æ„ï¼Œä»¥å¸®åŠ©ä¼˜åŒ–ï¼›æ¨ç†æ—¶ä½¿ç”¨é‡å‚æ•°åŒ–å°†3ä¸ªåˆ†æ”¯åˆå¹¶ä»¥æé«˜æ¨ç†é€Ÿåº¦ã€‚ 3 è®ºæ–‡æ–¹æ³•ç½‘ç»œåŒ…å«4ä¸ªéƒ¨åˆ†ï¼šæŸ±ä½“ç¼–ç ã€ç‰¹å¾æå–ã€ç‰¹å¾èåˆå’Œ3Dè¾¹ç•Œæ¡†å›å½’ã€‚ 3.1 æœ€å¤§-æ³¨æ„åŠ›æŸ±ä½“ç¼–ç ï¼ˆMAPEï¼‰æœ¬æ–‡çš„MAPEåŒ…å«ä¸‰ä¸ªå•å…ƒï¼šç‚¹ç¼–ç å•å…ƒã€æœ€å¤§æ± åŒ–ç¼–ç å•å…ƒå’Œæ³¨æ„åŠ›æ± åŒ–ç¼–ç å•å…ƒã€‚è®°éç©ºæŸ±ä½“iå†…çš„ç‚¹é›†ä¸º ï¼ˆ5è¡¨ç¤º3ç»´ä½ç½®ã€åå°„å¼ºåº¦å’Œç›¸å¯¹æ—¶é—´æˆ³ï¼‰ã€‚ ç‚¹ç¼–ç ï¼šé¦–å…ˆä½¿ç”¨å„ç‚¹ä¸æŸ±ä½“ä¸­å¿ƒçš„åç§»é‡ ä»¥åŠå„ç‚¹åæ ‡ä¸æœ€å°åæ ‡çš„åç§»é‡ å¢å¼ºå„ç‚¹çš„ç‰¹å¾ï¼Œå¾—åˆ° ã€‚ æ³¨æ„æ­¤å¤„ä¸PointPillarsä¸åŒï¼Œä¸ä¼šä¸ºäº†ä¿è¯å„æŸ±ä½“ç‚¹æ•°ç›¸åŒè€Œä¸¢å¼ƒä»»ä½•ç‚¹ã€‚ç„¶åä½¿ç”¨MLPå°†å„ç‚¹æ˜ å°„åˆ°é«˜ç»´ç©ºé—´å¾—åˆ° ã€‚æœ€å¤§æ± åŒ–ç¼–ç ï¼šä½¿ç”¨æœ€å¤§æ± åŒ–èšåˆæŸ±ä½“å†…ç‚¹çš„ç‰¹å¾ï¼Œå¾—åˆ° ã€‚ æ³¨æ„åŠ›æ± åŒ–ç¼–ç ï¼šç”¨äºä¿ç•™ç»†ç²’åº¦ä¿¡æ¯ã€‚ä½¿ç”¨MLPå¤„ç†æŸ±ä½“å†…çš„ç‚¹å¾—åˆ°æ³¨æ„åŠ›åˆ†æ•° ï¼Œç„¶åæ ¹æ®åŠ æƒæ±‚å’Œï¼š å…¶ä¸­ ã€‚ æœ€åï¼Œå¹³å‡ä¸å¾—åˆ° ï¼Œå…¶åŒ…å«äº†æŸ±ä½“å†…çš„å…¨å±€ä¿¡æ¯å’Œç»†ç²’åº¦å±€éƒ¨ä¿¡æ¯ã€‚MAPEèƒ½æå¤§æå‡å°ç‰©ä½“çš„æ£€æµ‹èƒ½åŠ›ã€‚ 3.2 CRVNetä¸»å¹²åŸºäºCSPNetå’ŒRepVGGï¼Œæœ¬æ–‡æå‡ºCRVNetï¼ŒåŸºäºVGGæˆ–ResNet34æ­å»ºæ¨¡å‹ï¼Œå…¶åŸºæœ¬ç»“æ„å•å…ƒå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ä½¿ç”¨CSPç»“æ„èƒ½å®ç°ç´§å‡‘è€Œé«˜æ•ˆçš„ç½‘ç»œã€‚ç”±äºå•è·¯å¾„ç½‘ç»œçš„è®¡ç®—ä»£ä»·å’Œå‚æ•°é‡ä¼šéšæ¨¡å‹å®¹é‡æŒ‡æ•°å¢åŠ ï¼Œæœ¬æ–‡å¼•å…¥RepBlockã€‚æ¨ç†æ—¶ï¼Œæ¯ä¸ªRepBlockä¼šè¢«è½¬åŒ–ä¸ºå·ç§¯+æ¿€æ´»å‡½æ•°çš„å½¢å¼ï¼ˆç§°ä¸ºRepConvï¼‰ï¼Œä»¥å‡å°æ¨ç†æ—¶é—´ã€‚ 3.3 Neckä¸åŸºäºä¸­å¿ƒçš„HeadNeckä½¿ç”¨PillarNetçš„è®¾è®¡ï¼Œèåˆä¸»å¹²ç½‘ç»œå¤šå°ºåº¦ç‰¹å¾ã€‚å›å½’å¤´åœ¨CenterPointçš„åŸºç¡€ä¸Šæ·»åŠ IoUåˆ†æ”¯ï¼Œä¼°è®¡é¢„æµ‹è¾¹ç•Œæ¡†å’ŒçœŸå®è¾¹ç•Œæ¡†çš„IoUï¼Œå¹¶ä½¿ç”¨IoUæ„ŸçŸ¥çš„ä¿®æ­£å‡½æ•°å‡å°åˆ†ç±»ä¸å›å½’é¢„æµ‹çš„é—´éš™ã€‚ä¿®æ­£çš„ç½®ä¿¡åº¦åˆ†æ•°æŒ‰ä¸‹å¼è®¡ç®—ï¼Œå¹¶ç”¨äºNMSåå¤„ç†ï¼š å…¶ä¸­ä¸ºé¢„æµ‹ç½®ä¿¡åº¦åˆ†æ•°ï¼Œä¸ºé¢„æµ‹IoUï¼Œã€‚ åˆ†ç±»ä¸å›å½’é¢„æµ‹çš„é—´éš™/ä¸ä¸€è‡´æ€§ï¼šåˆ†ç±»åˆ†æ•°æœ€é«˜çš„æ¡†ä¸ä¸€å®šæ˜¯æœ€å›å½’æœ€å‡†çš„æ¡†ã€‚ 3.4 æŸå¤±å‡½æ•°ä½¿ç”¨CenterPointçš„æŸå¤±å‡½æ•°ã€‚å¯¹äºIoUé¢„æµ‹ï¼Œä½¿ç”¨L1æŸå¤±ï¼Œå›å½’ç›®æ ‡è¢«ç¼©æ”¾åˆ°å†…ï¼›æ­¤å¤–æ·»åŠ DIoUæŸå¤±ã€‚æ€»æŸå¤±å¦‚ä¸‹ï¼š 4 å®éªŒå®æ–½ç»†èŠ‚ï¼šä½¿ç”¨éšæœºç¿»è½¬ã€æ—‹è½¬å’Œç¼©æ”¾æ•°æ®å¢å¹¿ã€GTå¢å¹¿ï¼ˆå¸¦è¡°é€€ç­–ç•¥ï¼‰ï¼›æµ‹è¯•æ—¶ä½¿ç”¨åŒç¿»è½¬æ•°æ®å¢å¹¿ã€‚ 4.1 ä¸»è¦ç»“æœ4.1.1 å®šé‡è¯„ä¼°åœ¨nuScenesæµ‹è¯•é›†ä¸Šï¼ŒFastPillarsèƒ½è¶…è¿‡SOTAæ–¹æ³•çš„æ€§èƒ½ï¼Œä¸”èƒ½è¾¾åˆ°å®æ—¶æ€§ã€‚ 4.1.2 ä¸å®æ—¶One-Stageæ–¹æ³•æ¯”è¾ƒä¸PillarNetæ¯”è¾ƒï¼Œæœ¬æ–‡çš„æ–¹æ³•æœ‰2å€çš„é€Ÿåº¦è€Œç²¾åº¦ç›¸å½“ã€‚ 4.2 æ¶ˆèå®éªŒ4.2.1 æœ€å¤§-æ³¨æ„åŠ›æŸ±ä½“ç¼–ç æ¨¡å—ä¸æœ€å¤§æ± åŒ–ç›¸æ¯”ï¼Œæœ¬æ–‡çš„MAPEæ¨¡å—èƒ½æé«˜æ€§èƒ½ï¼Œä¸”åœ¨å°ç‰©ä½“ä¸Šçš„æ€§èƒ½æå‡è¾ƒå¤§ã€‚è¿™è¯æ˜äº†MAPEèƒ½æå–ç»†ç²’åº¦çš„å±€éƒ¨é›†åˆä¿¡æ¯ã€‚ è¡¥å……ææ–™B. MAPEä¸åŒæ± åŒ–æ“ä½œçš„æ¶ˆèå®éªŒ ä¸ä»…ä½¿ç”¨æ³¨æ„åŠ›æ± åŒ–æˆ–ä»…ä½¿ç”¨æœ€å¤§æ± åŒ–ç­‰æ–¹æ³•ç›¸æ¯”ï¼Œå› å…¶èåˆäº†ä¸»è¦ç‰¹å¾å’Œå±€éƒ¨å‡ ä½•ç‰¹å¾ï¼Œæœ¬æ–‡çš„æœ€å¤§+æ³¨æ„åŠ›æ± åŒ–æ–¹æ³•æœ‰ç›®å‰æœ€é«˜çš„æ€§èƒ½ã€‚","link":"/posts/26007bd4/"},{"title":"3D-NMS ç®—æ³•åŠPCL &amp; CUDAå®ç°","text":"1 NMS ç®€ä»‹NMSï¼ˆNon Maximum Suppressionï¼‰å³éæå¤§å€¼æŠ‘åˆ¶ï¼Œå¹¿æ³›åº”ç”¨äºä¼ ç»Ÿçš„ç‰¹å¾æå–å’Œæ·±åº¦å­¦ä¹ çš„ç›®æ ‡æ£€æµ‹ç®—æ³•ä¸­ã€‚ NMSåŸç†æ˜¯é€šè¿‡ç­›é€‰å‡ºå±€éƒ¨æå¤§å€¼å¾—åˆ°æœ€ä¼˜è§£ã€‚ åœ¨äºŒç»´è¾¹ç¼˜æå–ä¸­ä½“ç°åœ¨æå–è¾¹ç¼˜è½®å»“åå°†ä¸€äº›æ¢¯åº¦æ–¹å‘å˜åŒ–ç‡è¾ƒå°çš„ç‚¹ç­›é€‰æ‰ï¼Œé¿å…é€ æˆå¹²æ‰°ã€‚ åœ¨ä¸‰ç»´å…³é”®ç‚¹æ£€æµ‹ä¸­ä¹Ÿèµ·åˆ°é‡è¦ä½œç”¨ï¼Œç­›é€‰æ‰ç‰¹å¾ä¸­éå±€éƒ¨æå€¼ã€‚ åœ¨ç›®æ ‡æ£€æµ‹æ–¹é¢å¦‚Yoloå’ŒRCNNç­‰æ¨¡å‹ä¸­å‡æœ‰ä½¿ç”¨ï¼Œå¯ä»¥å°†è¾ƒå°åˆ†æ•°çš„è¾“å‡ºæ¡†è¿‡æ»¤æ‰,åŒæ ·ï¼Œåœ¨ä¸‰ç»´åŸºäºç‚¹äº‘çš„ç›®æ ‡æ£€æµ‹æ¨¡å‹ä¸­äº¦æœ‰ä½¿ç”¨ã€‚ 2 å®ç°2.1 PCLæå–ç‚¹äº‘æå¤§å€¼ç‰¹å¾ç‚¹ï¼ˆC++å®ç°ï¼‰ç‚¹äº‘å…³é”®ç‚¹ç‰¹å¾æå–ç®—æ³•ç»å¸¸ä¼šä½¿ç”¨nmsæå–æå¤§å€¼ç‚¹ã€‚ å¦‚3D SIFTå…³é”®ç‚¹æ£€æµ‹ä¸­éœ€è¦è®¡ç®—å°ºåº¦ç©ºé—´ä¸­åƒç´ ç‚¹çš„26é‚»åŸŸçš„æå€¼ç‚¹ã€‚ 1233D SWIFTç®—æ³•åŸç†å‚è€ƒï¼š https://blog.csdn.net/lingyunxianhe/article/details/79063547https://www.cs.ubc.ca/~lowe/papers/ijcv04.pdf 12345678pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift;pcl::PointCloud&lt;pcl::PointWithScale&gt; result;sift.setInputCloud(cloud_xyz);pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;());sift.setSearchMethod(tree); sift.setScales(0.01f, 7, 20);sift.setMinimumContrast(0.001f);sift.compute(result); 2.2 ç›®æ ‡æ£€æµ‹ç­›é€‰bboxï¼ˆCUDAå®ç°ï¼‰nmsåœ¨æ·±åº¦å­¦ä¹ é¢†åŸŸå¸¸ç”¨äºå¯¹ Bounding Box(bbox) çš„å¾—åˆ†è¿›è¡Œæå¤§å€¼ç­›é€‰ï¼Œåœ¨rcnnï¼Œyolo, pointnet, pointpillarsç­‰äºŒç»´ã€ä¸‰ç»´æ£€æµ‹æ·±åº¦å­¦ä¹ æ¨¡å‹ä¸­å¹¿æ³›ä½¿ç”¨ã€‚ å…¶ç®—æ³•æµç¨‹å¤§è‡´ä¸ºï¼š 1ï¼šè®¡ç®—æ‰€æœ‰bboxçš„å¾—åˆ†ã€‚ 2ï¼šæ’åºï¼Œä¾æ¬¡ä¸å¾—åˆ†é«˜çš„bboxçš„IoUè¿›è¡Œå¯¹æ¯”ï¼Œå¦‚æœå¤§äºè®¾å®šçš„é˜ˆå€¼ï¼Œå°±åˆ é™¤è¯¥æ¡†ã€‚ workflowï¼šnmsLauncher -&gt; nms_kernel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256#define THREADS_PER_BLOCK 16#define DIVUP(m, n) ((m) / (n) + ((m) % (n) &gt; 0))const float EPS = 1e-8;struct Point { float x, y; __device__ Point() {} __device__ Point(double _x, double _y){ x = _x, y = _y; } __device__ void set(float _x, float _y){ x = _x; y = _y; } __device__ Point operator +(const Point &amp;b)const{ return Point(x + b.x, y + b.y); } __device__ Point operator -(const Point &amp;b)const{ return Point(x - b.x, y - b.y); }};__device__ inline void rotate_around_center(const Point &amp;center, const float angle_cos, const float angle_sin, Point &amp;p){ // å°†ç»™å®šç‚¹å›´ç»•ä¸­å¿ƒç‚¹æ—‹è½¬ float new_x = (p.x - center.x) * angle_cos + (p.y - center.y) * (-angle_sin) + center.x; float new_y = (p.x - center.x) * angle_sin + (p.y - center.y) * angle_cos + center.y; p.set(new_x, new_y);}__device__ inline int point_cmp(const Point &amp;a, const Point &amp;b, const Point &amp;center){ // æ¯”è¾ƒä¸¤ç‚¹ç›¸å¯¹ç»™å®šcenteræè§’å¤§å° return atan2(a.y - center.y, a.x - center.x) &gt; atan2(b.y - center.y, b.x - center.x);}__device__ inline float cross(const Point &amp;a, const Point &amp;b){ return a.x * b.y - a.y * b.x;}__device__ inline float cross(const Point &amp;p1, const Point &amp;p2, const Point &amp;p0){ // è®¡ç®—ä¸‰ç‚¹æ„æˆçš„ä¸¤å‘é‡å‰ä¹˜ return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);}__device__ int check_rect_cross(const Point &amp;p1, const Point &amp;p2, const Point &amp;q1, const Point &amp;q2){ // æ£€æŸ¥ä¸¤çŸ©å½¢æ˜¯å¦ç›¸äº¤ int ret = min(p1.x,p2.x) &lt;= max(q1.x,q2.x) &amp;&amp; min(q1.x,q2.x) &lt;= max(p1.x,p2.x) &amp;&amp; min(p1.y,p2.y) &lt;= max(q1.y,q2.y) &amp;&amp; min(q1.y,q2.y) &lt;= max(p1.y,p2.y); return ret;}__device__ inline int check_in_box2d(const float *box, const Point &amp;p){ //params: (7) [x, y, z, dx, dy, dz, heading] const float MARGIN = 1e-2; float center_x = box[0], center_y = box[1]; float angle_cos = cos(-box[6]), angle_sin = sin(-box[6]); // å°†ç‚¹æ—‹è½¬åˆ°boxçš„åæ–¹å‘ float rot_x = (p.x - center_x) * angle_cos + (p.y - center_y) * (-angle_sin); float rot_y = (p.x - center_x) * angle_sin + (p.y - center_y) * angle_cos; return (fabs(rot_x) &lt; box[3] / 2 + MARGIN &amp;&amp; fabs(rot_y) &lt; box[4] / 2 + MARGIN);}__device__ inline int intersection(const Point &amp;p1, const Point &amp;p0, const Point &amp;q1, const Point &amp;q0, Point &amp;ans){ // å¿«é€Ÿæ£€æŸ¥ä¸¤çŸ©å½¢æ˜¯å¦ç›¸äº¤ï¼Œä¸ç›¸äº¤æ­¤å‡½æ•°è·³è¿‡ if (check_rect_cross(p0, p1, q0, q1) == 0) return 0; // è®¡ç®—ä¸‰ç‚¹æ„æˆçš„ä¸¤å‘é‡å‰ä¹˜ float s1 = cross(q0, p1, p0); float s2 = cross(p1, q1, p0); float s3 = cross(p0, q1, q0); float s4 = cross(q1, p1, q0); if (!(s1 * s2 &gt; 0 &amp;&amp; s3 * s4 &gt; 0)) return 0; // è®¡ç®—ä¸¤çº¿äº¤ç‚¹ float s5 = cross(q1, p1, p0); if(fabs(s5 - s1) &gt; EPS){ ans.x = (s5 * q0.x - s1 * q1.x) / (s5 - s1); ans.y = (s5 * q0.y - s1 * q1.y) / (s5 - s1); } else{ float a0 = p0.y - p1.y, b0 = p1.x - p0.x, c0 = p0.x * p1.y - p1.x * p0.y; float a1 = q0.y - q1.y, b1 = q1.x - q0.x, c1 = q0.x * q1.y - q1.x * q0.y; float D = a0 * b1 - a1 * b0; ans.x = (b0 * c1 - b1 * c0) / D; ans.y = (a1 * c0 - a0 * c1) / D; } return 1;}__device__ inline float box_overlap(const float *box_a, const float *box_b){ // params box_a: [x, y, z, dx, dy, dz, heading] // params box_b: [x, y, z, dx, dy, dz, heading] float a_angle = box_a[6], b_angle = box_b[6]; float a_dx_half = box_a[3] / 2, b_dx_half = box_b[3] / 2, a_dy_half = box_a[4] / 2, b_dy_half = box_b[4] / 2; float a_x1 = box_a[0] - a_dx_half, a_y1 = box_a[1] - a_dy_half; float a_x2 = box_a[0] + a_dx_half, a_y2 = box_a[1] + a_dy_half; float b_x1 = box_b[0] - b_dx_half, b_y1 = box_b[1] - b_dy_half; float b_x2 = box_b[0] + b_dx_half, b_y2 = box_b[1] + b_dy_half; Point center_a(box_a[0], box_a[1]); Point center_b(box_b[0], box_b[1]); Point box_a_corners[5]; box_a_corners[0].set(a_x1, a_y1); box_a_corners[1].set(a_x2, a_y1); box_a_corners[2].set(a_x2, a_y2); box_a_corners[3].set(a_x1, a_y2); Point box_b_corners[5]; box_b_corners[0].set(b_x1, b_y1); box_b_corners[1].set(b_x2, b_y1); box_b_corners[2].set(b_x2, b_y2); box_b_corners[3].set(b_x1, b_y2); float a_angle_cos = cos(a_angle), a_angle_sin = sin(a_angle); float b_angle_cos = cos(b_angle), b_angle_sin = sin(b_angle); for (int k = 0; k &lt; 4; k++){ rotate_around_center(center_a, a_angle_cos, a_angle_sin, box_a_corners[k]); rotate_around_center(center_b, b_angle_cos, b_angle_sin, box_b_corners[k]); } box_a_corners[4] = box_a_corners[0]; box_b_corners[4] = box_b_corners[0]; // æ±‚ç›´çº¿äº¤ç‚¹ Point cross_points[16]; Point poly_center; int cnt = 0, flag = 0; poly_center.set(0, 0); for (int i = 0; i &lt; 4; i++){ for (int j = 0; j &lt; 4; j++){ flag = intersection(box_a_corners[i + 1], box_a_corners[i], box_b_corners[j + 1], box_b_corners[j], cross_points[cnt]); if (flag){ poly_center = poly_center + cross_points[cnt]; cnt++; } } } // æ£€æŸ¥ABä¸¤çŸ©å½¢æ¡†çš„è§’ç‚¹æ˜¯å¦åœ¨å½¼æ­¤å†…éƒ¨ï¼Œè‹¥è§’ç‚¹åœ¨å½¼æ­¤å†…éƒ¨ï¼Œåˆ™ç›¸äº’äº¤å‰ for (int k = 0; k &lt; 4; k++){ if (check_in_box2d(box_a, box_b_corners[k])){ poly_center = poly_center + box_b_corners[k]; cross_points[cnt] = box_b_corners[k]; cnt++; } if (check_in_box2d(box_b, box_a_corners[k])){ poly_center = poly_center + box_a_corners[k]; cross_points[cnt] = box_a_corners[k]; cnt++; } } poly_center.x /= cnt; poly_center.y /= cnt; // å†’æ³¡æ³•å¯¹é¡¶ç‚¹æ’åº Point temp; for (int j = 0; j &lt; cnt - 1; j++){ for (int i = 0; i &lt; cnt - j - 1; i++){ if (point_cmp(cross_points[i], cross_points[i + 1], poly_center)){ temp = cross_points[i]; cross_points[i] = cross_points[i + 1]; cross_points[i + 1] = temp; } } } // è®¡ç®—é‡å åŒºåŸŸé¢ç§¯ float area = 0; for (int k = 0; k &lt; cnt - 1; k++){ area += cross(cross_points[k] - cross_points[0], cross_points[k + 1] - cross_points[0]); } return fabs(area) / 2.0;}__device__ inline float iou_bev(const float *box_a, const float *box_b){ // params box_a: [x, y, z, dx, dy, dz, heading] // params box_b: [x, y, z, dx, dy, dz, heading] float sa = box_a[3] * box_a[4]; float sb = box_b[3] * box_b[4]; float s_overlap = box_overlap(box_a, box_b); return s_overlap / fmaxf(sa + sb - s_overlap, EPS);}__global__ void nms_kernel(const int boxes_num, const float nms_overlap_thresh, const float *boxes, unsigned long long *mask){ /* params: boxes (N, 7) [x, y, z, dx, dy, dz, heading] 7 -------- 4 /| /| 6 -------- 5 . | | | | . 3 -------- 0 |/ |/ 2 -------- 1 params: mask (N, N/THREADS_PER_BLOCK_NMS) */ const int row_start = blockIdx.y; const int col_start = blockIdx.x; const int row_size = fminf(boxes_num - row_start * THREADS_PER_BLOCK_NMS, THREADS_PER_BLOCK_NMS); const int col_size = fminf(boxes_num - col_start * THREADS_PER_BLOCK_NMS, THREADS_PER_BLOCK_NMS); __shared__ float block_boxes[THREADS_PER_BLOCK_NMS * 7]; if (threadIdx.x &lt; col_size) { block_boxes[threadIdx.x * 7 + 0] = boxes[(THREADS_PER_BLOCK_NMS * col_start + threadIdx.x) * 7 + 0]; block_boxes[threadIdx.x * 7 + 1] = boxes[(THREADS_PER_BLOCK_NMS * col_start + threadIdx.x) * 7 + 1]; block_boxes[threadIdx.x * 7 + 2] = boxes[(THREADS_PER_BLOCK_NMS * col_start + threadIdx.x) * 7 + 2]; block_boxes[threadIdx.x * 7 + 3] = boxes[(THREADS_PER_BLOCK_NMS * col_start + threadIdx.x) * 7 + 3]; block_boxes[threadIdx.x * 7 + 4] = boxes[(THREADS_PER_BLOCK_NMS * col_start + threadIdx.x) * 7 + 4]; block_boxes[threadIdx.x * 7 + 5] = boxes[(THREADS_PER_BLOCK_NMS * col_start + threadIdx.x) * 7 + 5]; block_boxes[threadIdx.x * 7 + 6] = boxes[(THREADS_PER_BLOCK_NMS * col_start + threadIdx.x) * 7 + 6]; } __syncthreads(); if (threadIdx.x &lt; row_size) { const int cur_box_idx = THREADS_PER_BLOCK_NMS * row_start + threadIdx.x; const float *cur_box = boxes + cur_box_idx * 7; int i = 0; unsigned long long t = 0; int start = 0; if (row_start == col_start) { start = threadIdx.x + 1; } for (i = start; i &lt; col_size; i++) { if (iou_bev(cur_box, block_boxes + i * 7) &gt; nms_overlap_thresh){ t |= 1ULL &lt;&lt; i; } } const int col_blocks = DIVUP(boxes_num, THREADS_PER_BLOCK_NMS); mask[cur_box_idx * col_blocks + col_start] = t; }}void nmsLauncher(const float *boxes, unsigned long long * mask, int boxes_num, float nms_overlap_thresh){ dim3 blocks(DIVUP(boxes_num, THREADS_PER_BLOCK_NMS), DIVUP(boxes_num, THREADS_PER_BLOCK_NMS)); dim3 threads(THREADS_PER_BLOCK_NMS); nms_kernel&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(boxes_num, nms_overlap_thresh, boxes, mask);}","link":"/posts/764ef83/"},{"title":"Nvidia GPU &amp; ç®—èƒ½Sophon TPU ç®—å­è€—æ—¶åˆ†æ","text":"1ã€Nvidia GPUè¯¥åˆ†ææ–¹æ³•é€‚åˆonnxæ¨¡å‹æˆ–trtæ¨¡å‹ï¼ŒNVçš„å·¥å…·æ è¾ƒä¸ºæ˜“ç”¨ï¼Œå¯ä½¿ç”¨ trtexec å‘½ä»¤ç›´æ¥è¾“å‡ºç®—å­è€—æ—¶ã€‚æ³¨æ„ï¼Œæœ‰äº›æ˜“äºä¼˜åŒ–è®¡ç®—çš„ç®—å­ï¼ˆä¾‹å¦‚ Conv+Relu ã€Conv+BN+Reluï¼‰ï¼Œä¼šä½œä¸ºä¸€ä¸ªç®—å­é›†è®¡ç®—ï¼Œæ­¤æ—¶æ— æ³•ç›´æ¥è¯»å–åˆ°æ¯ä¸ªç‹¬ç«‹ç®—å­çš„è€—æ—¶ã€‚ é¦–å…ˆéœ€è¦å®‰è£…Nvidia TensorRTåº“ã€CUDA ToolKitï¼ˆæ²¡è¿™ä¿©å’‹ç©å‘€ï¼‰ï¼Œç„¶åä½¿ç”¨trtexecå‘½ä»¤è¡Œå·¥å…·è¿›è¡Œæ¨ç†ã€‚ ç¤ºä¾‹å‘½ä»¤ï¼š 1trtexec --onnx=pfe+backbone_v12.onnx --loadInputs=input.1 --fp16 --exportProfile=bmap_dbg.json --verbose å…¶ä¸­ï¼Œ--onnxå‚æ•°æŒ‡å®šonnxæ–‡ä»¶è·¯å¾„ï¼Œ--loadInputså‚æ•°æŒ‡å®šè¾“å…¥å±‚nameï¼Œ--fp16é€‰é¡¹æŒ‡å®šå¯ç”¨FP16æ¨ç†ã€‚åé¢çš„ä¸¤ä¸ªå‚æ•°ä¸ºç”¨äºåˆ†ææ¨ç†è¿‡ç¨‹ï¼Œ--exportProfileå‚æ•°ç”¨äºå°†æ¯ä¸ªç®—å­å±‚çš„è€—æ—¶åŠå æ¯”ä¿¡æ¯å­˜å…¥.jsonæ–‡ä»¶ï¼Œ --verboseå‚æ•°ç”¨äºè¾“å‡ºè¯¦ç»†æ—¥å¿—ç›®å½•ã€‚ ä»¥ä¸‹æ˜¯å…¨éƒ¨å‚æ•°è¯¦ç»†è¯´æ˜ï¼Œç‰ˆæœ¬ä¸ç¬¦å¯ä»¥ä½¿ç”¨--helpå‚æ•°ï¼Œå¤§è‡´å†…å®¹ç›¸ä¼¼ï¼š å•å‡»å±•å¼€ 1.1 Model Option æ¨¡å‹é€‰é¡¹ â€“uff : UFFæ¨¡å‹æ–‡ä»¶å â€“onnx : ONNXæ¨¡å‹æ–‡ä»¶å â€“model : Caffeæ¨¡å‹æ–‡ä»¶åï¼Œæ¨¡å¼æ—¶æ— æ¨¡å‹ï¼Œä½¿ç”¨éšæœºæƒé‡ â€“deploy : Caffe prototxt æ–‡ä»¶å â€“output : è¾“å‡ºåç§°ï¼ˆå¯å¤šæ¬¡æŒ‡å®šï¼‰ï¼›UFFå’ŒCaffeè‡³å°‘éœ€è¦ä¸€ä¸ªè¾“å‡º â€“uffInput : è¾“å…¥blobåç§°åŠå…¶ç»´åº¦ï¼ˆXã€Yã€Z=Cã€Hã€Wï¼‰ï¼Œå¯ä»¥å¤šæ¬¡æŒ‡å®šï¼›UFFå‹å·è‡³å°‘éœ€è¦ä¸€ä¸ª â€“uffNHWC : è®¾ç½®è¾“å…¥æ˜¯å¦åœ¨NHWCå¸ƒå±€ä¸­è€Œä¸æ˜¯NCHWä¸­ï¼ˆåœ¨â€“uffInputä¸­ä½¿ç”¨Xã€Yã€Z=Hã€Wã€Cé¡ºåºï¼‰ 1.2 Build Options æ„å»ºé€‰é¡¹ â€“maxBatch ï¼š è®¾ç½®æœ€å¤§æ‰¹å¤„ç†å¤§å°å¹¶æ„å»ºéšå¼æ‰¹å¤„ç†å¼•æ“ï¼ˆé»˜è®¤å€¼=1ï¼‰ â€“explicitBatch ï¼šæ„å»ºå¼•æ“æ—¶ä½¿ç”¨æ˜¾å¼æ‰¹é‡å¤§å°ï¼ˆé»˜è®¤ = éšå¼ï¼‰ â€“minShapes=spec ï¼š ä½¿ç”¨æä¾›çš„æœ€å° shape çš„é…ç½®æ–‡ä»¶æ„å»ºåŠ¨æ€ shape â€“optShapes=spec ï¼š ä½¿ç”¨æä¾›çš„ opt shape çš„é…ç½®æ–‡ä»¶æ„å»ºåŠ¨æ€ shape â€“maxShapes=spec ï¼š ä½¿ç”¨æä¾›çš„æœ€å¤§ shape çš„é…ç½®æ–‡ä»¶æ„å»ºåŠ¨æ€ shape â€“minShapesCalib=spec ï¼š ä½¿ç”¨æä¾›çš„æœ€å° shape çš„é…ç½®æ–‡ä»¶æ ¡å‡†åŠ¨æ€ shape â€“optShapesCalib=spec ï¼š ä½¿ç”¨æä¾›çš„ opt shape çš„é…ç½®æ–‡ä»¶æ ¡å‡†åŠ¨æ€ shape â€“maxShapesCalib=spec ï¼šä½¿ç”¨æä¾›çš„æœ€å¤§ shape çš„é…ç½®æ–‡ä»¶æ ¡å‡†åŠ¨æ€ shape æ³¨æ„ï¼šå¿…é¡»æä¾›æ‰€æœ‰ä¸‰ä¸ª minã€opt å’Œ max shape ã€‚ä½†æ˜¯ï¼Œå¦‚æœåªæä¾›äº† opt shape ï¼Œé‚£ä¹ˆå®ƒå°†è¢«æ‰©å±•ï¼Œä»¥ä¾¿å°†æœ€å° shape å’Œæœ€å¤§ shape è®¾ç½®ä¸ºä¸ opt shape ç›¸åŒçš„å€¼ã€‚æ­¤å¤–ï¼Œä½¿ç”¨ åŠ¨æ€ shape æ„å‘³ç€æ˜¾å¼æ‰¹å¤„ç†ã€‚ è¾“å…¥åç§°å¯ä»¥ç”¨è½¬ä¹‰å•å¼•å·æ‹¬èµ·æ¥ï¼ˆä¾‹å¦‚ï¼šâ€˜Input:0â€™ï¼‰ã€‚ç¤ºä¾‹è¾“å…¥ shape è§„èŒƒï¼šinput0:1x3x256x256,input1:1x3x128x128 æ¯ä¸ªè¾“å…¥ shape éƒ½ä½œä¸ºé”®å€¼å¯¹æä¾›ï¼Œå…¶ä¸­ key æ˜¯è¾“å…¥åç§° å€¼æ˜¯ç”¨äºè¯¥è¾“å…¥çš„ç»´åº¦ï¼ˆåŒ…æ‹¬æ‰¹æ¬¡ç»´åº¦ï¼‰ã€‚ æ¯ä¸ªé”®å€¼å¯¹éƒ½ä½¿ç”¨å†’å· (ğŸ˜ƒ åˆ†éš”é”®å’Œå€¼ã€‚ å¯ä»¥é€šè¿‡é€—å·åˆ†éš”çš„é”®å€¼å¯¹æä¾›å¤šä¸ªè¾“å…¥ shape ã€‚ â€“inputIOFormats=spec ï¼š æ¯ä¸ªè¾“å…¥å¼ é‡çš„ç±»å‹å’Œæ ¼å¼ï¼ˆé»˜è®¤æ‰€æœ‰è¾“å…¥ä¸ºfp32:chwï¼‰ æ³¨æ„ï¼šå¦‚æœæŒ‡å®šæ­¤é€‰é¡¹ï¼Œè¯·æŒ‰ç…§ä¸ç½‘ç»œè¾“å…¥IDç›¸åŒçš„é¡ºåºä¸ºæ‰€æœ‰è¾“å…¥è®¾ç½®é€—å·åˆ†éš”çš„ç±»å‹å’Œæ ¼å¼ï¼ˆå³ä½¿åªæœ‰ä¸€ä¸ªè¾“å…¥éœ€è¦æŒ‡å®šIOæ ¼å¼ï¼‰æˆ–è®¾ç½®ä¸€æ¬¡ç±»å‹å’Œæ ¼å¼ä»¥è¿›è¡Œå¹¿æ’­ã€‚ â€“outputIOFormats=spec : æ¯ä¸ªè¾“å‡ºå¼ é‡çš„ç±»å‹å’Œæ ¼å¼ï¼ˆé»˜è®¤æ‰€æœ‰è¾“å…¥ä¸ºfp32:chwï¼‰ æ³¨æ„ï¼šå¦‚æœæŒ‡å®šæ­¤é€‰é¡¹ï¼Œè¯·æŒ‰ç…§ä¸ç½‘ç»œè¾“å‡ºIDç›¸åŒçš„é¡ºåºä¸ºæ‰€æœ‰è¾“å‡ºè®¾ç½®é€—å·åˆ†éš”çš„ç±»å‹å’Œæ ¼å¼ï¼ˆå³ä½¿åªæœ‰ä¸€ä¸ªè¾“å‡ºéœ€è¦æŒ‡å®šIOæ ¼å¼ï¼‰æˆ–è®¾ç½®ä¸€æ¬¡ç±»å‹å’Œæ ¼å¼ä»¥è¿›è¡Œå¹¿æ’­ã€‚ â€“workspace=N ï¼š ä»¥Mä¸ºå•ä½è®¾ç½®å·¥ä½œåŒºå¤§å°ï¼ˆé»˜è®¤å€¼ = 16ï¼‰ â€“noBuilderCache : åœ¨æ„å»ºå™¨ä¸­ç¦ç”¨æ—¶åºç¼“å­˜ï¼ˆé»˜è®¤æ˜¯å¯ç”¨æ—¶åºç¼“å­˜ï¼‰ â€“nvtxMode=mode : æŒ‡å®š NVTX æ³¨é‡Šè¯¦ç»†ç¨‹åº¦ã€‚ mode ::= default|verbose|none â€“minTiming=M : è®¾ç½®å†…æ ¸é€‰æ‹©ä¸­ä½¿ç”¨çš„æœ€å°è¿­ä»£æ¬¡æ•°ï¼ˆé»˜è®¤å€¼ = 1ï¼‰ â€“avgTiming=M : ä¸ºå†…æ ¸é€‰æ‹©è®¾ç½®æ¯æ¬¡è¿­ä»£çš„å¹³å‡æ¬¡æ•°ï¼ˆé»˜è®¤å€¼ = 8ï¼‰ â€“noTF32 : ç¦ç”¨ tf32 ç²¾åº¦ï¼ˆé»˜è®¤æ˜¯å¯ç”¨ tf32ï¼Œé™¤äº† fp32ï¼‰ â€“refit : å°†å¼•æ“æ ‡è®°ä¸ºå¯æ”¹è£…ã€‚è¿™å°†å…è®¸æ£€æŸ¥å¼•æ“å†…çš„å¯æ”¹è£…å±‚å’Œé‡é‡ã€‚ â€“fp16 ï¼š é™¤ fp32 å¤–ï¼Œå¯ç”¨ fp16 ç²¾åº¦ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“int8 : é™¤ fp32 å¤–ï¼Œå¯ç”¨ int8 ç²¾åº¦ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“best : å¯ç”¨æ‰€æœ‰ç²¾åº¦ä»¥è¾¾åˆ°æœ€ä½³æ€§èƒ½ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“calib= : è¯»å–INT8æ ¡å‡†ç¼“å­˜æ–‡ä»¶ â€“safe : ä»…æµ‹è¯•å®‰å…¨å—é™æµä¸­å¯ç”¨çš„åŠŸèƒ½ â€“saveEngine= : ä¿å­˜åºåˆ—åŒ–æ¨¡å‹çš„æ–‡ä»¶å â€“loadEngine= ï¼š åŠ è½½åºåˆ—åŒ–æ¨¡å‹çš„æ–‡ä»¶å â€“tacticSources=tactics ï¼š é€šè¿‡ä»é»˜è®¤ç­–ç•¥æºï¼ˆé»˜è®¤ = æ‰€æœ‰å¯ç”¨ç­–ç•¥ï¼‰ä¸­æ·»åŠ  (+) æˆ–åˆ é™¤ (-) ç­–ç•¥æ¥æŒ‡å®šè¦ä½¿ç”¨çš„ç­–ç•¥ã€‚ 1.3 Inference Options æ¨ç†é€‰é¡¹ â€“batch=N ï¼š ä¸ºéšå¼æ‰¹å¤„ç†å¼•æ“è®¾ç½®æ‰¹å¤„ç†å¤§å°ï¼ˆé»˜è®¤å€¼ = 1ï¼‰ â€“shapes=spec ï¼š ä¸ºåŠ¨æ€ shape æ¨ç†è¾“å…¥è®¾ç½®è¾“å…¥ shape ã€‚ æ³¨æ„ï¼šä½¿ç”¨åŠ¨æ€ shape æ„å‘³ç€æ˜¾å¼æ‰¹å¤„ç†ã€‚ è¾“å…¥åç§°å¯ä»¥ç”¨è½¬ä¹‰çš„å•å¼•å·æ‹¬èµ·æ¥ï¼ˆä¾‹å¦‚ï¼šâ€˜Input:0â€™ï¼‰ã€‚ ç¤ºä¾‹è¾“å…¥ shape è§„èŒƒï¼šinput0:1x3x256x256, input1:1x3x128x128 æ¯ä¸ªè¾“å…¥ shape éƒ½ä½œä¸ºé”®å€¼å¯¹æä¾›ï¼Œå…¶ä¸­é”®æ˜¯è¾“å…¥åç§°ï¼Œå€¼æ˜¯ç”¨äºè¯¥è¾“å…¥çš„ç»´åº¦ï¼ˆåŒ…æ‹¬æ‰¹æ¬¡ç»´åº¦ï¼‰ã€‚ æ¯ä¸ªé”®å€¼å¯¹éƒ½ä½¿ç”¨å†’å· (ğŸ˜ƒ åˆ†éš”é”®å’Œå€¼ã€‚ å¯ä»¥é€šè¿‡é€—å·åˆ†éš”çš„é”®å€¼å¯¹æä¾›å¤šä¸ªè¾“å…¥ shape ã€‚ â€“loadInputs=spec ï¼šä»æ–‡ä»¶åŠ è½½è¾“å…¥å€¼ï¼ˆé»˜è®¤ = ç”Ÿæˆéšæœºè¾“å…¥ï¼‰ã€‚ è¾“å…¥åç§°å¯ä»¥ç”¨å•å¼•å·æ‹¬èµ·æ¥ï¼ˆä¾‹å¦‚ï¼šâ€˜Input:0â€™ï¼‰ â€“iterations=N ï¼š è‡³å°‘è¿è¡Œ N æ¬¡æ¨ç†è¿­ä»£ï¼ˆé»˜è®¤å€¼ = 10ï¼‰ â€“warmUp=N ï¼š åœ¨æµ‹é‡æ€§èƒ½ä¹‹å‰è¿è¡Œ N æ¯«ç§’ä»¥é¢„çƒ­ï¼ˆé»˜è®¤å€¼ = 200ï¼‰ â€“duration=N ï¼š è¿è¡Œè‡³å°‘ N ç§’æŒ‚é’Ÿæ—¶é—´çš„æ€§èƒ½æµ‹é‡ï¼ˆé»˜è®¤å€¼ = 3ï¼‰ â€“sleepTime=N ï¼š å»¶è¿Ÿæ¨ç†ä»¥å¯åŠ¨å’Œè®¡ç®—ä¹‹é—´çš„ N æ¯«ç§’é—´éš”å¼€å§‹ï¼ˆé»˜è®¤ = 0ï¼‰ â€“streams=N ï¼š å®ä¾‹åŒ– N ä¸ªå¼•æ“ä»¥åŒæ—¶ä½¿ç”¨ï¼ˆé»˜è®¤å€¼ = 1ï¼‰ â€“exposeDMA ï¼š ä¸²è¡ŒåŒ–è¿›å‡ºè®¾å¤‡çš„ DMA ä¼ è¾“ã€‚ ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“noDataTransfers ï¼š åœ¨æ¨ç†è¿‡ç¨‹ä¸­ï¼Œè¯·å‹¿å°†æ•°æ®ä¼ å…¥å’Œä¼ å‡ºè®¾å¤‡ã€‚ ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“useSpinWait ï¼š ä¸»åŠ¨åŒæ­¥ GPU äº‹ä»¶ã€‚ æ­¤é€‰é¡¹å¯èƒ½ä¼šå‡å°‘åŒæ­¥æ—¶é—´ï¼Œä½†ä¼šå¢åŠ  CPU ä½¿ç”¨ç‡å’ŒåŠŸç‡ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“threads ï¼š å¯ç”¨å¤šçº¿ç¨‹ä»¥é©±åŠ¨å…·æœ‰ç‹¬ç«‹çº¿ç¨‹çš„å¼•æ“ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“useCudaGraph ï¼š ä½¿ç”¨ cuda å›¾æ•è·å¼•æ“æ‰§è¡Œï¼Œç„¶åå¯åŠ¨æ¨ç†ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“separateProfileRun ï¼š ä¸è¦åœ¨åŸºå‡†æµ‹è¯•ä¸­é™„åŠ åˆ†æå™¨ï¼› å¦‚æœå¯ç”¨åˆ†æï¼Œå°†æ‰§è¡Œç¬¬äºŒæ¬¡åˆ†æè¿è¡Œï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“buildOnly ï¼š è·³è¿‡æ¨ç†æ€§èƒ½æµ‹é‡ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ 1.4 Build and Inference Batch Options æ„å»ºå’Œæ¨ç†æ‰¹å¤„ç†é€‰é¡¹ ä½¿ç”¨éšå¼æ‰¹å¤„ç†æ—¶ï¼Œå¼•æ“çš„æœ€å¤§æ‰¹å¤„ç†å¤§å°ï¼ˆå¦‚æœæœªæŒ‡å®šï¼‰è®¾ç½®ä¸ºæ¨ç†æ‰¹å¤„ç†å¤§å°ï¼› ä½¿ç”¨æ˜¾å¼æ‰¹å¤„ç†æ—¶ï¼Œå¦‚æœä»…æŒ‡å®š shape ç”¨äºæ¨ç†ï¼Œå®ƒä»¬ä¹Ÿå°†åœ¨æ„å»ºé…ç½®æ–‡ä»¶ä¸­ç”¨ä½œ min/opt/maxï¼› å¦‚æœåªä¸ºæ„å»ºæŒ‡å®šäº† shape ï¼Œåˆ™ opt shape ä¹Ÿå°†ç”¨äºæ¨ç†ï¼› å¦‚æœä¸¤è€…éƒ½è¢«æŒ‡å®šï¼Œå®ƒä»¬å¿…é¡»æ˜¯å…¼å®¹çš„ï¼› å¦‚æœå¯ç”¨äº†æ˜¾å¼æ‰¹å¤„ç†ä½†éƒ½æœªæŒ‡å®šï¼Œåˆ™æ¨¡å‹å¿…é¡»ä¸ºæ‰€æœ‰è¾“å…¥æä¾›å®Œæ•´çš„é™æ€ç»´åº¦ï¼ŒåŒ…æ‹¬æ‰¹å¤„ç†å¤§å° 1.5 Reporting Options æŠ¥å‘Šé€‰é¡¹ â€“verbose ï¼š ä½¿ç”¨è¯¦ç»†æ—¥å¿—è®°å½•ï¼ˆé»˜è®¤å€¼ = falseï¼‰ â€“avgRuns=N ï¼š æŠ¥å‘Š N æ¬¡è¿ç»­è¿­ä»£çš„å¹³å‡æ€§èƒ½æµ‹é‡å€¼ï¼ˆé»˜è®¤å€¼ = 10ï¼‰ â€“percentile=P ï¼š æŠ¥å‘Š P ç™¾åˆ†æ¯”çš„æ€§èƒ½ P=(0~100)ï¼Œ0 ä»£è¡¨æœ€å¤§æ€§èƒ½ï¼Œ100 ä»£è¡¨æœ€å°æ€§èƒ½ï¼›ï¼ˆé»˜è®¤ = 99%ï¼‰ï¼‰ â€“dumpRefit ï¼š ä»å¯æ”¹è£…å¼•æ“æ‰“å°å¯æ”¹è£…å±‚å’Œé‡é‡ â€“dumpOutput ï¼š æ‰“å°æœ€åä¸€æ¬¡æ¨ç†è¿­ä»£çš„è¾“å‡ºå¼ é‡ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“dumpProfile ï¼š æ¯å±‚æ‰“å°é…ç½®æ–‡ä»¶ä¿¡æ¯ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“exportTimes= ï¼š å°†è®¡æ—¶ç»“æœå†™å…¥ json æ–‡ä»¶ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“exportOutput= ï¼š å°†è¾“å‡ºå¼ é‡å†™å…¥ json æ–‡ä»¶ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“exportProfile= ï¼š å°†æ¯å±‚çš„é…ç½®æ–‡ä»¶ä¿¡æ¯å†™å…¥ json æ–‡ä»¶ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ 1.6 System Options ç³»ç»Ÿé€‰é¡¹ â€“device=N ï¼šé€‰æ‹© cuda è®¾å¤‡ Nï¼ˆé»˜è®¤ = 0ï¼‰ â€“useDLACore=N ï¼š ä¸ºæ”¯æŒ DLA çš„å±‚é€‰æ‹© DLA æ ¸å¿ƒ Nï¼ˆé»˜è®¤ = æ— ï¼‰ â€“allowGPUFallback ï¼š å¯ç”¨ DLA åï¼Œå…è®¸ GPU å›é€€ä¸å—æ”¯æŒçš„å±‚ï¼ˆé»˜è®¤ = ç¦ç”¨ï¼‰ â€“plugins ï¼š è¦åŠ è½½çš„æ’ä»¶åº“ (.so)ï¼ˆå¯ä»¥å¤šæ¬¡æŒ‡å®šï¼‰ 1.7 Help å¸®åŠ© â€“help, -h ï¼š æ‰“å°ä»¥ä¸Šå¸®åŠ©ä¿¡æ¯ æ‰§è¡Œå®Œæˆåï¼Œä¼šåœ¨å½“å‰ç›®å½•ç”Ÿæˆä¸€ä¸ªjsonæ–‡ä»¶ï¼Œå†…å®¹åŒ…å«ï¼šç®—å­å±‚åç§°ã€å…±è®¡æ‰§è¡Œæ—¶é—´ï¼ˆè¿è¡Œæ—¶é—´ä¸é‡å¤è¿è¡Œæ¬¡æ•°ç›¸å…³ï¼Œéå•æ¬¡æ‰§è¡Œæ—¶é—´ï¼‰ã€å¹³å‡å•æ¬¡æ‰§è¡Œæ—¶é—´ã€å ç”¨ç‡ã€‚ è¾“å‡ºç¤ºä¾‹ï¼š 123456789[ { &quot;count&quot; : 252 }, { &quot;name&quot; : &quot;Reformatting CopyNode for Input Tensor 0 to Pad_0 + Conv_1 + Relu_2&quot;, &quot;timeMs&quot; : 75.319, &quot;averageMs&quot; : 0.298885, &quot;percentage&quot; : 6.04541 }, { &quot;name&quot; : &quot;Pad_0 + Conv_1 + Relu_2&quot;, &quot;timeMs&quot; : 52.394, &quot;averageMs&quot; : 0.207913, &quot;percentage&quot; : 4.20535 }, { &quot;name&quot; : &quot;Conv_3 + Relu_4&quot;, &quot;timeMs&quot; : 44.4168, &quot;averageMs&quot; : 0.176257, &quot;percentage&quot; : 3.56507 }, { &quot;name&quot; : &quot;Conv_5 + Relu_6&quot;, &quot;timeMs&quot; : 43.1007, &quot;averageMs&quot; : 0.171035, &quot;percentage&quot; : 3.45944 }, { &quot;name&quot; : &quot;Conv_7 + Relu_8&quot;, &quot;timeMs&quot; : 42.7234, &quot;averageMs&quot; : 0.169537, &quot;percentage&quot; : 3.42915 }, { &quot;name&quot; : &quot;Conv_9 + Relu_10&quot;, &quot;timeMs&quot; : 16.1732, &quot;averageMs&quot; : 0.0641793, &quot;percentage&quot; : 1.29812 }] ä¸Šé¢ä»…æ˜¯ç®€å•åˆ†æç®—å­ç°‡è€—æ—¶ï¼Œå…¶å®NVè¿˜æä¾›äº†å¾ˆå¤šåˆ†æå·¥å…·ï¼Œä¾‹å¦‚NVIDIA Nsightâ„¢ Systemsï¼Œå®ƒå¯ä»¥é€šè¿‡å¤šç§æ–¹å¼é…ç½®ï¼Œä»¥ä»…æŠ¥å‘Šç¨‹åºæ‰§è¡Œçš„ä¸€éƒ¨åˆ†çš„æ—¶åºä¿¡æ¯ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥å°†ä¼ ç»Ÿçš„ CPU é‡‡æ ·é…ç½®æ–‡ä»¶ä¿¡æ¯ä¸ GPU ä¿¡æ¯ä¸€èµ·æŠ¥å‘Šã€‚ 2ã€Sophon TPUç®—èƒ½TPUæä¾›äº†TPU Profileå·¥å…·ï¼Œå¸®åŠ©å®Œæˆç®—å­åˆ†æã€‚TPUå†…éƒ¨ä¸»è¦ç”±MCUã€GDMAã€TIUä¸‰ä¸ªengineæ¥å®Œæˆå·¥ä½œã€‚ MCUåœ¨BM1684Xä¸Šæ˜¯ä¸€ä¸ªå•æ ¸çš„A53å¤„ç†å™¨ï¼Œé€šè¿‡firmwareå›ºä»¶ç¨‹åºå®Œæˆå‘GDMAã€TIUä¸¤ä¸ªengineä¸‹å‘å‘½ä»¤ã€é©±åŠ¨é€šä¿¡ã€ç®€å•è®¡ç®—ç­‰å…·ä½“åŠŸèƒ½ï¼Œå®ç°äº†ç®—å­çš„å…·ä½“é€»è¾‘ã€‚ GDMAå’ŒTIUæ˜¯å®é™…çš„æ‰§è¡Œå¼•æ“ï¼ŒGDMAç”¨äºGlobal memä¸Local memä¹‹é—´ä¼ è¾“æ•°æ®ï¼Œå®ç°äº†1Dã€çŸ©é˜µã€4Dç­‰æ•°æ®æ¬è¿åŠŸèƒ½ï¼›TIUå¯¹local memä¸­çš„æ•°æ®æ‰§è¡Œå¯†é›†è®¡ç®—å‘½ä»¤ï¼ŒåŒ…æ‹¬å·ç§¯ã€çŸ©é˜µä¹˜æ³•ã€ç®—æœ¯ç­‰åŸå­æ“ä½œã€‚ 2.1ã€åˆ†ææµç¨‹ç®€è¿°åˆ†ææµç¨‹ï¼Œè‹¥ç¨‹åºåœ¨X86æ¶æ„æœåŠ¡å™¨å®Œæˆç¼–è¯‘ï¼Œåœ¨è¾¹ç¼˜è®¡ç®—ç›’æ¨ç†ï¼Œåˆ†æä¸»è¦åˆ†ä¸ºå…­æ­¥ã€‚è‹¥ç¼–è¯‘æ¨ç†åœ¨åŒåŸŸå†…è¿›è¡Œï¼Œå¯çœå»æ•°æ®æ‹·è´æµç¨‹ï¼Œåˆ†ä¸ºå››æ­¥ã€‚ [æœåŠ¡å™¨] ç¨‹åºç”Ÿæˆmlir -&gt; [æœåŠ¡å™¨] mlirè½¬bmodel -&gt; [æœåŠ¡å™¨] bmodelæ‹·è´è‡³SE7-&gt;[SE7] è¿è¡Œç”Ÿæˆdataæ–‡ä»¶-&gt;[SE7] ç»“æœæ‹·å›æœåŠ¡å™¨ -&gt; [æœåŠ¡å™¨] dataè½¬æ¢ä¸ºHTML profileå¯è§†åŒ– [æœåŠ¡å™¨] ç¨‹åºç”Ÿæˆmlir é¦–å…ˆè¿›å…¥dockerç¯å¢ƒï¼Œsourceè¿è¡Œç¯å¢ƒ ``` 1source /workspace/tpu-mlir_v1.3.140-g3180ff37-20231116/envsetup.sh ç”Ÿæˆmliræ–‡ä»¶ï¼Œéœ€è¦æ›´æ”¹onnxæ¨¡å‹å¯¹åº”shapeåŠè¾“å‡ºèŠ‚ç‚¹å ```1model_transform.py --model_name pp_bmap --model_def ./pfe+backbone_v12.onnx --input_shapes [[1,40,512,512]] --keep_aspect_ratio --output_names '273','320','367','414','461','508','542' --mlir bmap_dbg_1.mlir [æœåŠ¡å™¨] mlirè½¬bmodel åœ¨ä¸Šä¸€æ­¥åŸºç¡€ä¸Šï¼Œè¿è¡Œmodel_deploy æ³¨æ„ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œä¼šå°†ç®—å­èåˆæˆç®—å­ç°‡æ¥è®¡ç®—ï¼Œä¼˜åŒ–æ¨ç†æ•ˆç‡ã€‚å¦‚æœéœ€è¦å¯¹å•ç‹¬ç®—å­è¿›è¡Œè¯„ä¼°ï¼Œå‘½ä»¤éœ€è¦åŠ --disable_layer_groupå‚æ•°æ¥ç¦ç”¨ç®—å­èåˆæ“ä½œã€‚ ``` 1model_deploy.py --mlir bmap_dbg_1.mlir --quantize F16 --chip bm1684x --test_input ../concat_in_f32.npz --test_reference ../concat_top_outputs.npz --debug --compare_all --model bmap_dbg_2_F16F32.bmodel --quantize_table qtable_con --disable_layer_group å°†ç”Ÿæˆçš„bmodelæ‹·è´è‡³SE7ç­‰è¾¹ç¼˜è®¡ç®—è®¾å¤‡ (å¯é€‰) [SE7] è¿è¡Œç”Ÿæˆdataæ–‡ä»¶ ``` 12# é€šè¿‡ç¯å¢ƒå˜é‡(BMRUNTIME_ENABLE_PROFILE)ä½¿èƒ½profile, ç”ŸæˆäºŒè¿›åˆ¶æ•°æ®BMRUNTIME_ENABLE_PROFILE=1 bmrt_test --bmodel bmap_dbg_2_F16F32.bmodel ä½¿èƒ½profileè¿è¡Œä¼šç”Ÿæˆä¸€ä¸ªbmprofile_data-1çš„æ–‡ä»¶å¤¹ï¼Œå†…éƒ¨åŒ…å«è¿è¡Œæ•°æ® å°†è¯¥æ–‡ä»¶å¤¹æ‹·è´è‡³æœåŠ¡å™¨ï¼ˆå¯é€‰ï¼‰ [æœåŠ¡å™¨] dataè½¬æ¢ä¸ºHTML profileå¯è§†åŒ– ``` 1tpu_profile.py --arch BM1684X bmprofile_data-1 out_dir è¿è¡Œä¼šç”Ÿæˆout_diræ–‡ä»¶å¤¹ï¼Œå†…éƒ¨åŒ…å«jsonæ•°æ®å’Œhtmlæ–‡ä»¶ï¼Œæµè§ˆå™¨æ‰“å¼€å³å¯æŸ¥çœ‹æ•°æ®ã€‚ tipsï¼šdockerä¸ä¸»æœºæ‹·è´å‘½ä»¤ ``` 1sudo docker cp se7:/workspace/concat/layer/bmprofile_out_1 /home/username/ é€€å‡ºdockerï¼šctrl+D ç”Ÿæˆæ—¶åºå›¾æ•°æ®åï¼Œå¯æŒ‰éœ€æŸ¥çœ‹å¹¶åˆ†æã€‚è¯¦ç»†è¯´æ˜è¯·è§tpu-mlirå®˜æ–¹è¯´æ˜ : TPU Profileå·¥å…·ä½¿ç”¨åŠåˆ†æ | TPUMLIR å¼€æºå·¥å…·é“¾é¡¹ç›® | é€šç”¨ AI ç¼–è¯‘å™¨å·¥å…·é“¾é¡¹ç›®ï¼Œé«˜æ•ˆå°†æ¨¡å‹ç¼–è¯‘ç”Ÿæˆ TPU æ‰§è¡Œä»£ç ","link":"/posts/186ec257/"},{"title":"NVIDIA GPU æ¶æ„ä¸ CUDA ç®—åŠ›","text":"ä½¿ç”¨NVCCç¼–è¯‘æ—¶ï¼ŒGencodesï¼ˆâ€™-gencodeâ€˜ï¼‰åå¸¦archå’Œcodeå‚æ•°ã€‚archæ ‡å¿—ï¼ˆâ€™archâ€˜ï¼‰æŒ‡å®šäº†CUDAæ–‡ä»¶å°†è¢«ç¼–è¯‘çš„è‹±ä¼Ÿè¾¾ï¼ˆNVIDIAÂ®ï¼‰GPUæ¶æ„åç§°ï¼Œcodeæ ‡å¿—ï¼ˆâ€™codeâ€˜ï¼‰æŒ‡å®šäº†GPUç®—åŠ›ã€‚ä¾‹å¦‚ ï¼ˆâ€™-gencode arch=compute_75,code=sm_75â€˜ï¼‰ ä»¥ä¸‹æ˜¯ NVIDIA GPU æ¶æ„åç§°åŠå…¶ç®—åŠ›å¯¹ç…§è¡¨ï¼š Fermi â€  Kepler â€  Maxwell â€¡ Pascal Volta Turing Ampere Ada Hopper Blackwell sm_20 sm_30 sm_50 sm_60 sm_70 sm_75 sm_80 sm_89 sm_90 sm_95 sm_35 sm_52 sm_61 sm_72(Xavier) sm_86 sm_90a (Thor) sm_37 sm_53 sm_62 sm_87 (Orin) â€  ä» CUDA 9 å’Œ 11 å¼€å§‹ï¼ŒFermi å’Œ Kepler å·²è¢«å¼ƒç”¨â€¡ è‡ª CUDA 11.6 èµ·ï¼ŒMaxwell å·²è¢«å¼ƒç”¨ Q&amp;A1. ä½•æ—¶åº”ä½¿ç”¨ä¸åŒçš„ â€œgencodes â€œæˆ– â€œcuda archâ€ï¼Ÿç¼–è¯‘ CUDA ä»£ç æ—¶ï¼Œåº”å§‹ç»ˆåªç¼–è¯‘ä¸€ä¸ªä¸æœ€å¸¸ç”¨çš„ GPU æ˜¾å¡ç›¸åŒ¹é…çš„ â€œ-archâ€œæ ‡å¿—ã€‚è¿™å°†åŠ å¿«è¿è¡Œé€Ÿåº¦ï¼Œå› ä¸ºä»£ç ç”Ÿæˆå°†åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­è¿›è¡Œã€‚å¦‚æœåªæåŠ â€œ-gencodeâ€œï¼Œå´çœç•¥äº† â€œ-archâ€œæ ‡å¿—ï¼Œé‚£ä¹ˆ GPU ä»£ç ç”Ÿæˆå°†åœ¨ JIT ç¼–è¯‘å™¨ä¸Šç”± CUDA é©±åŠ¨ç¨‹åºå®Œæˆã€‚ å¦‚æœæƒ³åŠ å¿« CUDA ç¼–è¯‘é€Ÿåº¦ï¼Œå°±éœ€è¦å‡å°‘æ— å…³çš„ â€œ-gencodeâ€œæ ‡å¿—ã€‚ä¸è¿‡ï¼Œæœ‰æ—¶å¯èƒ½å¸Œæœ›é€šè¿‡æ·»åŠ æ›´å…¨é¢çš„ â€œ-gencodeâ€œæ ‡è®°æ¥è·å¾—æ›´å¥½çš„ CUDA å‘åå…¼å®¹æ€§ã€‚ åœ¨ç»§ç»­ä¹‹å‰ï¼Œè¯·å…ˆç¡®å®š GPU å’Œ å®‰è£…çš„ CUDA ç‰ˆæœ¬ã€‚ 2. CUDA ç‰ˆæœ¬ä¸ GPU æ ¸å¿ƒæ¶æ„è¯¦ç»†åˆ—è¡¨Fermi æ¶æ„ (CUDA 3.2 è‡³ CUDA 8)ä»CUDA 9å¼€å§‹ï¼Œkepleræ¶æ„å·²è¢«å¼ƒç”¨ï¼ŒCUDA10å¼€å§‹å®Œå…¨åœæ­¢æ”¯æŒ. SM20 -&gt; SM_20, compute_30 â€“GeForce 400, 500, 600, GT-630. ** Kepler æ¶æ„ (CUDA 5 è‡³ CUDA 10)ä»CUDA 11å¼€å§‹ï¼Œkepleræ¶æ„å·²è¢«å¼ƒç”¨. SM30 -&gt; SM_30, compute_30 â€“Kepler æ¶æ„ (e.g. generic Kepler, GeForce 700, GT-730). SM35 -&gt; SM_35, compute_35 â€“Tesla K40. SM37 -&gt;SM_37, compute_37 â€“Tesla K80. Maxwell æ¶æ„ (CUDA 6 è‡³ CUDA 11)ä»CUDA 11å¼€å§‹ï¼ŒMaxwellæ¶æ„å·²è¢«å¼ƒç”¨. SM50 -&gt;SM_50, compute_50 â€“Tesla/Quadro M ç³»åˆ—. SM52 -&gt;SM_52, compute_52 â€“Quadro M6000 , GeForce 900, GTX-970, GTX-980, GTX Titan X. SM53 -&gt;SM_53, compute_53 â€“Tegra (Jetson) TX1 / Tegra X1, Drive CX, Drive PX, Jetson Nano. Pascal æ¶æ„ (CUDA 8 è‡³ä»Š) SM60 or SM_60, compute_60 â€“Quadro GP100, Tesla P100, DGX-1 (Generic Pascal) SM61 or SM_61, compute_61â€“GTX 1080, GTX 1070, GTX 1060, GTX 1050, GTX 1030 (GP108), GT 1010 (GP108) Titan Xp, Tesla P40, Tesla P4, NVIDIA Drive PX2 SM62 or SM_62, compute_62 â€“NVIDIA Drive PX2, Tegra (Jetson) TX2 Volta æ¶æ„ (CUDA 9 è‡³ä»Š) SM70 or SM_70, compute_70 â€“DGX-1 with Volta, Tesla V100, GTX 1180 (GV104), Titan V, Quadro GV100 SM72 or SM_72, compute_72 â€“Jetson AGX Xavier, Drive AGX Pegasus, Xavier NX Turing æ¶æ„ (CUDA 10 è‡³ä»Š) SM75 or SM_75, compute_75 â€“GTX/RTX Turing â€“ GTX 1660 Ti, RTX 2060, RTX 2070, RTX 2080, Titan RTX, Quadro RTX 4000, Quadro RTX 5000, Quadro RTX 6000, Quadro RTX 8000, Quadro T1000/T2000, Tesla T4 Ampere æ¶æ„ (CUDA 11.1 è‡³ä»Š) SM80 or SM_80, compute_80 â€“NVIDIA A100 (â€œTeslaâ€ å‘½åä»æ­¤ä»£å¼€å§‹åœç”¨ â€“ GA100), NVIDIA DGX-A100 SM86 or SM_86, compute_86 â€“ (CUDA 11.1 onwards)Tesla GA10x cards, RTX Ampere â€“ RTX 3080, GA102 â€“ RTX 3090, RTX A2000, A3000, RTX A4000, A5000, A6000, NVIDIA A40, GA106 â€“ RTX 3060, GA104 â€“ RTX 3070, GA107 â€“ RTX 3050, RTX A10, RTX A16, RTX A40, A2 Tensor Core GPU SM87 or SM_87, compute_87 â€“ (CUDA 11.4 onwards, é‡‡ç”¨ PTX ISA 7.4 / é©±åŠ¨ç¨‹åº r470 åŠæ›´æ–°ç‰ˆæœ¬ï¼‰- è¯¥é¡¹ä»…é€‚ç”¨äº Jetson AGX Orin å’Œ Drive AGX Orin â€œä¸è®¡ç®—èƒ½åŠ›ä¸º 8.0 çš„è®¾å¤‡ç›¸æ¯”ï¼Œè®¡ç®—èƒ½åŠ›ä¸º 8.6 çš„è®¾å¤‡æ¯ä¸ª SM æ¯ä¸ªå‘¨æœŸçš„ FP32 æ“ä½œé‡å¢åŠ äº† 2 å€ã€‚è™½ç„¶ä¸º 8.0 ç¼–è¯‘çš„äºŒè¿›åˆ¶æ–‡ä»¶å¯ä»¥åœ¨ 8.6 ä¸ŠåŸæ ·è¿è¡Œï¼Œä½†å»ºè®®æ˜ç¡®ä¸º 8.6 è¿›è¡Œç¼–è¯‘ï¼Œä»¥ä¾¿ä»å¢åŠ çš„ FP32 ååé‡ä¸­è·ç›Šã€‚.â€œ https://docs.nvidia.com/cuda/ampere-tuning-guide/index.html#improved_fp32 Ada Lovelace æ¶æ„ (CUDA 11.8 è‡³ä»Š) SM89 or SM_89, compute_89 â€“NVIDIA GeForce RTX 4090, RTX 4080, RTX 4070, RTX 4060, RTX 6000 Ada, Tesla L40, L40s Ada, L4 Ada Hopper æ¶æ„ (CUDA 12 è‡³ä»Š) SM90 or SM_90, compute_90 â€“NVIDIA H100 (GH100), NVIDIA H200 SM90a or SM_90a, compute_90a â€“ (é€‚ç”¨äº PTX ISA 8.0 ç‰ˆï¼‰- ä¸º wgmma å’Œ setmaxnreg ç­‰åŠŸèƒ½æ·»åŠ äº†åŠ é€ŸåŠŸèƒ½ã€‚è‹±ä¼Ÿè¾¾â„¢ï¼ˆNVIDIAÂ®ï¼‰CUTLASS éœ€è¦æ­¤åŠŸèƒ½ã€‚ Blackwell æ¶æ„ (CUDA 12 è‡³ä»Š) SM95 or SM_95, compute_95 â€“NVIDIA B100 (GB100) 3. GCC ä¸­çš„ nvcc``gencode å’Œ arch æ ‡å¿—ç¤ºä¾‹æ³¨æ„ï¼šå¦‚æœåœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œéƒ¨ç½²çš„è®¡ç®—å¡æ˜¯å›ºå®šçš„å‹å·ï¼Œä¸éœ€è¦å…¼å®¹æ€§æ—¶ï¼Œå¦‚A100ï¼Œnvccç”Ÿæˆæ—¶å»ºè®®å›ºå®šæŒ‡å®šç®—åŠ›æ•°æ®ï¼Œå¯ä»¥æœ€å¤§ç¨‹åº¦ä¿è¯ç®—åŠ›ä¸ä¼šæµªè´¹ã€‚ æ ¹æ® NVIDIA æä¾›çš„ä¿¡æ¯ï¼š nvcc çš„ -gencode= å‘½ä»¤è¡Œé€‰é¡¹ä¸­çš„ arch= æŒ‡å®šå‰ç«¯ç¼–è¯‘ç›®æ ‡ï¼Œå¹¶ä¸”å¿…é¡»å§‹ç»ˆæ˜¯ PTX ç‰ˆæœ¬ã€‚code= æŒ‡å®šåç«¯ç¼–è¯‘ç›®æ ‡ï¼Œå¯ä»¥æ˜¯ cubin æˆ– PTXï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸¤è€…ã€‚ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶å°†åªä¿ç•™ code= æŒ‡å®šçš„åç«¯ç›®æ ‡ç‰ˆæœ¬ï¼›è‡³å°‘æœ‰ä¸€ä¸ªç‰ˆæœ¬å¿…é¡»æ˜¯ PTXï¼Œä»¥æä¾› Ampere å…¼å®¹æ€§ã€‚ åœ¨ CUDA 7.0 ä¸Šç”Ÿæˆ GCC çš„ç¤ºä¾‹flagï¼Œå¯æœ€å¤§ç¨‹åº¦åœ°å…¼å®¹è¯¥æ—¶ä»£çš„æ‰€æœ‰æ˜¾å¡ï¼š -arch=sm_30 \\ -gencode=arch=compute_20,code=sm_20 \\ -gencode=arch=compute_30,code=sm_30 \\ -gencode=arch=compute_50,code=sm_50 \\ -gencode=arch=compute_52,code=sm_52 \\ -gencode=arch=compute_52,code=compute_52 åœ¨ CUDA 8.1 ä¸Šç”Ÿæˆçš„ç¤ºä¾‹flagï¼Œå¯ä¸ Volta ä¹‹å‰çš„æ˜¾å¡å®ç°æœ€å¤§ç¨‹åº¦çš„å…¼å®¹æ€§ï¼š -arch=sm_30 \\ -gencode=arch=compute_20,code=sm_20 \\ -gencode=arch=compute_30,code=sm_30 \\ -gencode=arch=compute_50,code=sm_50 \\ -gencode=arch=compute_52,code=sm_52 \\ -gencode=arch=compute_60,code=sm_60 \\ -gencode=arch=compute_61,code=sm_61 \\ -gencode=arch=compute_61,code=compute_61 åœ¨ CUDA 9.2 ä¸Šç”Ÿæˆçš„ç¤ºä¾‹æ ‡å¿—ï¼Œå¯ä¸ Volta æ˜¾å¡å®ç°æœ€å¤§å…¼å®¹æ€§ï¼š -arch=sm_50 \\-gencode=arch=compute_50,code=sm_50 \\-gencode=arch=compute_52,code=sm_52 \\-gencode=arch=compute_60,code=sm_60 \\-gencode=arch=compute_61,code=sm_61 \\-gencode=arch=compute_70,code=sm_70 -gencode=arch=compute_70,code=compute_70 åœ¨CUDA 10.1ä¸Šç”Ÿæˆçš„æ ·æœ¬æ ‡å¿—ï¼Œä¸ V100 å’Œ T4 å›¾çµå¡å…·æœ‰æœ€å¤§å…¼å®¹æ€§ï¼š -arch=sm_50 -gencode=arch=compute_50,code=sm_50 -gencode=arch=compute_52,code=sm_52 -gencode=arch=compute_60,code=sm_60 -gencode=arch=compute_61,code=sm_61 -gencode=arch=compute_70,code=sm_70 -gencode=arch=compute_75,code=sm_75 \\-gencode=arch=compute_75,code=compute_75 åœ¨CUDA 11.0ä¸Šç”Ÿæˆçš„æ ‡è®°ç¤ºä¾‹ï¼Œä¸ V100 å’Œ T4 å›¾çµå¡å…·æœ‰æœ€å¤§å…¼å®¹æ€§ï¼š -arch=sm_52 -gencode=arch=compute_52,code=sm_52 -gencode=arch=compute_60,code=sm_60 -gencode=arch=compute_61,code=sm_61 -gencode=arch=compute_70,code=sm_70 -gencode=arch=compute_75,code=sm_75 \\-gencode=arch=compute_80,code=sm_80 \\-gencode=arch=compute_80,code=compute_80 åœ¨CUDA 11.7ä¸Šç”Ÿæˆï¼Œä¸ V100 å’Œ T4 æ˜¾å¡å…·æœ‰æœ€å¤§å…¼å®¹æ€§ï¼Œä½†ä¹Ÿæ”¯æŒè¾ƒæ–°çš„ RTX 3080 å’Œ Drive AGX Orinï¼š -arch=sm_52 -gencode=arch=compute_52,code=sm_52 -gencode=arch=compute_60,code=sm_60 -gencode=arch=compute_61,code=sm_61 -gencode=arch=compute_70,code=sm_70 -gencode=arch=compute_75,code=sm_75 \\-gencode=arch=compute_80,code=sm_80 \\-gencode=arch=compute_86,code=sm_86 \\-gencode=arch=compute_87,code=sm_87-gencode=arch=compute_86,code=compute_86 åœ¨CUDA 11.4ä¸Šç”Ÿæˆçš„ç¤ºä¾‹æ ‡å¿—ï¼Œå¯ä½¿ RTX 3080 æ˜¾å¡å‘æŒ¥æœ€ä½³æ€§èƒ½ï¼š -arch=sm_80 -gencode=arch=compute_80,code=sm_80 \\-gencode=arch=compute_86,code=sm_86 \\-gencode=arch=compute_87,code=sm_87 \\-gencode=arch=compute_86,code=compute_86 ä½¿ç”¨ GeForce RTX 4080ã€L40sã€L4 å’Œ RTX A6000 Ada æ˜¾å¡åœ¨ CUDA 12 ä¸Šç”Ÿæˆæœ€ä½³æ€§èƒ½çš„ç¤ºä¾‹æ ‡å¿—ï¼š -arch=sm_89 -gencode=arch=compute_89,code=sm_89 \\-gencode=arch=compute_89,code=compute_89 åœ¨ CUDA12ï¼ˆPTX ISA ç‰ˆæœ¬ 8.0ï¼‰ä¸Šç”Ÿæˆçš„ç¤ºä¾‹æ ‡è®°ï¼Œå¯ä¸è‹±ä¼Ÿè¾¾ H100 å’Œ H200ï¼ˆHopperï¼‰å›¾å½¢å¤„ç†å™¨å®ç°æœ€ä½³æ€§èƒ½ï¼Œä¸”ä¸å‘ä¸‹å…¼å®¹å‰å‡ ä»£äº§å“ï¼š -arch=sm_90 -gencode=arch=compute_90,code=sm_90 \\-gencode=arch=compute_90a,code=sm_90a \\-gencode=arch=compute_90a,code=compute_90a ä¸º Hopper GPU å¢åŠ æ›´å¤šå…¼å®¹æ€§å’Œä¸€äº›å‘åå…¼å®¹æ€§ï¼š -arch=sm_52 -gencode=arch=compute_52,code=sm_52 -gencode=arch=compute_60,code=sm_60 -gencode=arch=compute_61,code=sm_61 -gencode=arch=compute_70,code=sm_70 -gencode=arch=compute_75,code=sm_75 -gencode=arch=compute_80,code=sm_80 -gencode=arch=compute_86,code=sm_86 -gencode=arch=compute_87,code=sm_87 \\-gencode=arch=compute_90,code=sm_90 -gencode=arch=compute_90,code=compute_90 4. åœ¨ PyTorch ä¸­ä½¿ç”¨ TORCH_CUDA_ARCH_LISTå¦‚æœä½¿ç”¨çš„æ˜¯ PyTorchï¼Œå¯ä»¥åœ¨å®‰è£…æ—¶ä½¿ç”¨ TORCH_CUDA_ARCH_LIST ç¯å¢ƒå˜é‡è®¾ç½®æ¶æ„ï¼Œä¾‹å¦‚ï¼š TORCH_CUDA_ARCH_LIST=&quot;7.0 7.5 8.0 8.6&quot; python3 setup.py install è¯·æ³¨æ„ï¼Œè™½ç„¶ä½ å¯ä»¥åœ¨è¿™ä¸ªå˜é‡ä¸­æŒ‡å®šæ¯ä¸€ä¸ªæ¶æ„ï¼Œä½†æ¯ä¸€ä¸ªéƒ½ä¼šå»¶é•¿ç¼–è¯‘æ—¶é—´ï¼Œå› ä¸ºå†…æ ¸å¿…é¡»é’ˆå¯¹æ¯ä¸€ä¸ªæ¶æ„è¿›è¡Œç¼–è¯‘ã€‚ ä¹Ÿå¯ä»¥åœ¨æŒ‡å®šçš„æœ€æ–°æ¶æ„ä¸Šæ·»åŠ åç¼€ +PTX æ¥å‘Šè¯‰ PyTorch ç”Ÿæˆä¸è¾ƒæ–°çš„æ˜¾å¡å‘å‰å…¼å®¹çš„ PTX ä»£ç ï¼š TORCH_CUDA_ARCH_LIST=&quot;7.0 7.5 8.0 8.6+PTX&quot; python3 build_my_extension.py 5. ä½¿ç”¨ Cmake ç¼–è¯‘ TensorRTå¦‚æœä½¿ç”¨ CMAKE ç¼–è¯‘ TensorRTï¼Œè¯·å»æ‰ sm_ å’Œ compute_ å‰ç¼€ï¼ŒåªæåŠè®¡ç®—èƒ½åŠ›ã€‚ ä»¥ Tesla V100 å’Œ Volta æ˜¾å¡ä¸ºä¾‹ï¼šcmake &lt;...&gt; `-DGPU_ARCHS=&quot;70&quot;` ä»¥è‹±ä¼Ÿè¾¾ RTX 2070 å’Œç‰¹æ–¯æ‹‰ T4 ä¸ºä¾‹ï¼šcmake &lt;...&gt; -DGPU_ARCHS=&quot;75&quot; NVIDIA A100 ç¤ºä¾‹ï¼šcmake &lt;...&gt; `-DGPU_ARCHS=&quot;80&quot;` ä»¥è‹±ä¼Ÿè¾¾â„¢ï¼ˆNVIDIAÂ®ï¼‰RTX 3080 å’Œ A100 ä¸€èµ·ä½¿ç”¨ä¸ºä¾‹ï¼šcmake &lt;...&gt; -DGPU_ARCHS=&quot;80 86&quot; NVIDIA H100 ç¤ºä¾‹ï¼šcmake &lt;...&gt; -DGPU_ARCHS=&quot;90&quot; 6. ä½¿ç”¨ Cmake ç¼–è¯‘ CUTLASS å’Œ Hopper GH100cmake .. -DCUTLASS_NVCC_ARCHS=90a 7. Value â€˜sm_86â€™ is not defined for option â€˜gpu-architectureâ€™å¦‚æœå‡ºç°ç±»ä¼¼ä¸‹é¢çš„é”™è¯¯ï¼š 1nvcc fatal : Value 'sm_86' is not defined for option 'gpu-architecture'. å¯èƒ½å®‰è£…äº†æ—§ç‰ˆæœ¬çš„ CUDA å’Œ/æˆ–é©±åŠ¨ç¨‹åºã€‚å‡çº§åˆ°è¾ƒæ–°çš„é©±åŠ¨ç¨‹åºï¼Œè‡³å°‘ 450.36.06 æˆ–æ›´é«˜ç‰ˆæœ¬ï¼Œä»¥æ”¯æŒ A100ã€RTX 3080ç­‰ sm_8x æ˜¾å¡ã€‚ 8. CUDA runtime error: operation not supportedå¦‚æœæ”¶åˆ°ç±»ä¼¼ä¸‹é¢è¿™æ ·çš„ std::runtime_errorï¼ˆruntime errorï¼‰ï¼š 1CUDA runtime errorï¼šoperation not supported æ˜¾å¡ä¸æ”¯æŒç”Ÿæˆçš„runtime codeã€‚ ä½¿ç”¨ nvidia-smi æŸ¥çœ‹æ˜¾å¡å’Œé©±åŠ¨ç¨‹åºç‰ˆæœ¬ã€‚ç„¶åï¼Œå°è¯•åŒ¹é…ç”Ÿæˆä»£ç ï¼Œç”Ÿæˆé€‚åˆæ˜¾å¡çš„æ­£ç¡®çš„runtime codeã€‚","link":"/posts/8a630bae/"},{"title":"Rplidar A3ä½¿ç”¨æ•™ç¨‹ï¼ˆåœ¨A2åŸºç¡€ä¸Šï¼‰","text":"rplidar A3çš„IDä¸a2ç›¸åŒï¼Œå‡ä¸º10c4:ea60ï¼Œä¸²å£æ–‡ä»¶ä¸­é…ç½®è¿‡A2å¯ä»¥ç›´æ¥æ¢a3åœ¨å·¥ä½œç©ºé—´ä¸‹git rplidaræœ€æ–°è½¯ä»¶åŒ… 1git clone https://github.com/ncnynl/rplidar_ros.git ç¼–è¯‘å·¥ä½œç©ºé—´ç¼–è¯‘é€šè¿‡åè¿è¡Œ 1roslaunch rplidar_ros view_rplidar_a3.launch è‹¥å‡ºç°æ¿€å…‰å›¾å³å®‰è£…æˆåŠŸã€‚æ³¨æ„äº‹é¡¹ï¼šA3çš„æ³¢ç‰¹ç‡ä¸º256000ï¼Œä¸å¯è°ƒä½ï¼Œå¦åˆ™æŠ¥é”™æ— æ³•è¿è¡Œè´´ä¸€æ®µlaunchæ–‡ä»¶ä¸­çš„ä»£ç ä½œå‚è€ƒ 123456789&lt;node name=&quot;rplidarNode&quot; pkg=&quot;rplidar_ros&quot; type=&quot;rplidarNode&quot; output=&quot;screen&quot;&gt; &lt;param name=&quot;serial_port&quot; type=&quot;string&quot; value=&quot;/dev/rplidar&quot;/&gt; &lt;param name=&quot;serial_baudrate&quot; type=&quot;int&quot; value=&quot;256000&quot;/&gt; &lt;!--æ³¢ç‰¹ç‡ä¸º256000--&gt; &lt;param name=&quot;frame_id&quot; type=&quot;string&quot; value=&quot;laser&quot;/&gt; &lt;param name=&quot;inverted&quot; type=&quot;bool&quot; value=&quot;false&quot;/&gt; &lt;param name=&quot;angle_compensate&quot; type=&quot;bool&quot; value=&quot;true&quot;/&gt; &lt;param name=&quot;scan_mode&quot; type=&quot;string&quot; value=&quot;Sensitivity&quot;/&gt; &lt;!--é›·è¾¾å·¥ä½œæ¨¡å¼--&gt; &lt;remap from=&quot;scan&quot; to=&quot;scan_raw&quot;/&gt;&lt;/node&gt; ç”±äºé›·è¾¾å…¼å®¹ï¼Œåœ¨åŸç¨‹åºä¸­ä¿®æ”¹ä¸€ä¸‹é›·è¾¾å‚æ•°å³å¯ä½¿ç”¨RPlidar A3.","link":"/posts/2aff5314/"},{"title":"Ubuntu 18.04 å®‰è£…RealSense D435æ•™ç¨‹","text":"1.æ›´æ–°å†…æ ¸è¿è¡Œä»£ç 1uname -r å¦‚æœ&gt;=4.4.0-50çš„ç‰ˆæœ¬åˆ™okï¼Œå¦åˆ™éœ€è¦å‡çº§å†…æ ¸ã€‚ 2.æ›´æ–°cmakeï¼ˆéœ€è¦3.6ä»¥ä¸Šç‰ˆæœ¬ï¼‰ï¼ˆéœ€è¦ç§‘å­¦ä¸Šç½‘ï¼‰é¦–å…ˆä¸‹è½½cmake-3.13.2.tar.gz :https://cmake.org/download/ åœ¨ä¸»æ–‡ä»¶å¤¹ä¸‹æ–°å»ºtools/æ–‡ä»¶å¤¹ï¼Œå°†cmake-3.13.2.tar.gzè§£å‹ä¹‹åæ”¾åœ¨tools/ä¸­ï¼Œæ›´æ”¹æƒé™è§£å‹ï¼š 1sudo tar -zxvf cmake-3.13.2.tar.gz èµ‹æƒé™ï¼š1sudo chmod -R 777 cmake-3.13.2å®‰è£…gcc-c++:1234sudo apt-get install build-essentialsudo ./bootstrapsudo makesudo make installæŸ¥çœ‹æ˜¯å¦å®‰è£…æˆåŠŸä»¥åŠå®‰è£…ç‰ˆæœ¬ï¼š1cmake --version 3.å®‰è£…ä¾èµ–1sudo apt-get install libusb-1.0-0-dev pkg-config libgtk-3-dev 4.ä¸‹è½½realsenseåº“ï¼ˆå¼ºçƒˆå»ºè®®ç§‘å­¦ä¸Šç½‘ï¼ï¼å¦åˆ™è¯·å…ˆä¸‹è½½å¥½è§£å‹åˆ°ç›®å½•ï¼‰1sudo git clone https://github.com/IntelRealSense/librealsense.git 5.è¿›å…¥librealsenseè·¯å¾„ä¸‹ï¼Œæ‰§è¡Œä¸‹åˆ—å‘½ä»¤ï¼ˆcmakeæ—¶ç§‘å­¦ä¸Šç½‘ï¼‰123mkdir build &amp;&amp; cd buildcmake ../cmake ../ -DBUILD_EXAMPLES=true 6.å®‰è£…ï¼ˆå®‰è£…ä¹‹å‰åŠ¡å¿…ç¡®è®¤cmakeæˆåŠŸï¼‰1make &amp;&amp; sudo make install 7.åˆ‡æ¢åˆ°librealsenseçš„è·¯å¾„ä¸‹ï¼Œå®‰è£…Video4Linuxè§†é¢‘å†…æ ¸é©±åŠ¨ï¼Œä¸èƒ½æ’Realsenseï¼ï¼ï¼ï¼12sudo cp config/99-realsense-libusb.rules /etc/udev/rules.d/sudo udevadm control --reload-rules &amp;&amp; udevadm trigger 8.å®‰è£…Opensslåº“ï¼š1sudo apt-get install libssl-dev 9.ç¼–è¯‘é…ç½®æ–‡ä»¶ï¼š1./scripts/patch-realsense-ubuntu-lts.sh æ³¨æ„ä¸Šé¢çš„é…ç½®æ–‡ä»¶ï¼Œä¸€å®šæ˜¯ltsç‰ˆæœ¬ï¼å¦åˆ™ç¨‹åºä¼šå´©ï¼ 10.æ£€æŸ¥å®‰è£…é©±åŠ¨æ˜¯å¦æˆåŠŸå®Œæˆåï¼Œæ’ä¸ŠRealsenseï¼Œæ‰§è¡Œ1sudo dmesg | tail -n 50æ— å¤±è´¥ä¿¡æ¯åˆ™å®‰è£…é©±åŠ¨æˆåŠŸ 11.è¿è¡Œä¾‹ç¨‹æ£€éªŒè¿›å…¥librealsense/build/examplesæ–‡ä»¶å¤¹ï¼Œæ‰§è¡Œ12cd capture./rs-captureçœ‹åˆ°å½©å›¾å’Œæ·±åº¦å›¾å³å®‰è£…æˆåŠŸã€‚//realsenseå®˜æ–¹ROSåŒ…çš„å®‰è£…1.é€šè¿‡æºç å®‰è£…intel RealSense ROSï¼ˆå®‰è£…å’Œä½¿ç”¨å¯å‚è€ƒgithubï¼š https://github.com/intel-ros/realsense ï¼‰2.gitæˆ–ç²˜è´´åˆ°å·¥ä½œç©ºé—´3.ç¼–è¯‘4.æµ‹è¯•roslaunch realsense2_camera opensource_tracking.launch å¯èƒ½ä¼šå‡ºç°ç¼ºå°‘åŒ…çš„æƒ…å†µï¼Œå®‰è£…å³å¯ã€‚ å‡ºç°ç‚¹äº‘æ•°æ®ã€æ‘„åƒå¤´æ•°æ®å³æˆåŠŸã€‚ ç‰ˆæœ¬ï¼šver1.1","link":"/posts/f7f75eef/"},{"title":"dockerå®¹å™¨ç­¾å‡ºåŠè¿ç§»æµç¨‹","text":"é¡¹ç›®ä¸­ï¼Œåœ¨æµ‹è¯•ç¯å¢ƒæœåŠ¡å™¨ä¸­éƒ¨ç½²äº†dockerå¼„äº†ä¸€ä¸ªollamaå®¹å™¨ï¼Œç°åœ¨éœ€è¦è¿ç§»åˆ°ç”Ÿäº§ç¯å¢ƒæœåŠ¡å™¨ã€‚å¦‚æœä¸æƒ³é‡æ–°é…ç½®ï¼Œå¯å°†æµ‹è¯•å®Œæˆçš„ollamaå®¹å™¨è¿›è¡Œæ‰“åŒ…ï¼Œä¿å­˜ä¸ºtaræ–‡ä»¶ï¼Œä¼ è¾“åˆ°ç”Ÿäº§æœåŠ¡å™¨ä¸­ï¼Œä½¿ç”¨loadåŠ è½½é•œåƒï¼Œç„¶åè¿è¡Œã€‚å…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š å°†å®¹å™¨æ‰“åŒ…æˆé•œåƒ å‘½ä»¤ï¼šdocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] optionsé€‰é¡¹ï¼š -a :æäº¤çš„é•œåƒä½œè€…ï¼› -c :ä½¿ç”¨DockerfileæŒ‡ä»¤æ¥åˆ›å»ºé•œåƒï¼› -m :æäº¤æ—¶çš„è¯´æ˜æ–‡å­—ï¼› -p :åœ¨commitæ—¶ï¼Œå°†å®¹å™¨æš‚åœã€‚ ä¾‹å¦‚ï¼š docker commit -a cuiyuhao -m &quot;Deploy ollama&quot; ollama ollama:v1.0 å®Œæˆåï¼Œä½¿ç”¨docker imageså¯ä»¥çœ‹è§è¯¥é•œåƒã€‚ æ‰“åŒ…é•œåƒ å‘½ä»¤ï¼šdocker save [OPTIONS] IMAGE [IMAGE...] ä¾‹å¦‚ï¼šdocker save -o ollama_v1_0.tar ollama:v1.0ã€‚è¿™é‡Œçš„ollama:v1.0æ˜¯åˆšæ‰“åŒ…çš„é•œåƒ å®Œæˆåï¼Œä¼šåœ¨å½“å‰ç›®å½•ç”Ÿæˆä¸€ä¸ªtaræ–‡ä»¶ scpä¼ è¾“é•œåƒæ–‡ä»¶ å‘½ä»¤ï¼šscp [OPTIONS] PACKFILE USER@IP:TARGET_LOCATION optionsé€‰é¡¹ï¼š -r :ä¼ è¾“æ–‡ä»¶å¤¹ï¼› ä¾‹å¦‚ï¼šscp ollama_v1_0.tar root@10.11.12.13:/home/ollama æ–°æœåŠ¡å™¨è½½å…¥é•œåƒ å‘½ä»¤ï¼šdocker load [OPTIONS] -optioné€‰é¡¹ï¼š â€“input,-i æŒ‡å®šå¯¼å…¥çš„æ–‡ä»¶ â€“quiet,-q ç²¾ç®€è¾“å‡ºä¿¡æ¯ å¦‚ï¼šdocker load --input ollama_v1_0.tar å®Œæˆårunå®¹å™¨æˆ–è€…ä½¿ç”¨docker-composeå¯åŠ¨å³å¯ã€‚","link":"/posts/530cb732/"},{"title":"UbuntuåŒç³»ç»Ÿã€ROSã€è½¯ä»¶å®‰è£…æ•™ç¨‹","text":"ä¸€ã€win10ä¸‹å®‰è£…Ubuntu16.04åŒç³»ç»Ÿ1ã€åˆ¶ä½œç³»ç»ŸUç›˜ä¸‹è½½Ubuntu16.04æˆ‘ä»¬é¦–å…ˆå»Ubuntuå®˜ç½‘ä¸‹ä¸€ä¸ªUbuntu16.04çš„isoé•œåƒæ–‡ä»¶ã€‚ åˆ©ç”¨è½¯ç¢Ÿé€šåˆ¶ä½œåœ¨åˆ¶ä½œç³»ç»ŸUç›˜çš„æ—¶å€™æˆ‘ä»¬éœ€è¦å»ä¸‹ä¸€ä¸ªè½¯ä»¶â€”â€”è½¯ç¢Ÿé€šï¼Œè¿™ä¸ªè‡ªå·±å»ç™¾åº¦æœç´¢ä¸€ä¸‹åº”è¯¥å°±èƒ½å‡ºæ¥çš„ã€‚ä¸‹è½½å®‰è£…å®Œä»¥åï¼Œæˆ‘ä»¬æ‰“å¼€è½¯ç¢Ÿé€šçš„ç•Œé¢æ‰“å¼€åˆšåˆšä¸‹è½½çš„isoé•œåƒæ–‡ä»¶çš„è·¯å¾„ã€‚ å°†isoæ–‡ä»¶åŠ è½½å®Œä»¥åæˆ‘ä»¬ç‚¹å¼€å¯åŠ¨ä¸‹çš„å†™å…¥ç¡¬ç›˜ç¡¬ç›˜æ˜ åƒ ç„¶åé€‰æ‹©æˆ‘ä»¬è‡ªå·±çš„Uç›˜ï¼Œç„¶åå†™å…¥å°±è¡Œäº†ï¼ˆæœ€å¥½ç‚¹ä¸Šåˆ»å½•æ ¡éªŒï¼‰ ç­‰å¾…å†™å…¥å®Œæˆä»¥åï¼Œæˆ‘ä»¬çš„å®‰è£…Uç›˜å°±åˆ¶ä½œå¥½äº†ã€‚ 2ã€ç£ç›˜åˆ†åŒºæˆ‘ä»¬å³é”®ç‚¹å‡»æ­¤ç”µè„‘ï¼Œç„¶åç‚¹å‡»ç®¡ç†å°±è¿›å…¥äº†ç®¡ç†ã€‚ç„¶åç‚¹å‡»å­˜å‚¨è¿›å…¥ç£ç›˜ç®¡ç†ã€‚è¿™æ—¶å€™å¯ä»¥çœ‹çœ‹å“ªä¸ªç›˜ç¬¦å‰©ä½™å®¹é‡è¾ƒå¤šï¼Œä¾¿å‹ç¼©å“ªä¸ªç›˜ç¬¦ã€‚æ ¹æ®è‡ªå·±éœ€è¦ï¼Œå‹ç¼©å‡ºUbuntuçš„ç©ºé—´ï¼ˆä¸€èˆ¬100Gè¶³å¤Ÿï¼‰å‹ç¼©å®Œä»¥åæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æœ‰ä¸ªç©ºä½™ç©ºé—´ï¼Œè¿™æ—¶å€™æˆ‘ä»¬ä¸è¦ç»™å®ƒåˆ†é…ç›˜ç¬¦ï¼Œé»˜è®¤è¿™æ ·å°±è¡Œäº†ã€‚ 3ã€è¿›å…¥BIOSè®¾ç½®Uç›˜å¯åŠ¨è®¾ç½®Secure Bootè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å·²ç»å¯ä»¥æŠŠwin10å…³é—­äº†ï¼Œæˆ‘ä»¬ç‚¹å‡»å…³æœºï¼Œç„¶åå†å¼€æœºã€‚æˆ‘ä»¬åœ¨å¼€æœºçš„æ—¶å€™ä¸€ç›´æŒ‰F2ï¼Œå°±å¯ä»¥è¿›å…¥BIOSäº†ï¼ˆå¤§å¤šæ•°ç”µè„‘æ˜¯æŒ‰F2è¿›å…¥BIOS,Lenovoçš„ç¬”è®°æœ¬æ˜¯æŒ‰Fn+F2ï¼‰ã€‚ï¼ˆäº²æµ‹åç¡•ã€ç©å®¶å›½åº¦ã€æˆ´å°”éƒ¨åˆ†ç”µè„‘æ˜¯é•¿æŒ‰F2è¿›BIOSï¼ŒESCè¿›ç³»ç»Ÿé€‰æ‹©é¡¹ï¼‰è¿›å…¥BIOSä»¥åï¼Œæˆ‘ä»¬å°±æ¥è®¾ç½®ä¸€ä¸‹Uç›˜å¯åŠ¨äº†ï¼Œæˆ‘ä»¬è¿›å…¥Bootï¼Œå¦‚æœBoot Modeæ˜¯UEFI æˆ‘ä»¬å°±å°†ä¸‹é¢çš„Secure Boot è®¾ç½®Disableã€‚å¦‚æœBoot Modeæ˜¯Legacy é‚£ä¹ˆæˆ‘ä»¬å°±è·³è¿‡è¿™æ­¥ã€‚ç‰¹åˆ«è¯´æ˜ï¼šå¦‚æœAcerç”µè„‘å‘ç°ä¸èƒ½å°†Secure Boot è®¾ç½®æˆDisableï¼Œå°±å¾—å»Securityé‡Œé¢è®¾ç½®ä¸€ä¸‹ Supervisor passwordå°±è¡Œäº†ï¼ŒæŒ‰F12é€‰æ‹©ç³»ç»Ÿã€‚ å°†USB HDDç½®é¡¶å¼„å®Œäº†ä¸Šé¢çš„ï¼Œå†å°†USB HDDæ”¾åˆ°æœ€ä¸Šé¢ï¼ˆAcer ç¬”è®°æœ¬æ˜¯æŒ‰F5å’ŒF6æ¥æ§åˆ¶ä¸Šå‡å’Œä¸‹é™çš„ï¼ŒDellç¬”è®°æœ¬æ˜¯é€‰åˆ°USB HDDä¸Šé¢æŒ‰ä¸‹Enterç„¶åå†ç§»åŠ¨åˆ°æœ€ä¸Šé¢çš„é‚£ä¸ªå¯åŠ¨å†æŒ‰ä¸‹Enterå°†æœ€ä¸Šé¢ç¡¬ç›˜å¯åŠ¨é¡¶ä¸‹å»ï¼‰è®¾ç½®å®Œæˆä»¥åæŒ‰ä¸‹ESC ä¿å­˜ä¸€ä¸‹å°±è¡Œäº†ã€‚ æ–°å¼å›¾å½¢åŒ–ç•Œé¢BIOSè®¾ç½®ï¼ˆä»¥ç¬”è€…çš„åç¡•ç©å®¶å›½åº¦ç¬”è®°æœ¬ä¸ºä¾‹ï¼‰ï¼šå³ä¾§boot priorityæ ä¸­ï¼Œé¼ æ ‡æ‹–åŠ¨å³ä¾§ä¸‰æ¡æ¨ªçº¿å³å¯æ›´æ”¹é»˜è®¤å¯åŠ¨é¡ºåºï¼Œæ’å…¥Uç›˜åå°†usbé¡¹æ‹–åŠ¨ä¹‹æœ€é¡¶ç«¯å³å¯ã€‚æŒ‰F7è¿›å…¥é«˜çº§è®¾ç½®ï¼Œé¼ æ ‡ç‚¹å‡»ä¸Šé¢çš„securityæ ï¼Œæ‰¾åˆ°security booté¡¹ç‚¹å‡»è¿›å…¥ å°†secure boot controlé¡¹æ”¹ä¸ºDisabledã€‚ è€å¼ç•Œé¢BIOSè®¾ç½®ï¼šUEFI å¯åŠ¨Legacyå¯åŠ¨ ï¼ˆèƒ½ä¸ç”¨å°½é‡ä¸è¦ç”¨è¿™ä¸ªæ–¹æ³•å®‰è£…ï¼‰ 4ã€å®‰è£…Ubuntuå®‰è£…å‰å¥æˆ‘ä»¬åœ¨ä¸Šé¢æ­¥éª¤å®Œæˆä»¥åï¼Œå°†ç³»ç»ŸUç›˜æ’å…¥ç”µè„‘ã€‚ç„¶åå¼€å¯ç”µè„‘ï¼Œå³å¯è¿›å…¥Uç›˜å®‰è£…ç•Œé¢äº†ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬é€‰æ‹©install Ubuntuå³å¯ç„¶åå°±æ˜¯é€‰æ‹©è¯­è¨€äº†ï¼Œæˆ‘ä»¬é€‰æ‹©è‡ªå·±åˆé€‚çš„è¯­è¨€å°±è¡Œäº†ï¼Œæˆ‘ä»¬ç‚¹å‡»å®‰è£…Ubuntuæ¥ä¸‹æ¥å°±æ˜¯è¿æ¥WiFiï¼Œå®‰è£…å›¾å½¢ç•Œé¢äº†ï¼Œèƒ½ä¸è¿å°½é‡ä¸è¿ï¼Œå¦åˆ™ä¼šå¾ˆæ…¢è¿™é‡Œæœ€å¥½è¦æŠŠå›¾ä¸­çš„â€˜å®‰è£…ç¬¬ä¸‰æ–¹è½¯ä»¶â€™çš„å‹¾ç‚¹æ‰å¥½äº†ï¼Œåˆ°äº†æœ€å…³é”®çš„ä¸€æ­¥äº†ï¼Œè¿™ä¸ªæ—¶å€™ç³»ç»Ÿä¼šæç¤ºä½ æ˜¯å¦ä¸windows 10 å…±å­˜ï¼Œæˆ‘ä»¬ä¸è¦ç‚¹å‡»é‚£ä¸ªï¼Œæˆ‘ä»¬é€‰æ‹©å…¶ä»–é€‰é¡¹ï¼Œè¿™æ ·è‡ªå·±æ–¹ä¾¿ç®¡ç†ä¸€äº›ã€‚æ³¨æ„:å¦‚æœç³»ç»Ÿæ²¡æç¤ºä½ ä¹‹å‰å®‰è£…è¿‡windows é‚£ä¹ˆä½ çš„å¯åŠ¨æ–¹å¼å°±é”™è¯¯äº†ï¼Œä½ å¾—å›åˆ°BIOSé¡µé¢ä¸‹æ›´æ”¹å¯åŠ¨æ–¹å¼å†æ¬¡å¯åŠ¨ç°åœ¨æˆ‘ä»¬æ¥å¯¹Ubuntuè¿›è¡Œåˆ†åŒºï¼Œåœ¨åˆ†åŒºä¹‹å‰æˆ‘å…ˆä»‹ç»ä¸€ä¸‹Linuxçš„æ–‡ä»¶ç³»ç»Ÿ swapï¼šç”¨ä½œè™šæ‹Ÿå†…å­˜ï¼Œè¿™ä¸ªè¦å’Œè‡ªå·±çš„ç‰©ç†å†…å­˜ä¸€æ ·å¤§/ï¼šä¸»è¦ç”¨æ¥å­˜æ”¾Linuxç³»ç»Ÿæ–‡ä»¶/boot:å­˜æ”¾linuxå†…æ ¸ï¼Œç”¨æ¥å¼•å¯¼ç³»ç»Ÿçš„ï¼Œå¦‚æœæ˜¯Legacyå¯åŠ¨å°±è¦è®¾ç½®å¼•å¯¼ï¼ŒUEFIå°±ä¸ç”¨è®¾ç½®è¿™ä¸ªï¼ˆUEFIè¦è®¾ç½®EFIæ–‡ä»¶ï¼‰/usr:å­˜æ”¾ç”¨æˆ·ç¨‹åºï¼Œä¸€èˆ¬åœ¨/usr/binä¸­å­˜æ”¾å‘è¡Œç‰ˆæä¾›çš„ç¨‹åºï¼Œç”¨æˆ·è‡ªè¡Œå®‰è£…çš„ç¨‹åºé»˜è®¤å®‰è£…åˆ°/usr/local/binä¸­/home:å­˜æ”¾ç”¨æˆ·æ–‡ä»¶ æˆ‘ä»¬åœ¨çœ‹ç£ç›˜ä¿¡æ¯çš„æ—¶å€™å¯ä»¥å‘ç°è‡ªå·±å½“åˆæ²¡æœ‰åˆ†é…çš„é‚£ä¸ªç©ºé—²ç£ç›˜ï¼Œé€‰ä¸­é‚£ä¸ªç©ºé—²ç£ç›˜ï¼Œç„¶åç‚¹å‡»+ å·ï¼Œå¼€å§‹åˆ†é…ã€‚ è®¾ç½®swapåˆ†é…swapï¼Œæˆ‘ä»¬é€‰æ‹©ä¸»åˆ†åŒºï¼Œç©ºé—´èµ·å§‹ä½ç½®ï¼Œå¤§å°å’Œè‡ªå·±ç‰©ç†å†…å­˜ä¸€æ ·ï¼ˆæˆ‘çš„æ˜¯16Gæˆ‘å°±åˆ†é…16384Mï¼‰ï¼Œç”¨äºäº¤æ¢ç©ºé—´ è®¾ç½®å¼•å¯¼ï¼ˆä¸‹é¢ä¸¤ä¸ªæ ¹æ®è‡ªå·±å¯åŠ¨æ–¹å¼é€‰æ‹©ï¼‰è®¾ç½®EFIå¼•å¯¼ï¼Œæˆ‘ä»¬é€‰æ‹©é€»è¾‘åˆ†åŒºï¼Œç©ºé—´èµ·å§‹ä½ç½®ï¼Œç”¨äºEFIç³»ç»Ÿåˆ†åŒºï¼Œå¤§å°è®¾ç½®500Må³å¯æ³¨æ„ï¼šLegacyå¯åŠ¨çš„è¯å°±æ²¡æœ‰efiå¼•å¯¼é¡¹ï¼ŒLegacyå¯åŠ¨è¦è®¾ç½®bootå¼•å¯¼ï¼ˆUEFIå¯åŠ¨ä¸è¦è®¾ç½®ä»¥ä¸‹å¼•å¯¼é¡¹ï¼‰è®¾ç½®Bootå¼•å¯¼ï¼Œæˆ‘ä»¬é€‰æ‹©é€»è¾‘åˆ†åŒºï¼Œç©ºé—´èµ·å§‹ä½ç½®ï¼Œç”¨äºExt4æ—¥å¿—æ–‡ä»¶ï¼ŒæŒ‚è½½ç‚¹ï¼š/bootï¼Œå¤§å°è®¾ç½®200Mï¼ˆè¿™é‡Œæ²¡æœ‰å›¾æ¼”ç¤ºï¼Œä½†æ˜¯å¯ä»¥æ ¹æ®ä¸‹å›¾ç±»æ¨ï¼‰ è®¾ç½®/åˆ†åŒºè®¾ç½®/ï¼Œæˆ‘ä»¬é€‰æ‹©é€»è¾‘åˆ†åŒºï¼Œç©ºé—´èµ·å§‹ä½ç½®ï¼Œç”¨äºExt4æ—¥å¿—æ–‡ä»¶ï¼ŒæŒ‚è½½ç‚¹ï¼š/ï¼Œå¤§å°æ ¹æ®è‡ªå·±åˆ†åŒºå¤§å°è®¾ç½®ï¼Œæˆ‘è¿™é‡Œè®¾ç½®çš„æ˜¯10Gã€‚ï¼ˆæ¯”å¦‚åˆ†åŒºç»™Ubuntuæ€»å…±100Gï¼Œæ¨èè®¾ç½®20Gå·¦å³ï¼‰ è®¾ç½®homeåˆ†åŒºè®¾ç½®homeï¼Œæˆ‘ä»¬é€‰æ‹©é€»è¾‘åˆ†åŒºï¼Œç©ºé—´èµ·å§‹ä½ç½®ï¼Œç”¨äºExt4æ—¥å¿—æ–‡ä»¶ï¼ŒæŒ‚è½½ç‚¹ï¼š/homeï¼Œå¤§å°çš„è¯å¯ä»¥æ ¹æ®è‡ªèº«æƒ…å†µï¼Œä½†æ˜¯è¿™ä¸ªæœ€å¥½è®¾ç½®å¤§ä¸€ç‚¹ï¼Œæ€»å…±100Gçš„è¯å¤§æ¦‚åˆ†40Gã€‚ï¼ˆæ ¹æ®usrç±»æ¨ï¼‰ è®¾ç½®usråˆ†åŒºè®¾ç½®usrï¼Œæˆ‘ä»¬é€‰æ‹©é€»è¾‘åˆ†åŒºï¼Œç©ºé—´èµ·å§‹ä½ç½®ï¼Œç”¨äºExt4æ—¥å¿—æ–‡ä»¶ï¼ŒæŒ‚è½½ç‚¹ï¼š/usrï¼Œå¤§å°çš„è¯å‰©ä½™çš„ç©ºé—´å°±éƒ½ç»™å®ƒäº†ã€‚ å®‰è£…ç»ˆç« è®¾ç½®å®Œæ‰€æœ‰ä»¥åï¼Œæˆ‘ä»¬è¦å°†ä¸‹é¢çš„å®‰è£…å¯åŠ¨å™¨è®¾å¤‡æ¢æˆæˆ‘ä»¬åˆšåˆšè®¾ç½®å¼•å¯¼çš„é‚£ä¸ªç›˜UEFIå¼•å¯¼ç±»å‹å°±æ˜¯efiï¼Œlegacyå¼•å¯¼æŒ‚è½½ç‚¹å°±æ˜¯/bootï¼Œè®¾å¤‡å·ä¸€å®šè¦å¯¹åº”ï¼ˆæ¯”å¦‚å›¾ä¸­è®¾å¤‡å·ä¸ºsda12ï¼‰ï¼Œå†ä¸‰æ£€æŸ¥æ­¤é¡¹ï¼ï¼ï¼ï¼ï¼ç„¶åå‡ºç°è¿™ä¸ªï¼Œæˆ‘ä»¬ç‚¹ç»§ç»­å°±è¡Œäº†ç„¶åå°±æ˜¯è®¾ç½®åœ°æ–¹ï¼Œè¯­è¨€å’Œå§“åä»¥åŠå¯†ç ã€‚ï¼ˆå¯†ç å°½é‡çŸ­ï¼Œèƒ½ä¸€ä¸ªå­—ç¬¦å°±åˆ«ä¸¤ä¸ªï¼Œå¦åˆ™åˆ°æ—¶å€™ç”¨èµ·æ¥å¾ˆéº»çƒ¦ï¼Œè£…å¥½ç³»ç»Ÿä¹‹åè®¡ç®—æœºåå’Œç”¨æˆ·ååƒä¸‡ä¸å¯ä»¥æ”¹åŠ¨ï¼ï¼ï¼‰è®¾ç½®å®Œä»¥åæˆ‘ä»¬ç­‰å¾…å®‰è£…å°±è¡Œäº†ã€‚ 5ã€é»˜è®¤å¯åŠ¨é¡¹è®¾ç½®å®‰è£…å®Œæˆåï¼Œä¼šé»˜è®¤è¿›å…¥UBUNTUç³»ç»Ÿã€‚å¦‚æœè¦è®¾ç½®æˆé»˜è®¤è¿›å…¥windowsç³»ç»Ÿï¼Œå¼€æœºé•¿æŒ‰ESCè¿›å…¥Ubuntuçš„è¯ï¼Œè¿›å…¥BIOSï¼Œå°†windows boot managerè®¾ç½®ä¸ºç¬¬ä¸€é€‰é¡¹ã€‚å¼€æœºç«‹å³æŒ‰ä½ESCé”®ï¼ˆä¸åŒçš„ç¬”è®°æœ¬å¯èƒ½ä¸åŒï¼‰ï¼Œè¿›å…¥ç³»ç»Ÿé€‰æ‹©é¡¹ï¼ŒæŒ‰é”®ç›˜ä¸Šä¸‹é”®å³å¯é€‰æ‹©ç³»ç»Ÿã€‚ 6ã€Ubuntuä¿®æ”¹å¯åŠ¨é¡¹ç­‰å¾…æ—¶é—´1sudo gedit /etc/default/grub æ‰¾åˆ°GRUB_TIMEOUT=10é‚£ä¸€è¡Œï¼Œè¿™é‡Œçš„10å°±æ˜¯ç­‰å¾…çš„æ—¶é—´ï¼ŒæŒ‰ç…§è‡ªå·±çš„éœ€è¦æ›´æ”¹å³å¯ï¼Œæˆ‘æ”¹æˆäº†1ã€‚ç„¶åä¿å­˜é€€å‡ºï¼Œç„¶åæ‰§è¡Œä¸‹ä¸€å¥å‘½ä»¤ä½¿ä¿®æ”¹ç”Ÿæ•ˆï¼š 1sudo update-grub 7ã€Ubuntuã€windowsæ—¶é—´ä¸ç»Ÿä¸€ä¿®å¤æ–°ç‰ˆæœ¬çš„Ubuntuä½¿ç”¨systemdå¯åŠ¨ä¹‹åï¼Œæ—¶é—´ä¹Ÿæ”¹æˆäº†ç”±timedatectlæ¥ç®¡ç†ï¼Œæ­¤æ–¹æ³•å°±ä¸é€‚ç”¨äº†ã€‚ 1sudo timedatectl set-local-rtc 1 é‡å¯å®Œæˆå°†ç¡¬ä»¶æ—¶é—´UTCæ”¹ä¸ºCSTï¼ŒåŒç³»ç»Ÿæ—¶é—´ä¿æŒä¸€è‡´ã€‚ å…ˆåœ¨ubuntuä¸‹æ›´æ–°ä¸€ä¸‹æ—¶é—´ï¼Œç¡®ä¿æ—¶é—´æ— è¯¯ï¼š 12sudo apt-get install ntpdatesudo ntpdate time.windows.com ç„¶åå°†æ—¶é—´æ›´æ–°åˆ°ç¡¬ä»¶ä¸Šï¼š 1sudo hwclock --localtime --systohc é‡æ–°è¿›å…¥windows10ï¼Œæ—¶é—´æ¢å¤æ­£å¸¸äº† äºŒã€ROSå®‰è£…æ•™ç¨‹Ubuntuçš„ä¸€äº›å°æŒ‡ä»¤ï¼š 1234567Ctrl +alt + t //æ‰“å¼€æ§åˆ¶ç»ˆç«¯ctrl +shift + c //å¤åˆ¶æ§åˆ¶ç»ˆç«¯ä¸­çš„æ–‡å­—å¿«çš„æ·æŒ‰é”®ctrl +shift + v //æŠŠæ–‡å­—ç²˜è´´è‡³æ§åˆ¶ç»ˆç«¯ä¸­çš„å¿«æ·æŒ‰é”®sudo apt-get install +æ–‡ä»¶å //ä¸‹è½½æ–‡ä»¶sudo gedit+æ–‡ä»¶å //ç¼–è¾‘æ–‡ä»¶å†…å®¹sudo dpkg â€“i //è§£å‹å¹¶å®‰è£…å‹ç¼©æ–‡ä»¶sudo apt update //æ›´æ–°æ–‡ä»¶ 1ã€å¼€æºï¼šï¼ˆé¡ºåºä¸ºå…ˆå¼€æºå†é…ç½®zshå†å®‰è£…rosï¼Œï¼‰æ‰“å¼€ä¸€ä¸ªæ§åˆ¶å°ï¼ˆCtrlï¼‹Altï¼‹Tï¼‰ï¼Œè¾“å…¥å¦‚ä¸‹æŒ‡ä»¤ 1234$ sudo sh -c 'echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list'//è®¾ç½®ç§˜é’¥$ sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 0xB01FA116 2ã€å®‰è£…On my zshï¼šå‚è€ƒç½‘å€ï¼šhttps://blog.csdn.net/hsd2012/article/details/54292192å®‰è£…oh my zshä¹‹å‰è¦å…ˆå®‰è£…git å’Œzshæ‰“å¼€ç»ˆç«¯ï¼Œè¾“å…¥ï¼š 12345678910 sudo apt-get install git//ï¼ˆå®‰è£…gitï¼‰ sudo apt-get install zsh//ï¼ˆå®‰è£…zshï¼‰ curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh//ï¼ˆä»ç½‘ç»œæºä¸Šè·å–oh my zshï¼‰ cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc//ï¼ˆåˆ›å»ºé…ç½®æ–‡ä»¶ï¼‰ chsh -s /bin/zsh//ï¼ˆå°†zshä½œä¸ºé»˜è®¤å·¥å…·ï¼Œæ›¿ä»£åŸæ¥é»˜è®¤çš„bashï¼‰ é‡å¯ç”µè„‘ï¼Œzshå°±å¯ä»¥ä½¿ç”¨äº†ï¼Zshæ¯”é»˜è®¤çš„bashçš„å¥½å¤„åœ¨äºï¼ŒæŒ‰ä¸€ä¸‹tabè¡¥å…¨å‘½ä»¤ï¼ŒæŒ‰åŒå‡»tabå‡ºç°å¤‡é€‰é¡¹ï¼Œæ–¹ä¾¿ä½¿ç”¨ 3.å®‰è£…ROSé¦–å…ˆç¡®ä¿ç³»ç»Ÿè½¯ä»¶å¤„äºæœ€æ–°ç‰ˆ 1$ sudo apt-get update ç„¶åæˆ‘ä»¬å°±å¯ä»¥å®‰è£…ROSäº†ï¼ˆæ­¤å¤„å®‰è£…çš„æ˜¯è‡³å°Šè±ªåå…¨åŠŸèƒ½ç‰ˆï¼‰ 1$ sudo apt-get install ros-kinetic-desktop-full å®Œæˆåï¼Œç”¨ä»¥ä¸‹æŒ‡ä»¤æ¥æŸ¥çœ‹å¯ä½¿ç”¨çš„åŒ…ï¼š 1$ apt-cache search ros-kinetic 4.åˆå§‹åŒ–ROSé¦–å…ˆï¼Œåˆå§‹åŒ–rosdep 12$ sudo rosdep init$ rosdep update ç„¶ååˆå§‹åŒ–ç¯å¢ƒå˜é‡ï¼šï¼ˆæ³¨æ„æ˜¯zshrcè€Œä¸æ˜¯bashrcï¼‰ 12$ echo &quot;source /opt/ros/kinetic/setup.zsh&quot; &gt;&gt; ~/.zshrc$ source ~/.zshrc æœ€åï¼Œå®‰è£…ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„æ’ä»¶ï¼š 1$ sudo apt-get install python-rosinstall 5ã€æµ‹è¯•ROS1$ roscore æ˜¾ç¤º started core service [/rosout] äº†æ²¡æœ‰ï¼Ÿå¦‚æœæ²¡é—®é¢˜ï¼Œæ­å–œä½ æˆåŠŸäº†ã€‚ ä¸‰ã€Ubuntuä¸­ä¸€äº›å®ç”¨ç¨‹åºçš„å®‰è£…1ã€ æœç‹—è¾“å…¥æ³•1ã€ä¸‹è½½æ–‡ä»¶æ‰“å¼€å®˜ç½‘ http://pinyin.sogou.com/linux ï¼Œç‚¹å‡»è‡ªå·±å¯¹åº”çš„ç³»ç»Ÿä½æ•°å®‰è£…åŒ…ï¼Œç„¶åä¸‹è½½ã€‚ 2ã€æ‰“å¼€å®‰è£…ç›®å½•ï¼Œè°ƒå‡ºç»ˆç«¯ã€‚1sudo dpkg -i sogoupinyin_2.1.0.00826_amd64.deb ï¼ˆåé¢çš„æ˜¯è‡ªå·±çš„å®‰è£…åŒ…å‘½ä»¤ï¼Œæ›´æ–°äº†å°±å’Œæˆ‘çš„ä¸ä¸€æ ·äº†ï¼Œå¦‚æœå‡ºç°å®‰è£…å‡ºé”™ï¼Œå°±é‡å¤è¯¥å‘½ä»¤å®‰è£…å‡ æ¬¡ç›´åˆ°æˆåŠŸï¼‰ 1sudo apt-get install -f 3ã€è®¾ç½®æ‰“å¼€â€œç³»ç»Ÿè®¾ç½®â€œï¼Œç‚¹å‡»â€è¯­è¨€æ”¯æŒâ€œï¼Œç„¶åå¼¹å‡ºä¸‹é¢çš„æ¡†å›¾ï¼Œç‚¹å‡»â€å®‰è£…â€œã€‚ç„¶åè¾“å…¥å¯†ç ä»€ä¹ˆçš„ï¼Œç­‰ä¸€ä¼šå„¿å°±å¥½ 4ã€ç„¶åæŠŠé‡Œé¢çš„IBusæ”¹ä¸ºfcitxï¼Œç„¶åå…³æ‰ï¼Œç„¶åé‡å¯ç”µè„‘ã€‚ 5ã€é‡å¯ç”µè„‘åï¼Œä¼šçœ‹åˆ°å±å¹•å³ä¸Šè§’æœ‰ä¼é¹…è¾“å…¥fcitxã€‚ 6ã€ç„¶åå³é”®ç‚¹å¼€ï¼Œé€‰æ‹©ConfigureFcitxã€‚ 7ã€ç„¶åç‚¹å‡»å¼¹å‡ºçš„æ¡†çš„å·¦ä¸‹æ–¹çš„â€+â€œå·ï¼Œæ·»åŠ æœç‹—è¾“å…¥æ³•ï¼Œå»æ‰é‚£ä¸ªåªâ€œæ˜¾ç¤ºå½“å‰è¯­è¨€â€çš„é€‰é¡¹ï¼Œç„¶åæœç´¢æ¡†è¾“å…¥sogï¼Œä½ ä¼šå‘ç°æœç‹—è¾“å…¥æ³•å·²ç»æœ‰äº†ï¼Œé€‰ä¸­è¾“å…¥æ³•å³å¯ï¼Œç„¶åå…³é—­ã€‚ ä½¿ç”¨shiftè¿›è¡Œä¸­è‹±æ–‡åˆ‡æ¢ 2ã€æ ‡é¢˜æ å®æ—¶æ˜¾ç¤ºä¸Šä¸‹è¡Œç½‘é€Ÿã€CPUåŠå†…å­˜ä½¿ç”¨ç‡ç»ˆç«¯æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ 123456sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor//è¿™é‡Œé€‰æ‹©æŒ‰enteré”® sudo apt-get update sudo apt-get install indicator-sysmonitor //å¯åŠ¨ indicator-sysmonitor &amp; //ctrl+cåå°è¿è¡Œè¯¥ç¨‹åº å‹¾ä¸ŠRun on startup:ï¼Œ è¿™æ ·å°±èƒ½å¼€æœºå¯åŠ¨äº†ã€‚åˆ‡æ¢åˆ° Advanced é€‰é¡¹ï¼Œå¯ä»¥å¯¹è¦æ˜¾ç¤ºçš„ä¿¡æ¯çš„æ ¼å¼è¿›è¡Œè®¾ç½®ã€‚å¯ä»¥å°è¯•è®¾ç½®å…¶ä»–æ ¼å¼ï¼Œå†Testï¼Œç›´åˆ°æ•ˆæœæ»¡æ„å†ç‚¹å‡»ä¿å­˜ã€‚ 3ã€ç½‘æ˜“äº‘éŸ³ä¹1ï¼šå…ˆå»å®˜ç½‘ä¸‹è½½æœ€æ–°ç‰ˆæœ¬çš„ç½‘æ˜“äº‘http://music.163.com/#/download2ï¼šæ‰§è¡Œå‘½ä»¤ï¼š sudo dpkg -i //ï¼ˆåæ¥å®˜ç½‘ä¸‹è½½çš„è½¯ä»¶åŒ…åï¼‰ 3ï¼šå¦‚æœæŠ¥é”™äº† ï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ sudo apt-get -f install 4ã€å®‰è£…æ˜¾å¡é©±åŠ¨è¦å®‰è£…è‹±ä¼Ÿè¾¾ç‹¬ç«‹æ˜¾å¡é©±åŠ¨ï¼ŒæŒ‰é”®ç›˜ä¸Šçš„windowsé”®ï¼Œè¾“å…¥â€˜fujâ€™æ‰¾åˆ°é™„åŠ é©±åŠ¨ï¼Œé€‰ä¸­ç¬¬ä¸€ä¸ªä¸“æœ‰ç±»å‹çš„æ˜¾å¡é©±åŠ¨ï¼Œç‚¹å‡»ç¡®å®šç­‰å¾…å®‰è£…å®Œæˆã€‚ é™„å½•ï¼šç‰ˆæœ¬ä¿¡æ¯ç‰ˆæœ¬ï¼šver1.1æ•´ç†æ’°å†™ï¼šcyhasuka","link":"/posts/f9549b06/"},{"title":"WiFi 6ç»ˆç« ï¼ŸROGæ——èˆ°ä¸‡å…†è·¯ç”±GT-AX11000Proå¼€ç®±è¯„æµ‹","text":"1ã€å‰è¨€2022å¹´10æœˆ19æ—¥ï¼Œåç¡•å‘å¸ƒäº†ROG GT-AX11000 Proï¼Œäº¬ä¸œå®é™…åˆ°æ‰‹ä»· 3499 å…ƒã€‚ä½œä¸ºROGç©å®¶å›½åº¦é¡¶çº§è·¯ç”±å™¨å…«çˆªé±¼çš„æœ€æ–°æ¬¾ï¼Œåç¡•è¿™æ¬¾AX11000Proå·²ç»æ˜¯ç›®å‰ç¡¬è·¯ç”±é¢œå€¼+æ€§èƒ½å¤©èŠ±æ¿ã€‚ä¸Šä¸€æ¬¡ä½“éªŒåç¡•çš„å…«çˆªé±¼è¿˜æ˜¯åç¡•RT- AC5300ï¼Œä½†å¯æƒœéšç€WiFi 6çš„é™ä¸´ï¼Œè¢«åæ¥çš„AX86Uè–„çº±ï¼Œè¿™ä¸€æ¬¡ç»ˆäºæœ‰æœºä¼šå¯ä»¥å†æ¬¡ç”¨ä¸Šæœ€æ–°æ¬¾çš„å…«çˆªé±¼ã€‚ ROG Rapture GT-AX11000 Pro å¯ä»¥è¯´æ˜¯åç¡•ä¸‰å¹´å¤šå‰æ¨å‡ºçš„GT-AX11000çš„å‡çº§ç‰ˆã€‚å¦‚æœè¯´åè€…æ˜¯åç¡•è¿›å†›Wi-Fi 6çš„ç¬¬ä¸€æ­¥ï¼Œé‚£ä¹ˆè¿™æ¬¾GT-AX11000 Proå°±æ˜¯ROGç©å®¶å›½åº¦çš„ä¸‰é¢‘è·¯ç”±å™¨åœ¨Wi-Fi 6æ ‡å‡†ä¸­çš„ç»ˆæå½¢æ€(ç›®å‰å›½å†…Wi-Fi 7æ ‡å‡†ä¸Šçº¿è¿˜æ˜¯é¥é¥æ— æœŸï¼Œè€ŒWi-Fi 6Eçš„6GHzé¢‘æ®µæœªå¼€æ”¾ï¼Œä¼°è®¡è¿‘å‡ å¹´ç›¸åº”çš„è®¾å¤‡æ”¯æŒä¹Ÿå¾ˆéš¾å‡ºç°)ã€‚ 2ã€ç®€ä»‹å› ä¸ºæ–‡ç« æ¯”è¾ƒé•¿ï¼Œåœ¨å¼€å¤´å…ˆç®€è¦ä»‹ç»ä¸€ä¸‹ç¡¬ä»¶é…ç½®ã€‚ æ­¤æ¬¡çš„ROG GT-AX11000 Proå‡çº§SoCåˆ°åšé€šBCM4912ï¼Œç½‘ç»œæ¥å£æ–¹é¢æ­è½½1ä¸ªä¸‡å…†10Gç”µå£ï¼ˆè‡ªé€‚åº”2.5G/1Gï¼Œå¯é…ç½®WAN/LANå£ï¼‰ã€ä¸€ä¸ª2.5G/1G WANå£ã€4ä¸ªåƒå…†LANå£ã€‚å¦å¤–æ­è½½1ä¸ªUSB3.0ã€1ä¸ªUSB2.0æ¥å£ã€‚æ ‡é…65ç“¦ç”µæºé€‚é…å™¨ã€‚ ä¸Šé¢å‰è¨€é‡Œæåˆ°ï¼Œè¿™æ¬¾ROGç©å®¶å›½åº¦çš„ä¸‰é¢‘è·¯ç”±å™¨æ˜¯Wi-Fi 6æ ‡å‡†ä¸­çš„ç»ˆæå½¢æ€ã€‚è¿™æ˜¯å› ä¸ºGT-AX11000 Proæ”¯æŒ5GHzé¢‘è°±çš„æœ€åä¸€éƒ¨åˆ†ï¼Œå³UNII-4 bandã€‚UNII-4ä¹Ÿè¢«ç§°ä¸º5.9 GHzé¢‘æ®µï¼Œæ˜¯ä»802.11ax/WiFi 6é¢‘æ®µçš„å»¶ä¼¸ï¼Œä½†å®ƒä¸6GHzé¢‘æ®µçš„WiFi 6Eæ— å…³ã€‚UNII-4å…±å¢åŠ å››ä¸ª20MHzçš„Wi-Fiä¿¡é“ï¼Œå…³é”®æ˜¯å…è®¸ç¬¬ä¸‰ä¸ª160MHzå®½çš„ä¿¡é“ï¼Œåœ¨ä¿¡å·æ‹¥æŒ¤çš„åœ°æ–¹å¯èƒ½ä¼šå¸¦æ¥æå¤§çš„ä¾¿åˆ©ã€‚ä½†å¯æƒœçš„æ˜¯ï¼Œç›®å‰ï¼ŒUNII-4åªèƒ½åœ¨ç¾å›½ä½¿ç”¨ï¼Œå›½å†…æ­¤é¢‘æ®µæš‚æ—¶è¿˜æœªå¼€æ”¾ç»™æ°‘ç”¨æ— çº¿è®¾å¤‡ï¼Œä¹Ÿæ²¡æœ‰ç›¸åº”çš„è®¾å¤‡å¯ä»¥ä½¿ç”¨è¿™ä¸€é¢‘æ®µã€‚ ç›®å‰æ”¯æŒUNII-4é¢‘æ®µçš„è·¯ç”±å™¨ä¸»è¦æœ‰ä¸‹é¢å‡ æ¬¾ï¼š åç¡• ROG GT-AX11000 Pro (ä¸‰é¢‘) åç¡• ZenWiFi Pro XT12 (ä¸‰é¢‘) åç¡• ZenWifi XT9ã€XT8 (ä¸‰é¢‘) ç¾¤è¾‰ SynologyRT6600ax (ä¸‰é¢‘) ç¾¤è¾‰ Synology WRX560 (åŒé¢‘) ä¸‹é¢è´´ä¸€å¼ 5GHzé¢‘æ®µå›¾ï¼Œä¾›å¤§å®¶å‚è€ƒã€‚ 3ã€å¤–è§‚ä¸€ä¸ªå­—ï¼šå¤§ï¼ æ¯«ä¸å¤¸å¼ çš„è¯´ï¼Œè¿™æ¬¾å¤§çœ¼ç›æ‘†åœ¨å®¢å…ç”µè§†æŸœï¼Œç»å¯¹æ˜¯å¸ç›ä¸€æ­¥åˆ°ä½äº†ï¼ˆä¹‹å‰RT-AC5300å…«çˆªé±¼æ”¾åœ¨å®¢å…ï¼Œäº²æˆšæœ‹å‹æ¥éƒ½è¦å…ˆç…ä¸Šä¸¤çœ¼å“ˆå“ˆï¼‰ é•¿ï¼šçº¦35.5cm å®½ï¼šçº¦35.5cm é«˜ï¼ˆå¦‚ä¸‹å›¾ï¼Œå¤©çº¿ç«–ç›´ï¼‰ï¼šçº¦19cm é«˜ï¼ˆä¸»æœºæœ¬ä½“ï¼‰ï¼šçº¦6cm RT/GT-AC5300æœ‰ä¸€ä¸ªå°é—®é¢˜ï¼Œå°±æ˜¯ä»–ä»¬çš„å¯æ‹†å¸å¼å¤©çº¿çœŸçš„éå¸¸éå¸¸å®¹æ˜“æ¾åŠ¨ï¼Œç”¨ä¹…äº†ä¸å°å¿ƒç¢°ä¸€ä¸‹å°±ä¼šå€’ã€‚è€Œå¯æ‹†å¸å¼çš„è®¾è®¡æ„ä¹‰ä¸å¤§ï¼ˆèµ·ç æ˜¯å¯¹æˆ‘æ¥è¯´ï¼Œæ¯•ç«Ÿè°å¤©å¤©æ²¡äº‹æ‹†å¤©çº¿å˜ï¼‰ è¿™æ¬¡GT-AX11000 Proçš„è®¾è®¡å¸ˆæ˜¾ç„¶ä¹Ÿæ„è¯†åˆ°è¿™ä¸€é—®é¢˜ã€‚ä¸å¯æ‹†å¸å¼çš„å¤©çº¿éå¸¸ç‰¢å›ºï¼Œå½»åº•è§£å†³äº†å€’çš„é—®é¢˜ã€‚è¿™ä¸€ç‚¹ç»å¯¹ç»™å¥½è¯„ã€‚å¤©çº¿è§’åº¦å¯è°ƒï¼Œå¹¶ä¸”æ–¹å‘å¯ä»¥å·¦å³æ—‹è½¬è¿‘180Â°ã€‚ ç¡•å¤§çš„ROGè´¥å®¶ä¹‹çœ¼Logoç”±æ•°ä¸ªå°çš„â€œROGâ€å­—ç¬¦å¡«æ»¡ï¼Œå¤–å›´è¾¹ç¼˜ä¹Ÿå¯ä»¥RGBè”åŠ¨ï¼Œå¤œæ™šä¸‹ååˆ†è¿·äººã€‚ ç½‘ç»œæ¥å£æ–¹é¢æ­è½½1ä¸ªä¸‡å…†10Gç”µå£ï¼ˆè‡ªé€‚åº”2.5G/1Gï¼Œå¯é…ç½®WAN/LANå£ï¼‰ã€ä¸€ä¸ª2.5G/1G WANå£ã€4ä¸ªåƒå…†LANå£ã€‚ æœ‰ä¸€ç‚¹ç¾ä¸­ä¸è¶³çš„æ˜¯ï¼Œå½“å‰å®˜æ–¹å›ºä»¶ã€æ¢…æ—å›ºä»¶å‡æ— æ³•å°†2.5G WANå£è®¾ç½®ä¸ºLANå£ï¼Œå¯¹äºç›®å‰çš„å®¶åº­åƒå…†ç½‘ç»œç¯å¢ƒæ¥è¯´å¯èƒ½æ— æ³•å°†å…¶å……åˆ†åˆ©ç”¨ã€‚å¦‚æœèƒ½è®¾ç½®LAN1-4å…¶ä¸­ä¸€ä¸ªå½“åšè¿æ¥å¤–ç½‘çš„WANå£ï¼Œ2.5Gå½“åšå†…ç½‘ç«¯å£ä¸NASé€šä¿¡å°±å¥½äº†ã€‚ ç”µæºæ¥å£ã€ç”µæºé”®ï¼ˆç™½ç‚¹æŒ‰ä¸‹ä¸ºå¼€æœºï¼‰ã€ä¸¤ä¸ªUSB æ¥å£ç‰¹å†™ã€‚ä¸‹é¢ç« èŠ‚ä¸­å®æµ‹USB3.0è¯»é€Ÿé«˜è¾¾230MB/sã€‚ WPSã€LEDæŒ‰é’®ç‰¹å†™ã€‚å…¶ä¸­LEDæŒ‰é’®åœ¨è·¯ç”±å™¨åå°å¯ä»¥è‡ªå®šä¹‰åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ¸¸æˆåŠ é€Ÿã€DFSæ¨¡å¼ã€LEDå¼€å…³ã€Auraç¥å…‰åŒæ­¥ç­‰åŠŸèƒ½ã€‚ æŒ‡ç¤ºç¯ç‰¹å†™ï¼Œå…¶ä¸­10GEæŒ‡ç¤ºç¯å¯ä»¥æ˜¾ç¤ºä¸‡å…†ç«¯å£çŠ¶æ€ï¼ŒåŒ…æ‹¬æ˜¯å¦å¯ç”¨åŠæ•°æ®ååç­‰ã€‚ è¾¹è§’çš„æ•£çƒ­å­”æ—æœ‰ä¸€ä¸ªä¸‰è§’å½¢åˆ‡è§’è®¾è®¡ï¼Œå‡¹åˆ»äº†ä¸‰è§’å½¢çš„logo è·¯ç”±å™¨åº•éƒ¨å¤§é¢ç§¯é•‚ç©ºè®¾è®¡ï¼Œé…åˆå†…éƒ¨æ•£çƒ­ç‰‡æœ‰æ•ˆæ•£çƒ­ã€‚ä¸‰è§’å½¢ã€æ¢¯å½¢çš„ä¸¤å—å¤§å‹ç¡…èƒ¶è„šå«å°†è·¯ç”±å™¨åº•éƒ¨æŠ¬é«˜ï¼Œä½¿ç©ºæ°”å¯¹æµï¼Œè¾…åŠ©æ•£çƒ­ã€‚ é“­ç‰Œç‰¹å†™ï¼Œè¾“å…¥19.5V-3.33A æˆ– 19V-3.42Aã€‚ æ ‡é…å……ç”µå™¨æ¥è‡ªåº·èˆ’ç§‘æŠ€ï¼Œè¾“å…¥å®½å¹…100-240V 1.7A 50-60Hzï¼Œè¾“å‡º+19.5V-3.33Aã€‚æœ€å¤§è¾“å‡ºåŠŸç‡65Wã€‚ å®æµ‹å¹³å‡å¾…æœºè¿è¡Œæ—¶åŠŸç‡åŠè€—ç”µé‡ï¼š ç¯å…‰å…³é—­ï¼šçº¦12W æ¯æ—¥ç”¨ç”µçº¦0.28åº¦ ç¯å…‰å¼€å¯ï¼šçº¦14W æ¯æ—¥ç”¨ç”µçº¦0.33åº¦ åŒ…è£…å†…é™„è¯´æ˜ä¹¦ 4ã€ç¡¬ä»¶ 4.1ã€ç¡¬ä»¶æ‹“æ‰‘ SoCï¼šBCM4912ï¼Œ4æ ¸å¿ƒARM Cortex A53 CPUï¼Œ16nmå·¥è‰ºï¼Œ2.0GHzä¸»é¢‘ RAMï¼šDDR4 1024MB FLASHï¼š256MB PHYï¼š10G PHYä¸ºBCM84891L 2.4Gï¼šBCM6715ï¼ŒFEMä¸ºSKY85331-11 5G1ï¼šBCM6715ï¼ŒFEMä¸ºSKY85743 5G2ï¼šBCM6715ï¼ŒFEMä¸ºSKY85743 ä¸‹é¢ç¡¬ä»¶ç¤ºæ„å›¾ä¾›å‚è€ƒã€‚ 4.2ã€æ•£çƒ­è·¯ç”±å™¨æ•´ä½“é‡‡ç”¨è¢«åŠ¨æ•£çƒ­ï¼ŒåŒ…æ‹¬ä¿¡å·æ”¾å¤§å™¨åœ¨å†…çš„åŸºæœ¬æ‰€æœ‰èŠ¯ç‰‡å‡è¦†ç›–å¯¼çƒ­ç¡…èƒ¶å«ï¼Œä½¿ç”¨é“åˆ¶æ•£çƒ­ç‰‡è¾…åŠ©æ•£çƒ­ã€‚ å®é™…æµ‹è¯•ï¼Œè¿è¡Œä¸€å‘¨æ—¶é—´ï¼Œä¸»SoCæ¸©åº¦åœ¨50åº¦å·¦å³ï¼Œ2.4Gã€5Gæ¸©åº¦åœ¨45åº¦å·¦å³ã€‚ï¼ˆå®¤å†…ç¯å¢ƒæ¸©åº¦ä¸º21åº¦ï¼Œæ¹¿åº¦35%ï¼‰ 4.3ã€ç«¯å£1ä¸ª2.5G WANå£ï¼Œ1ä¸ª10GbEç«¯å£ï¼Œ4ä¸ªåƒå…†LANå£ï¼Œ1ä¸ªUSB3.0æ¥å£ï¼Œ1ä¸ªUSB2.0æ¥å£ã€‚ 5ã€å›ºä»¶ 5.1ã€åç¡•å®˜æ–¹å›ºä»¶å®˜æ–¹å›ºä»¶ç»§æ‰¿äº†ROGè·¯ç”±å™¨ä¸€è´¯çš„é£æ ¼ï¼Œä»ªè¡¨æ¿æ˜¾ç¤ºåŸºæœ¬çš„æ— çº¿çŠ¶æ€ã€WAN IPã€ç½‘ç»œæµé‡ã€æ¸¸æˆæ¢æµ‹é›·è¾¾ã€Aura RGBã€LEDæŒ‰é”®ç»‘å®šç­‰åŠŸèƒ½ã€‚ ä¸‰æ®µç”µç«åŠ é€ŸåŠŸèƒ½ ç”µç«åŠ é€ŸåŠŸèƒ½å¯ä»¥ä¸ºæ¸¸æˆè®¾å¤‡åˆ°æœåŠ¡å™¨æ¯ä¸€é˜¶æ®µæä¾›å¯é è¿æ¥ï¼Œå…¶ä¸­ä¸€ä¸ª5Gé¢‘æ®µåœ¨å¼€å¯ç”µç«æ¨¡å¼åæä¾›ä¸“å±é€šé“ï¼Œæœ€å¤§ç¨‹åº¦ä¿è¯æ¸¸æˆæ—¶è¿æ¥è´¨é‡ã€‚å¯¹äºROGè®¾å¤‡æœ‰ç€ROG Firstæœ€é«˜ä¼˜å…ˆçº§ï¼Œé…åˆæ¸¸æˆå°åŒ…ä¼˜åŒ–ï¼Œå¯ä»¥ç»™ROGç©å®¶å¸¦æ¥å‰æ‰€æœªæœ‰çš„æµç•…æ¸¸æˆå»¶è¿Ÿã€‚ä¸”è·¯ç”±å™¨å†…ç½®ç½‘æ˜“UUåŠ é€Ÿå™¨ï¼Œå¯ä»¥è½»æ¾ä¸ºPS5ã€Xboxã€Switchç­‰ä¸»æœºæä¾›åŠ é€Ÿã€‚å¯¹äºæ‰‹æœºè®¾å¤‡ï¼Œæ‰‹æœºä¸‹è½½ASUS ROUTER appæˆ–è€…ç”µè„‘è·¯ç”±é¡µé¢å³å¯å¼€å¯ç”µç«æ¨¡å¼ï¼Œæé«˜è®¾å¤‡ä¼˜å…ˆçº§ï¼Œæœ€å¤§ç¨‹åº¦é™ä½pingå€¼å’Œä¸¢åŒ…ç‡ã€‚ æ¸¸æˆæ¢æµ‹é›·è¾¾åŠŸèƒ½ï¼Œæä¾›æ¸¸æˆæœåŠ¡å™¨pingåŠŸèƒ½ï¼Œå¯»æ‰¾æœ€ä¼˜åŒºæœã€‚ æ€»ä½“è€Œè¨€ï¼Œå¯¹äºä¸€èˆ¬æ²¡æœ‰ç‰¹æ®Šéœ€æ±‚çš„ç”¨æˆ·ï¼Œåç¡•å®˜æ–¹å›ºä»¶åŠŸèƒ½å·²ç»è¶³å¤Ÿå¼ºå¤§ï¼Œæ»¡è¶³æ—¥å¸¸æ‰€éœ€ç»°ç»°æœ‰ä½™ã€‚ 5.2ã€æ¢…æ—å›ºä»¶ç”±äºåç¡•è·¯ç”±å™¨å¼€æºäº†Asuswrtï¼Œæ¢…æ—å›ºä»¶çš„å¼€å‘è€…Eric Sauvageauï¼ˆRMerlï¼‰ åœ¨æ­¤åŸºç¡€ä¹‹ä¸Šï¼Œå¼€å‘äº†Asuswrt-Merlin ç³»ç»Ÿ ï¼Œä¸»è¦ç›®æ ‡æ˜¯å¢å¼ºç°æœ‰çš„Asuswrtå›ºä»¶ï¼Œå¹¶ä¿®å¤ä¸€äº›å·²çŸ¥çš„é—®é¢˜å’Œé™åˆ¶ï¼ŒåŒæ—¶ä¿æŒä¸åŸå§‹å›ºä»¶ç›¸åŒçš„æ€§èƒ½æ°´å¹³ã€‚æ­¤å¤–ï¼Œæ¢…æ—å›ºä»¶æ”¯æŒå¾ˆå¤šæ–°åŠŸèƒ½ï¼Œ æ¯”å¦‚ç”¨æˆ·è„šæœ¬ï¼ŒCronå®šæ—¶ä»»åŠ¡ï¼Œè‡ªå®šä¹‰è·¯ç”±é…ç½®æ–‡ä»¶ï¼Œå¤§å®¹é‡ç¡¬ç›˜ï¼Œè°ƒæ•´WiFiåŠŸç‡ï¼Œè½¯ä»¶ä¸­å¿ƒ ç­‰ç­‰ï¼Œ å…·ä½“çš„å¯ä»¥å»é¡¹ç›®å®˜ç½‘äº†è§£ã€‚ å›½å†…æ¯”è¾ƒå¸¸è§çš„æ¢…æ—å›ºä»¶æ˜¯KoolShareåŸºäºåŸç‰ˆæ¢…æ—å›ºä»¶æ”¹é€ è¿‡çš„ï¼ˆç°åœ¨å«KoolCenterï¼‰ï¼Œå…¶æ­è½½çš„è½¯ä»¶ä¸­å¿ƒæ’ä»¶åŠŸèƒ½æ¯”è¾ƒå¼ºå¤§ï¼Œè¿›é˜¶ç”¨æˆ·å¯ä»¥ä»ä¸­æ‰¾åˆ°è‡ªå·±éœ€è¦çš„ç½‘ç»œå·¥å…·ã€‚ æ­¤æ¬¡åˆ·æœºçš„å›ºä»¶ä¸ºKoolCenter 2022å¹´12æœˆ9æ—¥å‘å¸ƒçš„æ¢…æ—388.1_0ç‰ˆæœ¬ã€‚388ç‰ˆæœ¬å›ºä»¶å®˜æ–¹è¾ƒå¤§çš„æ›´æ–°å°±æ˜¯å¼•å…¥äº†wireguardæ”¯æŒï¼Œæ¢…æ—388å›ºä»¶åŒæ ·æ”¯æŒwgï¼Œä½†æ˜¯è¿˜æ˜¯ä»¥openvpnä¸ºä¸»ã€‚ ä»ªè¡¨æ¿ç­‰å¸ƒå±€åŸºæœ¬ç›¸åŒï¼Œå·¦ä¸Šè§’çš„Powered by Asuswrt-Merlin è¡¨æ˜äº†å›ºä»¶èº«ä»½ã€‚ æ’ä»¶WiFi Radarï¼Œå¯ä»¥æ¢æµ‹è·¯ç”±å™¨å‘¨å›´ç½‘ç»œç¯å¢ƒï¼ŒæŸ¥æ‰¾å‘¨å›´æ‰€æœ‰çš„WiFiç½‘ç»œï¼Œæ˜¾ç¤ºä¿¡å·å¹²æ‰°ä»¥ä¾¿ç”¨æˆ·æ‰¾åˆ°æœ€ä½³ä¿¡é“ï¼Œæå‡ç½‘ç»œç¨³å®šæ€§ã€‚ å¯ä»¥çœ‹å‡ºå®¶é‡Œç½‘ç»œç¯å¢ƒè¿˜æ˜¯å¾ˆå¥½çš„ï¼Œå‘¨å›´æ²¡æœ‰ä¿¡å·å¹²æ‰°çš„æƒ…å†µã€‚ KoolShareæ¢…æ—å›ºä»¶çš„è½¯ä»¶ä¸­å¿ƒé¡µé¢ï¼Œæä¾›äº†å¾ˆå¤šå®ç”¨çš„ç½‘ç»œå·¥å…·ä»¥åŠå°æ’ä»¶ï¼ŒåŒ…æ‹¬ç­¾åˆ°ã€æ­å»ºå®¶ç”¨NASåŠä¸ªäººç½‘ç«™å¸¸ç”¨çš„å†…ç½‘ç©¿é€ç­‰ç­‰ï¼Œæœ‰éœ€è¦å¯ä»¥è‡ªè¡Œä¸‹è½½ï¼Œå‚»ç“œå¼æ“ä½œã€‚ 6ã€æ€§èƒ½æµ‹è¯• 6.1ã€å¤–ç½‘æµ‹è¯•ä»‹ç»ä¸€ä¸‹å®¶é‡Œçš„å®½å¸¦ç¯å¢ƒã€‚å…‰çº¤å…¥æˆ·ï¼Œç”±å…‰çŒ«å…‰ç”µè½¬æ¢åä½¿ç”¨è·¯ç”±å™¨æ‹¨å·ã€‚è”é€šç½‘ç»œï¼Œç­¾çº¦ä¸Šè¡Œ1000Mbpsï¼Œä¸‹è¡Œ100Mbpsï¼Œå±±ä¸œé’å²›åœ°åŒºã€‚ é¦–å…ˆï¼Œæµ‹è¯•è·¯ç”±å™¨æ— é®æŒ¡è¦†ç›–ã€‚ä¸ºäº†æ›´åŠ æ¥è¿‘å®é™…åº”ç”¨åœºæ™¯ï¼Œé‡‡ç”¨å®½å¸¦æµ‹é€Ÿè€Œéä¿¡å·å¼ºåº¦æµ‹è¯•ï¼Œå¯¹å¤§å¤šæ•°äººæ¥è¯´ç»“æœæ›´ä¸ºç›´è§‚ã€‚ ä½¿ç”¨10ç±³6ç±»ç½‘çº¿å°†è·¯ç”±å™¨å»¶é•¿æ”¾ç½®äºçª—å£ï¼ˆæ— ç»ç’ƒç­‰ä»»ä½•é®æŒ¡ï¼‰ï¼ŒæŒ‰è·ç¦»æµ‹è¯•ç½‘é€Ÿã€‚å¯ä»¥çœ‹å‡ºï¼Œæ¾³å¤§åˆ©äºšåŒºåœ¨çŸ­è·ç¦»å’Œé•¿è·ç¦»éƒ½æœ‰ä¼˜åŠ¿ï¼Œåœ¨ä¸­é•¿è·ç¦»ä¼šå­˜åœ¨ä¸€å®šçš„å¼±åŠ¿ã€‚ä½†æ€»ä½“æ¥è¯´ï¼Œ5Gé¢‘æ®µæœ‰å¦‚æ­¤è¡¨ç°å·²ç»å¯åœˆå¯ç‚¹ï¼Œå·²ç»ä½äºç¬¬ä¸€æ¢¯é˜Ÿï¼ŒWiFi 6çš„æ³¢æŸæˆå½¢ç­‰ç›¸å…³æŠ€æœ¯çš„åº”ç”¨ä¹Ÿä¸ºé•¿è·ç¦»çš„æµ‹é€Ÿè¡¨ç°æä¾›äº†å¾ˆå¥½çš„å¸®åŠ©ã€‚ WANå£ï¼š2.5Gï¼ˆå®é™…ä¸å…‰çŒ«æ¡æ‰‹é€Ÿç‡1Gï¼‰ è·¯ç”±å™¨åœ°åŒºï¼šæ¾³å¤§åˆ©äºš è¿æ¥é¢‘æ®µï¼š5G1 160MHz æµ‹é€Ÿè®¾å¤‡ï¼šROG å¹»14 Win11 ç”µæ± ä¾›ç”µï¼ˆæ›´æ¢ç½‘å¡ä¸ºIntel AX210ï¼‰ æµ‹é€Ÿè½¯ä»¶ï¼šSpeedtest 6.2ã€å†…ç½‘æµ‹è¯•å†…ç½‘æµ‹è¯•ç¯å¢ƒï¼Œæœ‰çº¿è¿æ¥ä½¿ç”¨7ç±»ç½‘çº¿è¿æ¥PCç«¯ï¼Œç»Ÿä¸€ä½¿ç”¨ä¸‡å…†PCIEç½‘å¡è¿æ¥è·¯ç”±å™¨ï¼ˆç½‘å¡æ”¯æŒ10G/2.5G/1Gè‡ªåŠ¨åå•†ï¼‰ã€‚æ— çº¿è¿æ¥æµ‹è¯•ä»ç„¶ä½¿ç”¨ROG å¹»14ï¼ˆç½‘å¡Intel AX210ï¼‰ï¼Œè·ç¦»è·¯ç”±å™¨1.5ç±³ï¼Œæ— é®æŒ¡ã€‚ å†…ç½‘ç¯å¢ƒä¸­ï¼Œè·¯ç”±å™¨åŸºæœ¬å¯ä»¥è·‘æ»¡ç«¯å£é€Ÿç‡ã€‚ç‰¹åˆ«çš„ï¼Œåœ¨30åˆ†é’Ÿå‹åŠ›æµ‹è¯•ä¸‹ï¼Œç«¯å£é€Ÿç‡ä¹Ÿæ²¡æœ‰æ˜æ˜¾æ‰é€Ÿæƒ…å†µå‡ºç°ï¼Œç¨³å®šæ€§è¿˜æ˜¯ä¸é”™çš„ã€‚ å®¤å†…æ— çº¿è¦†ç›–æµ‹è¯•ï¼Œä¸ºé˜²æ­¢å†…ç½‘è®¾å¤‡å¯¹æµ‹é€Ÿç»“æœé€ æˆç“¶é¢ˆï¼Œä½¿ç”¨ç»¿è”DX4600 NASåŒ2.5Gé“¾è·¯èšåˆç»„æˆ5Gé€Ÿç‡ï¼Œè°ƒç”¨å…¶ä¸­å›ºæ€ç¡¬ç›˜PM981Aè¿›è¡Œè¯»å†™æµ‹è¯•ã€‚å…·ä½“è¿æ¥æƒ…å†µä¸ºï¼šè·¯ç”±å™¨10Gç«¯å£è¿æ¥ä¸‡å…†äº¤æ¢æœºï¼Œäº¤æ¢æœºç«¯å°†NASåŒ2.5Gé“¾è·¯èšåˆã€‚ æµ‹è¯•ç»“æœï¼Œè·¯ç”±å™¨æ— é®æŒ¡çš„å®¢å…ç½‘ç»œç¯å¢ƒæœ€å¥½ï¼ŒåŸºæœ¬èƒ½è¾¾åˆ°æ»¡é€Ÿç‡è¿è¡Œã€‚è€Œå«ç”Ÿé—´ç”±äºé—´éš”ä¸€å µæ‰¿é‡å¢™ã€ä¸€å µéæ‰¿é‡å¢™ï¼Œä¿¡å·æœ‰æ‰€è¡°å‡ï¼Œä½†å¯¹äºå®é™…ä¸Šç½‘ä½“éªŒæ¥è¯´ä»ç„¶æ»¡è¶³åŸºæœ¬éœ€æ±‚ã€‚ 6.3ã€USBæµ‹è¯•æµ‹è¯•ç¯å¢ƒï¼šä½¿ç”¨å›ºæ€Uç›˜æµ‹è¯•ï¼Œæ–‡ä»¶ç³»ç»Ÿä¸ºNTFSã€‚æµ‹è¯•æ—¶å…³é—­è·¯ç”±å™¨2.4Gæ— çº¿ç½‘ç»œã€‚åˆ†åˆ«æµ‹è¯•ä¸‡å…†ç«¯å£åŠä¸¤ä¸ª5Gé¢‘æ®µä¸‹è¯»å–USBè®¾å¤‡çš„é€Ÿç‡ã€‚ 7ã€ä½“éªŒæ€»ç»“ä½œä¸ºROGåœ¨å›½å†…å‘å”®çš„é¡¶çº§è·¯ç”±å™¨ï¼ŒåŠŸèƒ½éå¸¸é½å…¨ï¼Œæ”¯æŒAiMesh2.0ã€åŒçº¿è·¯æ¥å…¥ã€ç«¯å£èšåˆç­‰åŠŸèƒ½ï¼ŒSoCæ–¹é¢æ”¯æŒåšé€šæ–°ä¸€ä»£Rangeboost PlusæŠ€æœ¯ï¼Œæ™ºèƒ½è¯†åˆ«å¹²æ‰°ã€‚è€Œ2.5G WANå£é…åˆ10GbEç«¯å£å±äºæˆ˜æœªæ¥çš„é…ç½®ï¼Œå¯¹äºç°ä»Šçš„å®½å¸¦ç¯å¢ƒè€Œè¨€ï¼Œ2.5G WANå£å¯¹äºä¸€èˆ¬å®¶åº­æ¥è¯´æ„ä¹‰æœ‰é™ï¼Œå¦‚æœåæœŸå›ºä»¶æ›´æ–°å¯ä»¥æ”¯æŒå°†å…¶è®¾ç½®ä¸ºLANå£ï¼Œå¯¹äºå†…ç½‘çš„ä½¿ç”¨ä½“éªŒæ¥è¯´åè€Œä¼šæ›´å¥½ã€‚ å¯¹äºæˆ‘ä¸ªäººçš„æ•´ä½“ä½¿ç”¨ä½“éªŒï¼Œä¹‹å‰å®¶é‡Œä½¿ç”¨çš„æ˜¯AX86U(ä¸»)+AC5300(AiMeshèŠ‚ç‚¹)çš„ç»„åˆã€‚å®¶ä¸­è´­ç½®äº†ç»¿è”DX4600 NASåï¼Œå…¶æ­è½½åŒ2.5Gç½‘å£ï¼Œå¯ä»¥é€šè¿‡é“¾è·¯èšåˆç»„æˆ5Gé€Ÿç‡ã€‚ä½†AX86Uä»…æœ‰ä¸€ä¸ª2.5Gç½‘å£ï¼Œæ— æ³•å……åˆ†å‘æŒ¥NASçš„æ€§èƒ½ã€‚å¹¶ä¸”å½“å®¶ä¸­NASé«˜è´Ÿè½½ä¸‹è½½ä½¿ç”¨æ—¶ï¼ŒAiMeshè¿æ¥åˆ°AC5300ä¼šå¶å‘æ€§çš„å­˜åœ¨æ‰é€Ÿç”šè‡³æ–­è”çš„æƒ…å†µã€‚è€Œä¸”AC5300ç”±äºå¹´ä»£è¾ƒä¸ºä¹…è¿œï¼Œå†…éƒ¨ç¡…èƒ¶å«å­˜åœ¨è€åŒ–çš„æƒ…å†µï¼Œè™½ç„¶è¿›è¡Œäº†æ›´æ¢ï¼Œä½†å‘çƒ­ä»ç„¶è¾ƒä¸ºä¸¥é‡ï¼Œæˆ‘ç”šè‡³åŠ è£…äº†é£æ‰‡æ¥ç¼“è§£å‘çƒ­çš„é—®é¢˜ã€‚ è¿™äº›é—®é¢˜éšç€GT-AX11000Proçš„åˆ°æ¥è¿åˆƒè€Œè§£ã€‚è™½ç„¶éƒ½æ˜¯å…«çˆªé±¼ï¼Œä½†è¿™æ¬¾ç›¸è¾ƒäºæˆ‘ä¹‹å‰çš„è€æ¬¾AC5300å…«çˆªé±¼æå‡éå¸¸å¤§ï¼Œå°¤å…¶æ˜¯ç¨³å®šæ€§ä»¥åŠç«¯å£ä¸°å¯Œæ€§ã€‚æ­è½½çš„ä¸‡å…†ç½‘å£ç»™å†…ç½‘ç¯å¢ƒå¢æ·»äº†æ›´å¤šå¯ç©æ€§ï¼ŒåŒæ—¶æ­é…æ¢…æ—å›ºä»¶åº”ç”¨ä¸­å¿ƒçš„æ’ä»¶ï¼Œæ­å»ºä¸ªäººç½‘ç«™ã€ç§æœ‰äº‘æ›´åŠ æ–¹ä¾¿ï¼Œç»™å®¶åº­å¨±ä¹ç³»ç»Ÿæä¾›äº†ç¨³å®šçš„ç¡¬ä»¶æ”¯æŒã€‚è€Œæ— çº¿è¦†ç›–é¢ç§¯å¯¹äºæˆ‘ä¸ªäººè€Œè¨€è¾ƒä¸ºæ¬¡è¦ï¼ŒGT-AX11000Pro(ä¸»)+ AX86U (AiMeshèŠ‚ç‚¹)çš„ç»„åˆå·²ç»å¯ä»¥æ»¡è¶³ç»å¤§éƒ¨åˆ†å®¶åº­éœ€æ±‚ã€‚å¯¹äºæè‡´ç©å®¶ï¼Œæ­é…ä¸‡å…†äº¤æ¢æœºæ„å»ºä¸‡å…†å†…ç½‘ç¯å¢ƒä¹Ÿæ˜¯ä¸€ç§å¾ˆå¥½çš„é€‰æ‹©ã€‚","link":"/posts/727a344e/"},{"title":"ubuntuå¼€æœºå¼¹å‡ºç³»ç»Ÿç¨‹åºå‡ºç°é—®é¢˜è§£å†³æ–¹æ³•","text":"å¼€æœºæç¤º:æ£€æµ‹åˆ°ç³»ç»Ÿç¨‹åºå‡ºç°é—®é¢˜ä¿®æ”¹æ–¹æ³•ï¼š æ‰“å¼€ç»ˆç«¯ï¼Œè¾“å…¥ 1sudo gedit /etc/default/apport æŠŠenabled=1æ”¹æˆenabled=0åŸç†ï¼š å…³é—­ç³»ç»Ÿè‡ªåŠ¨æ£€æµ‹ é—®é¢˜è§£å†³ã€‚","link":"/posts/9a7bc0ac/"},{"title":"ä¸‰é˜²é“ ç”²ï¼Œåšè‹¥ç£çŸ³-åç¡•TUF Gamingé“ ç”²å›ºæ€ç¡¬ç›˜ç›’ä½“éªŒè¯„æµ‹","text":"ä»Šå¹´åæœˆåˆï¼Œåç¡•æ——ä¸‹çš„TUF æ¨å‡ºäº†è‡ªå®¶çš„T1Aé“ ç”²ä¸‰é˜²ç§»åŠ¨ç¡¬ç›˜ç›’ï¼Œè¡¥é½äº†TUFç¡¬ç›˜ç›’åˆ†æ”¯çš„äº§å“çº¿ã€‚ä¸ä¹‹å‰ROGæ¨å‡ºçš„ç¡¬ç›˜ç›’ç›¸æ¯”ï¼ŒTUFæ­¤æ¬¾ç¡¬ç›˜ç›’åœ¨ä¿è¯ä¼˜ç§€æ€§èƒ½çš„åŒæ—¶ï¼Œä¸»æ‰“ä¸‰é˜²åŠŸèƒ½ï¼ŒåŒå¸‚é¢ä¸Šçš„å„ç±»ç¡¬ç›˜ç›’äº§å“åšå‡ºäº†å·®å¼‚åŒ–ï¼Œå½¢æˆäº†äº’è¡¥ã€‚å‰ä¸¤å¤©æ‹¿åˆ°è¿™æ¬¾äº§å“ï¼Œé€šè¿‡æ‹†è§£è¯„æµ‹ä¸€ä¸‹è¿™æ¬¾äº§å“çš„åšå·¥åŠæ€§èƒ½ã€‚ 1. å‚æ•°ä»‹ç»æ­¤æ¬¾TUFç¡¬ç›˜ç›’æ”¯æŒUSB3.2 Gen2æ¥å£çš„å¸¦å®½è§„æ ¼ï¼Œæœ€å¤§é¡ºåºè¯»å†™é€Ÿåº¦å‡ä¸º10Gbpsï¼Œä¹Ÿå³1000MB/Sä¸Šä¸‹ã€‚åŒæ—¶æ”¯æŒNvmeä¸SATAä¸¤ç§åè®®çš„M.2å›ºæ€ç¡¬ç›˜ã€‚è¿™é‡Œéœ€è¦æé†’ä¸€ä¸‹ï¼Œä½¿ç”¨SATAåè®®çš„M.2å›ºæ€çš„è¯ï¼Œç”±äºSATAåè®®å…ˆå¤©çš„æ€§èƒ½é™åˆ¶ï¼Œæœ€é«˜é¡ºåºè¯»å†™é€Ÿåº¦åªèƒ½è¾¾åˆ°6Gbpsã€‚ä½¿ç”¨Q-LATCH å…å·¥å…·å¡æ‰£ä¾¿äºæ‹†å¸ï¼Œå¹¶ä¸”é€šè¿‡MIL-STD-810Hå†›å·¥æµ‹è¯•ï¼Œå…·å¤‡IP68é˜²å°˜é˜²æ°´å±æ€§ï¼Œæœ€å¤§é™åº¦ä¿è¯æ•°æ®å®‰å…¨ã€‚ 2. å¼€ç®±ç¯‡ç¡¬ç›˜ç›’åŒ…è£…é‡‡ç”¨ä¹¦æœ¬å¼ç¿»ç›–è®¾è®¡ï¼Œæ‰“å¼€åŒ…è£…å³å¯çœ‹åˆ°å¿«é€Ÿå®‰è£…æ‰‹å†Œã€è¯´æ˜ä¹¦ã€ä¿å¡ã€‚ åŒ…è£…å†…éƒ¨é™¤ç¡¬ç›˜ç›’æœ¬ä½“åŠUSB-Aè½¬USB-Cæ•°æ®çº¿å¤–ï¼Œå¦é™„é€ä¸€æ ¹å…­è§’æ‰³æ‰‹ç”¨äºæ‹†å¸ç¡¬ç›˜ç›’å¤–å£³ã€‚ ç¡¬ç›˜ç›’å¤–è§‚éå¸¸ç¡¬æœ—ï¼Œçº¯é‡‘å±å¤–å£³æ£±è§’åˆ†æ˜ï¼Œæ‰å®çš„é“å¨å¨æœ¬ä½“é‡è¾¾142gï¼Œæ¡åœ¨æ‰‹é‡Œååˆ†å‹æ‰‹ï¼Œåˆ†é‡åè¶³ã€‚è¡¨é¢ä¸ºç£¨ç ‚æè´¨ï¼Œè‡ªå¸¦é’¥åŒ™æ‰£è®¾è®¡ã€‚ä¸ROGä¸åŒï¼ŒTUFè¿™æ¬¾ç¡¬ç›˜ç›’æ²¡æœ‰é‡‡ç”¨RGBç¯æ•ˆï¼Œåªåœ¨é¡¶éƒ¨æœ‰ä¸€æšæ˜¾ç¤ºå·¥ä½œçŠ¶æ€çš„æŸ”å…‰LEDæŒ‡ç¤ºç¯ã€‚ ç¡¬ç›˜ç›’èƒŒé¢å°æœ‰TUF GAMINGçš„äº§å“logoï¼Œåº•å£³åŒæ ·ä¸ºçº¯é‡‘å±æè´¨ï¼Œç”±4é¢—é»‘è‰²å†…å…­è§’èºä¸è¿›è¡Œå›ºå®šã€‚æ­¤ç§æ–¹å¼ç›¸æ¯”å¡æ‰£åŠå¸¸è§çš„æ¨æ‹‰å¼ç»“æ„æ›´åŠ å¯é ï¼Œæ­é…èƒ¶åœˆåŒæ—¶ä¹Ÿä¿è¯äº†é˜²æ°´æ€§èƒ½ã€‚ 3. æ‹†è§£ç¯‡æ‹§ä¸‹å››é¢—èºä¸ä¾¿å¯ä»¥çœ‹åˆ°ç¡¬ç›˜ç›’PCBæœ¬ä½“ã€‚å†…éƒ¨é‡‡ç”¨å°é˜¶å¼è®¾è®¡ï¼Œæ­é…é»‘è‰²é˜²å°˜é˜²æ°´èƒ¶åœˆï¼Œä»¥å‘ˆç°å‡ºè‰²çš„é˜²æ°´æ€§èƒ½ã€‚ç¡¬ç›˜ç›’å¤–å£³å‡ºå‚å·²è´´å¥½å¯¼çƒ­ç¡…èƒ¶å«ï¼Œé…åˆåšå®çš„å£³ä½“å¯¹ç¡¬ç›˜è¿›è¡Œæ•£çƒ­ã€‚ ç»§ç»­æ‹†è§£ã€‚æ‹§ä¸‹4é¢—å›ºå®šPCBæ¿çš„åå­—èºä¸ï¼Œå–ä¸‹PCBã€‚å¯ä»¥çœ‹åˆ°ç¡¬ç›˜ç›’é‡‡ç”¨ç‘æ˜±RTL9210Bï¼ŒNVMEã€SATAåŒåè®®ä¸»æ§èŠ¯ç‰‡ã€‚æ­¤å‰è¯¥èŠ¯ç‰‡å›ºä»¶æ›¾å­˜åœ¨bugï¼Œå³ä½¿å®‰å…¨å¼¹å‡ºä¹Ÿä¼šå¯¼è‡´ç¡¬ç›˜ä¸å®‰å…¨å…³æœºæ¬¡æ•°å¢åŠ ã€‚ç°åœ¨å‚å•†å·²ç»æ›´æ–°å›ºä»¶ï¼Œä¹‹å‰çš„é—®é¢˜å·²ç»å¾—åˆ°è§£å†³ï¼Œå¤§å®¶å¯ä»¥æ”¾å¿ƒä½¿ç”¨ã€‚ å¤§å®¶æˆ–è®¸å·²ç»æ³¨æ„åˆ°ï¼Œä¸çŸ¥ä½•ç§åŸå› å°èƒèŸ¹ä¸»æ§å‡ºå‚å¹¶æœªè¦†ç›–ç¡…èƒ¶å¯¼çƒ­è´´ã€‚æ­¤æ¬¾ä¸»æ§è™½ç„¶æ¸©åº¦æ§åˆ¶æ¯”è¾ƒä¼˜ç§€ï¼Œä½†æ”¾ç€è¿™ä¹ˆåšå®çš„æ•£çƒ­å¤–å£³ä¸ç”¨ä¼¼ä¹æœ‰äº›å¯æƒœã€‚æˆ‘è‡ªè¡Œæ·»åŠ äº†ä¸€å—åšåº¦ä¸º1mmçš„æ•£çƒ­ç¡…èƒ¶è´´ï¼Œä¾›åŠ¨æ‰‹èƒ½åŠ›å¼ºçš„å°ä¼™ä¼´å‚è€ƒã€‚ é˜²æ°´USB-Cæ¥å£ç‰¹å†™ï¼Œæ¥å£ç«¯å­ç›¸è¾ƒæ™®é€šUSB-Cæ¯å£è¾ƒçŸ­ï¼Œåœ¨å¤–å±‚æ·»åŠ äº†é˜²æ°´æ©¡èƒ¶åœˆï¼Œå¯ä»¥æ›´å¥½çš„åº”å¯¹æç«¯ç¯å¢ƒã€‚ Q-LATCH å…å·¥å…·å¡æ‰£ç‰¹å†™ï¼Œç›¸è¾ƒå¾€å¸¸çš„èºä¸å›ºå®šåŠæ©¡èƒ¶å¡å›ºå®šï¼Œè¿™ç§æœ€æ–°ç ”å‘çš„å¡æ‰£ç»“æ„æ›´åŠ ä¾¿äºå¯¹ç¡¬ç›˜è¿›è¡Œæ›´æ¢æ‹†å¸ï¼Œåªéœ€æ—‹è½¬å³å¯ï¼Œååˆ†æ–¹ä¾¿ï¼Œç»™å¤§å¤§çš„å¥½è¯„ã€‚ç¡¬ç›˜ç›’æ”¯æŒ2242ã€2260ã€2280ä¸åŒé•¿åº¦ã€‚ 4. æµ‹è¯•ç¯‡ä¸Šæœºï¼Œä½¿ç”¨CrystalDiskMarkè¿›è¡Œç†è®ºæµ‹è¯•ï¼Œè¿™æ¬¾è½¯ä»¶é»˜è®¤æ˜¾ç¤ºè¯»å†™æµ‹è¯•ç»“æœçš„å³°å€¼ï¼Œå¯ä»¥çœ‹åˆ°é¡ºåºè¯»å†™é€Ÿåº¦åŸºæœ¬è¾¾åˆ°äº†10Gå¸¦å®½ç†è®ºä¸Šé™ã€‚ NVMEç¡¬ç›˜é‡‡ç”¨ä¸‰æ˜Ÿ980Pro 1TBæµ‹è¯•ï¼ŒæŒç»­è¯»å–é€Ÿåº¦ä¸ºï¼š1057.71MB/s æŒç»­å†™å…¥é€Ÿåº¦ä¸ºï¼š1046.88MB/sã€‚ SATAç¡¬ç›˜é‡‡ç”¨ä¸‰æ˜ŸPM871a 512GBæµ‹è¯•ï¼ŒæŒç»­è¯»å–é€Ÿåº¦ä¸ºï¼š540.85MB/s æŒç»­å†™å…¥é€Ÿåº¦ä¸ºï¼š520.66MB/sï¼Œè¾¾åˆ°SATAæ ‡ç§°çš„6Gbpsé€Ÿåº¦ã€‚ ä»æ€§èƒ½æµ‹è¯•æ¥çœ‹TUF ç¡¬ç›˜ç›’å·²ç»è¾¾åˆ°æ¥å£æ ‡ç§°æ€§èƒ½ï¼Œä¹Ÿéå¸¸ç¨³å®šï¼Œæ²¡æœ‰å‡ºç°æ–­è”ã€æ— é€Ÿåº¦ç­‰æƒ…å†µã€‚ 5. æ€»ç»“ç¯‡åç¡•TUF Gamingé“ ç”²æ˜¯ä¸€æ¬¾ä¼˜ç§€çš„ç§»åŠ¨ç¡¬ç›˜ç›’ï¼Œè™½ç„¶ä»·æ ¼ç•¥è´µï¼Œä½†å¯¹IP68+MIL-STD-810Hè®¤è¯çš„ä¸‰é˜²èƒ½åŠ›æœ‰è¦æ±‚çš„ç”¨æˆ·è€Œè¨€ç‰©è¶…æ‰€å€¼ï¼Œå³ä½¿åœ¨æ¶åŠ£å·¥å†µä¸‹ä¹Ÿèƒ½åšå›ºè€ç”¨ã€æŒä¹…ç¨³å®šï¼Œåœ¨ä¿è¯äº†æ•°æ®ä¼ è¾“æ€§èƒ½çš„åŒæ—¶ä¸ç”¨æ‹…å¿ƒæ•°æ®å®‰å…¨é—®é¢˜ã€‚","link":"/posts/5dcb1f53/"},{"title":"æ ¹æ®LLMå‚æ•°é‡ä¼°ç®—æ˜¾å­˜&#x2F;å†…å­˜å ç”¨","text":"âœ¨ Tipsï¼šæ–‡ä¸­â€œæ˜¾å­˜â€æŒ‡GPUå¯ä½¿ç”¨çš„å†…å­˜ç©ºé—´ï¼Œå¦‚æœ‰SoCä½¿ç”¨Unified Memory(å¦‚Apple M1~M3ç³»åˆ—ã€Nvidia AGX Orinç­‰)åˆ™å¯ç®€å•ç†è§£ä¸ºç³»ç»Ÿå†…å­˜ã€‚ æ¨ç†æ˜¾å­˜å¯¹äºä¸€ä¸ª70äº¿å‚æ•°ï¼ˆ7Bï¼‰çš„æ¨¡å‹ï¼Œä»¥ qwen2-7B ä¸ºä¾‹ï¼Œé¢„è®¡éœ€è¦çš„æ˜¾å­˜éœ€æ±‚å¦‚ä¸‹ï¼š FP32æµ®ç‚¹ç²¾åº¦ï¼š28GB BF16ç²¾åº¦ï¼š14GB int8ç²¾åº¦ï¼š7GB è™½ç„¶å…¶ä»–å› ç´ ä¹Ÿåœ¨å ç”¨æ˜¾å­˜ï¼Œä½†æ¨ç†æœŸé—´ä½¿ç”¨æ˜¾å­˜çš„ä¸»è¦æ˜¯å‚æ•°é‡ã€‚ æ¯”å¦‚ï¼Œqwen2-7B-BF16 æ¨¡å‹éœ€è¦çš„æ˜¾å­˜ç­‰äºå‚æ•°æ•°é‡ä¹˜ä»¥ç±»å‹å¤§å°ï¼š70äº¿å‚æ•° x 2å­—èŠ‚ = 140äº¿å­—èŠ‚ã€‚å› æ­¤ï¼Œ140äº¿å­—èŠ‚ = 14 x 1,000 x 1,000 x 1,000 / 1024 / 1024 / 1024 â‰ˆ 13 GBï¼ˆè€ƒè™‘1000/1024ï¼‰Â³ â‰ˆ 0.93ã€‚ æ³¨1ï¼š(1000/1024)Â³ â‰ˆ 0.93ï¼Œä¸ºäº†ä¼°ç®—ç›®çš„ï¼Œç®€å•åœ°å°†æ­¤æ¯”ç‡è§†ä¸º1ã€‚ æ³¨2ï¼šå¯¹äº7B-BF16æ¨¡å‹ï¼Œæ˜¾å­˜éœ€æ±‚å¤§çº¦æ˜¯7 x 2 = 14 GBã€‚ä¸Šè¿°ä¼°ç®—ç•¥é«˜äºç²¾ç¡®è®¡ç®—ï¼Œä½†æ›´å®ç”¨ï¼Œå› ä¸ºæ¨ç†éœ€è¦è¶…å‡ºå‚æ•°ä¹‹å¤–çš„é¢å¤–å†…å­˜ã€‚ å‡è®¾è¦ä¼°ç®—llama2-13Bæ¨¡å‹çš„æ˜¾å­˜éœ€æ±‚ï¼Œå¯¹åº”å„ç§ç±»å‹çš„åˆ†åˆ«æ˜¯ï¼šfloatï¼š13 x 4 = 52 GBï¼Œhalf/BF16ï¼š13 x 2 = 26 GBï¼Œint8ï¼š13 GBï¼Œint4ï¼š13 x 0.5 = 6.5 GB å¸¸ç”¨æ¨¡å‹å‚æ•°é‡-æ˜¾å­˜å ç”¨ä¼°è®¡ç»Ÿè®¡å¦‚ä¸‹è¡¨ï¼š ç²¾åº¦&æ˜¾å­˜å ç”¨é‡(ä¼°è®¡å€¼) ä¾‹å­(å®é™…å€¼) 32bit(FP32) 16bit(FP16/BF16) 8bit(int8) 4bit(int4) å‚æ•°é‡ 1 4byte 2byte 1byte 0.5byte 1B 4GB 2GB 1GB 0.5GB 2B 8GB 4GB 2GB 1GB Gemma_2B_4bit_1.4GB 7B 28GB 14GB 7GB 3.5GB Llama2_7B_4bit_3.8GB Mistral_7B_4bit_4.1GB 13B 52GB 26GB 13GB 6.5GB Llama2_13B_4bit_7.3GB 32B 128GB 64GB 32GB 16GB Qwen1.5_32B 32bit@120GB 16bit@60GB 4bit@15GB 70B 280GB 140GB 70GB 35GB Llama2_70B_4bit_39GB 130B 720GB 360GB 180GB 90GB Falcon_180B_16bit_360GB+ è®­ç»ƒæ˜¾å­˜ç”±äºåå‘ä¼ æ’­ã€Adamä¼˜åŒ–å’ŒTransformeræ¶æ„ç­‰å› ç´ ï¼Œä¿å®ˆä¼°è®¡ï¼Œè®­ç»ƒæ‰€éœ€çš„æ˜¾å­˜æ˜¯å…·æœ‰ç›¸åŒå‚æ•°æ•°é‡å’Œç±»å‹çš„æ¨ç†æ˜¾å­˜çš„å››å€ï¼ˆ1x ä¸ºæ¨¡å‹ï¼Œ1x ä¸ºæ¢¯åº¦ï¼Œ1~2x ä¸ºä¼˜åŒ–å™¨Â¹ï¼‰ã€‚ æ³¨1ï¼šä½¿ç”¨AdamWä¼˜åŒ–å™¨ï¼Œæ˜¾å­˜éœ€æ±‚ä¸º2xï¼›ä½¿ç”¨SGDä¼˜åŒ–å™¨ï¼Œæ˜¾å­˜éœ€æ±‚ä¸º1x ä¸ºäº†ç¡®ä¿è®­ç»ƒæœŸé—´æ¨¡å‹æ”¶æ•›ï¼Œå‚æ•°ç±»å‹ä¸€èˆ¬ä¸èƒ½æ˜¯int8æˆ–int4ã€‚é€šå¸¸ä½¿ç”¨FP32æˆ–é‡åŒ–åˆ°BF16ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨æµ®ç‚¹ç²¾åº¦FP32è®­ç»ƒä¸€ä¸ª7Bæ¨¡å‹å¤§çº¦éœ€è¦112GBï¼ˆ28GB x 4ï¼‰ã€‚ å‡è®¾è¦è®­ç»ƒQwen2-7Bæ¨¡å‹ï¼Œä¼°ç®—æ‰€éœ€çš„æ˜¾å­˜ï¼š å¯¹äºfloatç±»å‹ï¼š7ï¼ˆ10äº¿å‚æ•°ï¼‰x 4ï¼ˆfloatçš„å­—èŠ‚æ•°ï¼‰x 4 = 112 GB Adamä¼˜åŒ–å®é™…å ç”¨ä¸º109.8GB å¯¹äºhalf/BF16ç±»å‹å‚æ•°ï¼š7ï¼ˆ10äº¿å‚æ•°ï¼‰x 2ï¼ˆæ¯ä¸ªBF16å‚æ•°å­—èŠ‚æ•°ï¼‰x 4 = 56 GB Adamä¼˜åŒ–å®é™…å ç”¨ä¸º54.88GB å¯ä»¥çœ‹åˆ°ï¼Œä¼°ç®—çš„æ˜¾å­˜ä¸å®é™…æ˜¾å­˜å ç”¨ç›¸è¿‘ï¼Œå®é™…æƒ…å†µä¸­ä¸€èˆ¬éœ€è¦é¢„ç•™5%ä»¥ä¸Šçš„æ˜¾å­˜ç©ºé—´ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ï¼Œæ‰€ä»¥ä¼°ç®—å€¼ç•¥å¤§æ˜¯åˆç†çš„ã€‚ ä½¿ç”¨LoRA/QloRAæŠ€æœ¯çš„æ˜¾å­˜ä½¿ç”¨æƒ…å†µï¼Œä»¥LoRAä¸ºä¾‹ï¼š LoRAæ¶‰åŠåœ¨åŸå§‹æ¨¡å‹ä¸Šè¿è¡Œæ¨ç†å¹¶è®­ç»ƒä¸€ä¸ªè¾ƒå°çš„æ¨¡å‹ï¼Œä»¥å®ç°ä¸è®­ç»ƒåŸå§‹å‚æ•°å‡ ä¹ç›¸åŒçš„æ•ˆæœã€‚ ä¾‹å¦‚ï¼Œå¦‚æœéœ€è¦å¾®è°ƒå¤§å°ä¸º1024x512çš„å‚æ•°ï¼Œä½¿ç”¨LoRAå¹¶é€‰æ‹©Rankä¸º8ï¼Œåªéœ€è¦å¾®è°ƒä»¥ä¸‹æ•°é‡çš„å‚æ•°ï¼š1024x8 + 512x8ã€‚ è¿™ä¸ªè¿‡ç¨‹éœ€è¦ä½¿ç”¨åŸå§‹å‚æ•°é‡è¿è¡Œä¸€æ¬¡æ¨ç†ï¼ˆä¸éœ€è¦æ¢¯åº¦å’Œä¼˜åŒ–å™¨çŠ¶æ€ï¼‰ï¼Œä½†åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä»éœ€è¦ä¸€äº›æ˜¾å­˜æ¥å­˜å‚¨æ•°æ®ã€‚æ€»æ˜¾å­˜ä½¿ç”¨é‡æ˜¯è¿™äº›éœ€æ±‚çš„æ€»å’Œã€‚","link":"/posts/c87c0f5d/"},{"title":"è§£å†³hexoåšå®¢ä¸èƒ½æ˜¾ç¤ºå›¾åºŠå›¾ç‰‡é—®é¢˜","text":"åˆšæ­å»ºå¥½äº†hexoåšå®¢ï¼Œå†™äº†ä¸€ç¯‡å¸¦å›¾çš„æ–‡ç« ï¼Œç»“æœå‘ç°å›¾æŒ‚äº†â€¦ä¹‹å‰çœ‹åšå®¢æ‰«åˆ°hexoåšå®¢æ˜¾ç¤ºæœ¬åœ°å›¾ç‰‡å¯èƒ½ä¼šæœ‰é—®é¢˜ï¼Œäºæ˜¯é€‰äº†å›¾åºŠå›¾ç‰‡çš„æ–¹å¼æ’å›¾ï¼Œç»“æœè¿˜æ˜¯æ²¡èƒ½å¹¸å…ï¼Œå¥½åœ¨æœç´¢äº†åŠå¤©ï¼Œè§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œè¿™é‡Œåšä¸ªè®°å½•ï¼Œå¸®åŠ©åé¢é‡åˆ°é—®é¢˜çš„åŒå­¦ã€‚ è§£å†³æ–¹æ¡ˆï¼šé—®é¢˜æƒ…å¢ƒï¼šåœ¨è‡ªå·±ç”µè„‘çš„Chromeæµè§ˆå™¨æŸ¥çœ‹åšå®¢ï¼Œæ­£å¸¸æ˜¾ç¤ºå›¾ç‰‡ï¼Œåˆ‡æ¢åˆ°Safariã€ç«ç‹æµè§ˆå™¨å›¾ç‰‡æŒ‚äº†ã€‚ æ‰‹æœºç«¯å„æµè§ˆå™¨å‡æ˜¾ç¤ºä¸äº†å›¾ç‰‡ã€‚ è§£å†³æ­¥éª¤ï¼š åˆ†æ æ£€æŸ¥å›¾åºŠå›¾ç‰‡çš„é“¾æ¥ï¼š ç‚¹è¿›å»å‘ç°å›¾ç‰‡æ­£å¸¸æ˜¾ç¤ºï¼Œæ’é™¤å›¾åºŠæœåŠ¡å™¨é—®é¢˜ã€‚ ç”¨Chromeæ‰“å¼€åšæ–‡ï¼Œå³é”®æ£€æŸ¥æˆ–è€…æŸ¥çœ‹ç½‘é¡µæºç ï¼š æ‰¾åˆ°å›¾åºŠå›¾ç‰‡é“¾æ¥ï¼Œç‚¹å‡»å‘ç”Ÿ403(Forbidden)é”™è¯¯ï¼Œæ‰¾åˆ°é—®é¢˜æ ¹æºã€‚ è§£å†³ 403 forbiddenï¼Œè¯´æ˜äº†è¿™ä¸ªç½‘ç»œèµ„æºè¿™æ ·è·å–æ˜¯è¢«æ‹’ç»çš„ï¼Œé‚£ä¹ˆé€šè¿‡ç®€å•çš„è°·æ­Œï¼Œæ‰¾åˆ°äº†ç›¸å…³çš„è§£å†³æ–¹æ³•ï¼Œå¹¶å»å®é™…å°è¯•ï¼š è§£å†³æ–¹æ³• ï¼šåªéœ€è¦åœ¨markdownæ–‡ç« å¼€å¤´æ·»åŠ ä¸€ä¸ª&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; ç„¶åå°±æ˜¯hexo clean &amp;&amp; hexo g &amp;&amp; hexo dä¸Šä¼ åšå®¢äº†ï¼Œè¿™ä¸€æ¬¡åˆ†åˆ«åœ¨ç”µè„‘å’Œæ‰‹æœºç«¯æ‰“å¼€æ–‡ç« ï¼Œå›¾ç‰‡æ˜¾ç¤ºæ­£å¸¸ï¼Œé—®é¢˜è§£å†³ã€‚ åŸç†è§£æï¼šä¸ºäº†ä¸åšä¸€ä¸ªåªä¼šæ¬è¿çš„ç å†œï¼Œè¿™é‡Œç®€å•è®²è§£ä¸€ä¸‹åŸç†ï¼š HTMLçš„ æ ‡ç­¾æä¾›äº† HTML æ–‡æ¡£çš„å…ƒæ•°æ®ã€‚å…ƒæ•°æ®ä¸ä¼šæ˜¾ç¤ºåœ¨å®¢æˆ·ç«¯ï¼Œä½†æ˜¯ä¼šè¢«æµè§ˆå™¨è§£æã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆåŠ åœ¨mardownæ–‡ç« é‡Œä¸ä¼šçœ‹åˆ°è¿™æ®µä»£ç çš„åŸå› ã€‚ HTML çš„ name å±æ€§è§„å®šäº†å…ƒæ•°æ®çš„åç§°ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨åˆ°çš„æ˜¯refererå±æ€§ï¼Œè¿™ä¸ªå±æ€§çš„ä½œç”¨æ˜¯è®©æœåŠ¡å™¨åˆ¤æ–­æ¥æºé¡µé¢ï¼Œå³ç”¨æˆ·æ˜¯ä»å“ªæ¥çš„ï¼Œå¾ˆå¤šæ—¶å€™refererè¢«å½“åšé˜²ç›—é“¾æ¥ä½¿ç”¨ï¼ŒæœåŠ¡å™¨æ ¹æ®ä½ çš„è®¿é—®æ¥æºåˆ¤æ–­æ˜¯å¦åº”è¯¥è®©ä½ ä¸‹è½½è¿™ä¸ªèµ„æºï¼Œå¦‚æœä½ çš„æ¥æºä¸å’Œè§„èŒƒï¼Œæ¯”å¦‚æ˜¯ä¸ªæ¶æ„çˆ¬è™«ï¼Œé‚£ä¹ˆå°±ä¼šäº§ç”Ÿ403é”™è¯¯ã€‚ åˆ°è¿™é‡Œï¼Œcontent=&quot;no-referrer&quot;çš„æ„ä¹‰å°±å‘¼ä¹‹æ¬²å‡ºäº†ï¼Œæ—¢ç„¶æˆ‘ä»¬æƒ³æ‹¿åˆ°è¿™ä¸ªèµ„æºä½†è¢«æœåŠ¡å™¨è®¤å‡ºæ¥ä¹‹ååˆè¢«æ‹’ç»äº†ï¼Œé‚£ä¹ˆä¼ªè£…ä¸€ä¸‹ï¼Œä¸å‘Šè¯‰æœåŠ¡å™¨ä¸å°±è¡Œäº†ï¼Ÿæ‰€ä»¥ï¼Œè¿™é‡Œcontentçš„no-refererå°±æ˜¯è¡¨ç¤ºä¸å‘é€å¼•ç”¨æ•°æ®ï¼Œéšè—è‡ªå·±çš„æ¥æºä¿¡æ¯ã€‚è¿™æ ·ï¼Œå›¾ç‰‡å°±èƒ½æ­£å¸¸æ˜¾ç¤ºäº†ã€‚ å‚è€ƒ https://newsn.net/say/referer-policy.html Hexoä½¿ç”¨ç»†èŠ‚åŠå„ç§é—®é¢˜ - Selier - åšå®¢å›­","link":"/posts/9d5b9135/"},{"title":"æ‰‹æ„Ÿã€é¢œå€¼ã€æ€§èƒ½å…¼å…·ï¼ŸROGæœˆåˆƒAimPointæœˆè€€ç™½æ‹†è§£è¯„æµ‹","text":"è¿‘å¹´æ¥éšç€ä¼ æ„Ÿå™¨æŠ€æœ¯çš„é£é€Ÿå‘å±•ï¼Œé¼ æ ‡ä¼ æ„Ÿå™¨çš„æ‰«æç²¾åº¦DPIä»800,3200ä¸€è·¯é£™å‡ã€‚è¿™æ¬¡åç¡•ROGå‘å¸ƒçš„æœˆåˆƒæ— çº¿é¼ æ ‡æ­è½½äº†è‡ªç ”çš„AimPointæ——èˆ°ä¼ æ„Ÿå™¨ï¼ŒDPIè¾¾åˆ°äº†ææ€–çš„36000ï¼ŒåŠ é€Ÿåº¦å¯è¾¾50Gã€IPS æ›´æ˜¯é«˜è¾¾650ã€‚å¯èƒ½æœ‰å¾ˆå¤šäººä¸ç†è§£ï¼Œè¿™ä¹ˆé«˜çš„DPIæœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿæ²¡æœ‰äººçœŸçš„ä¼šç”¨è¿™ä¹ˆé«˜çš„DPIå·¥ä½œæˆ–è€…æ‰“æ¸¸æˆå§ï¼Ÿå…¶å®DPIä»£è¡¨çš„æ˜¯é¼ æ ‡æ¯ç§»åŠ¨1è‹±å¯¸æ—¶é¼ æ ‡æŒ‡é’ˆåœ¨æ˜¾ç¤ºå™¨ä¸Šç§»åŠ¨çš„åƒç´ ç‚¹ã€‚AimPointä¼ æ„Ÿå™¨çš„36000DPIï¼Œæ„å‘³ç€å…¶å¯ä»¥åœ¨ä¸€è‹±å¯¸çš„è·ç¦»å†…æ£€æµ‹åˆ°36000ä¸ªç‚¹çš„æ•°æ®ã€‚éšç€ä¼ æ„Ÿå™¨æ¥æ”¶åˆ°æ•°æ®æ ·æœ¬å®¹é‡çš„æå‡ï¼Œå…¶è¯»å–ç²¾åº¦å’Œè¯†åˆ«åˆ†è¾¨ç‡è¦æ¯”é‚£äº›ä½DPIä¸Šé™çš„é¼ æ ‡æ›´é«˜ã€‚ å°±æœ¬ä½“å‚æ•°è€Œè¨€ï¼Œå…¶é‡‡ç”¨ä¸ä¼šæ‰“æ²¹çš„PBTæè´¨æŒ‰é”®ã€çƒ­æ’æ‹”å¾®åŠ¨ã€75gçš„è½»é‡åŒ–è®¾è®¡ã€ç¬¬ä¸€æ¢¯é˜Ÿçš„ä¼ æ„Ÿå™¨ï¼Œæ¯«æ— ç–‘é—®è¿™æ˜¯ä¸€æ¬¾è¯šæ„æ»¡æ»¡çš„äº§å“ã€‚ å¯ä»¥çœ‹åˆ°ï¼ŒROGä¸ºæœˆåˆƒAimPointæä¾›äº†ä¸°å¯Œçš„é…ä»¶ã€‚åŒ…æ‹¬2.4Gæ¥æ”¶å™¨&amp;ä¼ç»³å……ç”µå»¶é•¿çº¿ã€3Pin æ¬§å§†é¾™ç°ç‚¹å¾®åŠ¨2ï¼ˆæ—¥äº§æ¬§å§†é¾™ï¼Œ1000ä¸‡æ¬¡ç‚¹å‡»å¯¿å‘½ï¼‰ã€PTFEç‰¹æ°Ÿé¾™è„šè´´4ã€æ©¡èƒ¶é˜²æ»‘è´´ã€ROGè´´çº¸ã€‚ å››æ¬¾é¼ æ ‡å¯¹æ¯”ï¼Œä»å·¦åˆ°å³åˆ†åˆ«æ˜¯ç½—æŠ€G903ã€GPWã€ROG æœˆåˆƒæœ‰çº¿ç‰ˆå’Œæœˆåˆƒæ— çº¿AimPointæœˆè€€ç™½ã€‚å…¶ä¸­ï¼ŒROGä¸¤æ¬¾é¼ æ ‡æ¨¡å…·åŸºæœ¬ç›¸åŒï¼Œæ‰‹æ„Ÿä¿æŒåœ¨ç›¸åŒæ°´å¹³ã€‚è¿™é‡Œç‰¹åˆ«è¡¨æ‰¬ä¸€ä¸‹ROGçš„ç»†èŠ‚å¤„ç†ï¼ŒPBTæŒ‰é”®å’Œé™„é€çš„æŒ‰é”®é˜²æ»‘è´´å¾ˆå¾—æˆ‘å¿ƒæ„ã€‚åœ¨æ¸¸æˆæ“ä½œä¸­ï¼ŒGPWé¼ æ ‡æŒ‰é”®çš„ABSæè´¨çš„ä¼šæ‰“æ²¹ï¼Œä½¿æˆ‘è¿«ä¸å¾—å·²è´´ä¸Šäº†æŒ‰é”®é˜²æ»‘è´´ï¼ˆèœ¥èœ´çš®ï¼‰ã€‚è¿™æ¬¡ROGå±…ç„¶ç›´æ¥é€ï¼Œç‚¹ä¸ªèµ è¯´ä¸€ä¸‹æ‰‹æ„Ÿä½“éªŒã€‚ä¹‹å‰æˆ‘æ˜¯GPWç”¨æˆ·ï¼Œç”±GPWæ¢ä¸ºæœˆåˆƒæ— çº¿AimPointä¹‹åç«Ÿç„¶æ²¡æœ‰æ„Ÿåˆ°ä¸é€‚ã€‚æ¯•ç«ŸGPWæ˜¯å·¦å³æ‰‹é€šç”¨é¼ æ ‡ï¼Œæœˆåˆƒæ— çº¿AimPointä¸ºå³æ‰‹ä¸“ç”¨ï¼Œæ¨¡å…·çš„ä¸åŒå¹¶æ²¡æœ‰ä¸ºæˆ‘å¸¦æ¥æ¸¸æˆæ“ä½œä¸Šæ¼«é•¿çš„é€‚åº”æœŸã€‚GPWä¸€ä»£é‡é‡ä¸º80å…‹ï¼ŒGPWäºŒä»£ä¸º63å…‹ï¼Œè¿™æ¬¾æœˆåˆƒæ— çº¿AimPointé¼ æ ‡é‡é‡åœ¨äºŒè€…ä¹‹é—´ï¼Œä¸º75å…‹ï¼ˆå®æµ‹å»é™¤æ¥æ”¶å™¨73å…‹ï¼‰ã€‚ä¸‹é¢æ˜¯ä¸¤é¼ æ ‡ä½¿ç”¨æ‰‹å‹å¯¹æ¯”ã€‚ ä¸‹é¢è¦ç‰¹åˆ«æä¸€ä¸ªå°ç»†èŠ‚ï¼Œå¯¹äºæ¸¸æˆç©å®¶æ¥è¯´ï¼Œæˆ‘ä»¬å¸Œæœ›æ— çº¿é¼ æ ‡å»¶è¿Ÿè¦è¶³å¤Ÿä½ï¼Œå¹¶ä¸”è¦é˜²æ­¢ä¸å¿…è¦çš„å¹²æ‰°ã€‚æ‰€ä»¥å¤§å®¶å¯èƒ½ä¼šæŠŠæ¥æ”¶å™¨ç”¨å»¶é•¿çº¿çš„å½¢å¼æ”¾ç½®äºæ¡Œé¢ã€‚ä½†æ˜¯è¿™æ ·å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œå»¶é•¿çº¿æ— æ³•åœ¨æ¡Œé¢ä¸Šå›ºå®šï¼Œæ¥æ”¶å™¨éšæ„æ‘†æ”¾éå¸¸ä¸ç¾è§‚ã€‚ROGçš„è®¾è®¡å¸ˆåŒæ ·è€ƒè™‘åˆ°è¿™ä¸€é—®é¢˜ï¼Œåœ¨æ¥æ”¶å™¨å»¶é•¿æ¨¡å—èƒŒé¢å®‰è£…äº†ä¸€ä¸ªé‡‘å±å¤¹ï¼Œå¯ä»¥è½»æ¾çš„å¤¹åˆ°é¼ æ ‡å«ä¸Šï¼Œé˜²æ­¢æ¥æ”¶å™¨åœ¨æ¡Œé¢ç§»åŠ¨ã€‚ æ¥æ”¶å™¨å›ºå®šåˆ°é¼ æ ‡å«ï¼Œç®€æ´ç¾è§‚ã€‚ å±•ç¤ºéƒ¨åˆ†å°±åˆ°è¿™é‡Œï¼Œä¸‹é¢æ¥åˆ°ä»Šå¤©çš„é‡å¤´æˆâ€”æ‹†è§£ã€‚ å°†é¼ æ ‡åº•éƒ¨ä¸¤ä¸ªç¡…èƒ¶å¡å–ä¸‹ï¼Œå¸ä¸‹ä¸¤é¢—åå­—èºä¸å³å¯æ‰“å¼€å¤–å£³ã€‚å¯ä»¥çœ‹åˆ°ï¼ŒROGçš„è®¾è®¡å¸ˆåœ¨è½»é‡åŒ–ä¸Šä¸‹äº†å¾ˆå¤§çš„åŠŸå¤«ã€‚é¼ æ ‡ä¸Šå£³åœ¨ä¿è¯å¼ºåº¦çš„åŒæ—¶é‡‡ç”¨èœ‚çªç»“æ„ï¼Œé™ä½é‡é‡ã€‚è€Œæ»šè½®æ”¯æ’‘éƒ¨åˆ†ä¹ŸåŒæ ·é‡‡ç”¨Zå­—å‹ç»“æ„ï¼Œå°½å¯èƒ½å°‘çš„ä½¿ç”¨ä¸å¿…è¦çš„å¡‘æ–™æè´¨ã€‚è€Œç”±äºè€ƒè™‘åˆ°ç©å®¶ä»¬ä¼šæ—¶å¸¸æ‹†è§£é¼ æ ‡æ›´æ¢å¾®åŠ¨ç­‰é…ä»¶ï¼ŒROGé‡‡ç”¨é¢„åŸ‹é“œæŸ±çš„æ–¹å¼é˜²æ­¢èºä¸æ»‘ä¸ï¼Œå±äºç»†èŠ‚æ‹‰æ»¡ã€‚ å…¶é‡‡ç”¨äº†ä¸€å—å®¹é‡ä¸º370mahçš„èšåˆç‰©é”‚ç”µæ± ï¼Œä¾›åº”å•†æ¥è‡ªæ­å·é‡‘è‰²èƒ½æºã€‚å®˜æ–¹æœ€å¤§ç»­èˆªæ—¶é—´ä¸ºè“ç‰™149å°æ—¶ï¼Œ2.4G 119å°æ—¶ã€‚ ROGè‡ªç ”å¾®åŠ¨ç‰¹å†™ï¼Œé‡‡ç”¨çº¢è‰²é€æ˜å¤–å£³è®¾è®¡ï¼Œå°æœ‰ROG logoã€‚å¯¿å‘½ä¸º70Mï¼ˆ7000ä¸‡æ¬¡ç‚¹å‡»ï¼‰ã€‚æ‰‹æ„Ÿæ¸…è„†ï¼Œä¸ªäººä½¿ç”¨ä½“éªŒæ„Ÿè§‰ç±»ä¼¼æ¬§å§†é¾™è“ç‚¹ï¼ˆä»…ä¾›å‚è€ƒï¼‰ã€‚å¾®åŠ¨æ”¯æŒæ’æ‹”æ›´æ¢ã€‚ è¯·æ³¨æ„ï¼Œæ™®é€šç©å®¶æ‹†è§£åˆ°ä¸Šé¢å°±å·²ç»å¯ä»¥æ»¡è¶³æ›´æ¢å¾®åŠ¨çš„éœ€æ±‚ï¼Œéä¸“ä¸šäººå‘˜ä¸å»ºè®®ç»§ç»­æ‹†è§£ï¼Œå¯èƒ½ä¼šé€ æˆæœªçŸ¥æŸå®³ã€‚ å¸ä¸‹ä¸»æ¿ï¼Œä¸»æ¿é‡‡ç”¨æ²‰é‡‘å·¥è‰ºä»¥å®ç°æ›´å¥½çš„ç”µæ°”è¿æ¥æ€§èƒ½ï¼Œä¸æ˜“æ°§åŒ–ï¼Œå¯ä»¥æå‡PCBç¨³å®šæ€§ï¼Œä¸­é—´çš„é•¿æ–¹å½¢èŠ¯ç‰‡å³ä¸ºAimPoint 36Kä¼ æ„Ÿå™¨ã€‚ä»ä¼ æ„Ÿå™¨çº¸é¢æ•°æ®å¯ä»¥çœ‹åˆ°ï¼Œåç¡•è¿™æšè‡ªç ”çš„AimPoint 36Kä¼ æ„Ÿå™¨æ— è®ºæ˜¯DPIè¿½è¸ªç²¾å‡†åº¦è¿˜æ˜¯DPIçš„åå·®å€¼éƒ½éå¸¸çš„ä¼˜ç§€ï¼Œç”šè‡³åœ¨36000DPIä¸‹åå·®å€¼åªæœ‰0.3%ï¼Œæ˜¯å½“ä¹‹æ— æ„§çš„æ——èˆ°ä¼ æ„Ÿå™¨ã€‚ é è¿‘ä¾§é”®å¾®åŠ¨çš„æ­£æ–¹å½¢èŠ¯ç‰‡ä¸ºæ¥è‡ªnordic semiçš„SoCï¼Œå‹å·ä¸ºnRF52840ã€‚nRF52840åŸºäºå¸¦æœ‰æµ®ç‚¹å•å…ƒçš„32ä½ARMÂ® Cortexâ„¢-M4 CPUï¼Œç‰‡å†…æ­è½½1 MB é—ªå­˜ + 256 KB RAMï¼Œä¸»é¢‘ä¸º64 MHzã€‚æ”¯æŒ2.4Gã€Bluetooth 5åŠè“ç‰™ä½åŠŸè€—(BLE)ï¼Œå¹¶é€šè¿‡ç²¾å¯†çš„ç‰‡ä¸Šè‡ªé€‚åº”ç”µæºç®¡ç†ç³»ç»Ÿï¼Œå®ç°äº†æä½çš„ç‰‡ä¸ŠåŠŸè€—ï¼Œå¯ä»¥æœ‰æ•ˆæå‡é¼ æ ‡ç»­èˆªã€‚ç‰¹åˆ«çš„ï¼ŒèŠ¯ç‰‡å†…éƒ¨æ­è½½äº†åç¡•è¿™æ¬¡å…¨æ–°å‡çº§çš„SpeedNovaæ— çº¿é€šä¿¡åè®®ï¼Œé’ˆå¯¹ä½å»¶è¿Ÿä¼˜åŒ–ã€‚ PCBèƒŒé¢ï¼Œå¯ä»¥çœ‹åˆ°AimPoint 36Kä¼ æ„Ÿå™¨èƒŒé¢ã€æ¨¡å¼åˆ‡æ¢å¼€å…³åŠDPIå’Œè“ç‰™é…å¯¹å¼€å…³ã€‚ åº•éƒ¨çš„å¾®åŠ¨PCBå°æ¿é‡‡ç”¨12pinæ’åº§çš„å½¢å¼ä¸ä¸»æ¿è¿æ¥ï¼Œæ­è½½å¾®åŠ¨æ’æ‹”åº§åŠtype-cæ¥å£ã€‚ä¸éš¾çœ‹åˆ°ï¼Œé¼ æ ‡åº•å£³ä¹Ÿé‡‡ç”¨äº†è¾ƒå¤šåŠ å¼ºç­‹çš„å½¢å¼ï¼Œåœ¨é™ä½å¤–å£³åšåº¦çš„åŒæ—¶æå‡å¼ºåº¦ã€‚ æ‹†è§£å®Œæˆï¼Œå¯¹é¼ æ ‡å†…éƒ¨ç›¸å…³å…ƒä»¶è¿›è¡Œç§°é‡ã€‚é¼ æ ‡åº•å£³16gï¼›é¼ æ ‡ä¸Šç›–27gï¼›æ»šè½®2gï¼›é»‘è‰²ç”µæ± æ¶2gï¼›ç”µæ± 7gï¼›ä¸»æ¿+èƒŒé¢æŒ‰é”®16gï¼›å¾®åŠ¨0.5gï¼ˆä¸¤æšå…±1gï¼‰ï¼›èºä¸&amp;ç¡…èƒ¶å¡2gã€‚å…±è®¡73å…‹ã€‚å¯¹äºæè‡´å‡é‡ç©å®¶ï¼Œä¸æ›´æ”¹ä¸Šç›–ä¸åº•å£³çš„å‰æä¸‹ï¼Œå»æ‰ç”µæ± æ¶åŠèºä¸ç¡…èƒ¶å¡ï¼Œè¿™æ¬¾é¼ æ ‡æœ€è½»å¯ä»¥é™åˆ°69gã€‚ ROGè™½ç„¶åœ¨ç¡¬ä»¶åœˆå­é‡Œæ˜¯è´¥å®¶ä¹‹çœ¼ï¼Œä½†æ˜¯åœ¨å¤–è®¾åœˆå­é‡Œï¼ŒROGçœŸçš„æ˜¯åå‰¯å…¶å®çš„å·ç‹ã€‚ä¸ä»…æ¨æ–°é€Ÿåº¦æå¿«ï¼Œæ€§ä»·æ¯”ä¹Ÿéå¸¸çš„é«˜ï¼Œé’ˆå¯¹ç©å®¶èµ é€çš„é…ä»¶åŒæ ·ååˆ†é½å…¨ï¼Œè®©ä½ ä¸å†éœ€è¦è´­ä¹°é¼ æ ‡åè¿˜éœ€è¦åœ¨è„šå«ã€è´´çº¸ä¸ŠèŠ±è´¹é¢å¤–çš„å¿ƒæ€ï¼ˆæ¯•ç«Ÿå•ä¹°ä¸€å¥—é«˜ç«¯ç‰¹æ°Ÿé¾™è„šè´´ä¹Ÿè¦äºŒä¸‰åï¼Œèœ¥èœ´çš®é˜²æ»‘è´´ä¹Ÿéœ€äºŒä¸‰åï¼‰ã€‚ æ€»çš„æ¥çœ‹ï¼ŒROGæœˆåˆƒæ— çº¿AimPointé¼ æ ‡åœ¨æ²¿ç”¨äº†ROGé¼ æ ‡å¤–è§‚è®¾è®¡çš„åŸºç¡€ä¸Šï¼ŒåŠ å…¥äº†AimPoint 36Kå…‰å­¦ä¼ æ„Ÿå™¨ï¼Œè®©è¿™æ¬¾é¼ æ ‡æ‹¥æœ‰æ›´é«˜çš„é…ç½®ï¼›å€ŸåŠ©å¥¥åˆ›è½¯ä»¶ï¼Œç”¨æˆ·è¿˜èƒ½å¯¹é¼ æ ‡è¿›è¡Œè‡ªå®šä¹‰è®¾ç½®ï¼›è½»é‡åŒ–ä»¥åŠç¬¦åˆäººä½“å·¥å­¦çš„è®¾è®¡ï¼Œåˆ™è®©å…¶æ“ä½œèµ·æ¥æ›´ä¸ºèˆ’é€‚ï¼Œä»¥å¾€çš„GPWç©å®¶ä¹Ÿå¯ä»¥è½»æ¾ä¸Šæ‰‹ã€‚å¯¹ç”µç«ç©å®¶è€Œè¨€ï¼Œæ‰‹æ„Ÿã€é¢œå€¼ã€æ€§èƒ½å…¼å…·ï¼Œè¿™çš„ç¡®æ˜¯ä¸€æ¬¾å€¼å¾—å…¥æ‰‹çš„æ¸¸æˆé¼ æ ‡ã€‚","link":"/posts/21f2167c/"},{"title":"é«˜é€Ÿä¸‹è½½ HuggingFaceå¤§æ¨¡å‹ï¼ˆæ”¯æŒæ–­ç‚¹ç»­ä¼ ã€å¤šçº¿ç¨‹ï¼‰","text":"ç‰¹æ€§ â¯ï¸ ä»æ–­ç‚¹æ¢å¤ï¼šå¯éšæ—¶é‡æ–°è¿è¡Œæˆ–æŒ‰ Ctrl+C ï¼Œå†æ¬¡æ‰§è¡Œè„šæœ¬æ—¶ä¸‹è½½æ¢å¤åˆ°æ–­ç‚¹çŠ¶æ€ã€‚ ğŸš€ å¤šçº¿ç¨‹ä¸‹è½½ï¼šåˆ©ç”¨å¤šçº¿ç¨‹åŠ å¿«ä¸‹è½½è¿›ç¨‹ã€‚ ğŸ“¦ è½»é‡åŒ–ï¼šä»…ä¾èµ–git , aria2c/wget ã€‚ åŸºæœ¬å‘½ä»¤ï¼š1./hf-downloader.sh *HF_Repo_ID* --tool aria2c -x 16 å¦‚æœæ²¡æœ‰å®‰è£…æˆ–æ¡ä»¶ä¸å…è®¸å®‰è£… Aria2 ï¼Œåˆ™å¯ä»¥åˆ‡æ¢åˆ°ç”¨ wgetï¼ˆä¸æ”¯æŒå¤šçº¿ç¨‹ï¼‰ï¼š 1./hf-downloader.sh *HF_Repo_ID* --tool wget ä½¿ç”¨æ–¹æ³•ï¼šå®Œæ•´æ‹·è´ æ–‡æœ«ä»£ç  åˆ°hf-downloader.sh,èµ‹æƒï¼š 1chmod a+x hf-downloader.sh è®¾ç½®é•œåƒç«¯ç‚¹çš„ç¯å¢ƒå˜é‡ï¼Œæˆ–ç›´æ¥å°†å…¶åŠ å…¥bashæ–‡ä»¶ä¸­ï¼š 1export HF_ENDPOINT=&quot;https://hf-mirror.com&quot; æ­£å¸¸æ‰§è¡Œè„šæœ¬å³å¯ã€‚ä¾‹ï¼š 1./hf-downloader.sh Qwen/Qwen2-7B-Instruct --tool aria2c -x 16 å¤‡æ³¨ï¼š å‚æ•°-xæ˜¯ aria2 çš„çº¿ç¨‹æ•°é‡ï¼Œé»˜è®¤ä¸º4ï¼Œæœ€å¤§ä¸º16ã€‚ å¦‚æœæ¨¡å‹ä¸‹è½½éœ€è¦ç™»å½•HFè´¦å·ï¼Œéœ€å…ˆè·å– huggingface token ,ç„¶åä¸‹æ–¹å¡«å†™ç”¨æˆ·åå’Œtokenï¼Œå¦‚ï¼š 1./hf-downloader.sh Qwen/Qwen2-7B-Instruct --hf_username YOUR_HF_USERNAME(NOT_EMAIL) --hf_token YOUR_HF_TOKEN ä¸‹è½½æ¨¡å‹æ—¶æ’é™¤æŸäº›æ–‡ä»¶ï¼ˆå¦‚.safetensorsï¼‰ï¼š 1./hf-downloader.sh Qwen/Qwen2-7B-Instruct --exclude *.safetensors huggingface-downloader è„šæœ¬ä»£ç :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#!/usr/bin/env bash# Color definitionsRED='\\033[0;31m'GREEN='\\033[0;32m'YELLOW='\\033[1;33m'NC='\\033[0m' # No Colortrap 'printf &quot;${YELLOW}\\nDownload interrupted. If you re-run the command, you can resume the download from the breakpoint.\\n${NC}&quot;; exit 1' INTdisplay_help() { cat &lt;&lt; EOFUsage: hfd &lt;repo_id&gt; [--include include_pattern1 include_pattern2 ...] [--exclude exclude_pattern1 exclude_pattern2 ...] [--hf_username username] [--hf_token token] [--tool aria2c|wget] [-x threads] [--dataset] [--local-dir path] Description: Downloads a model or dataset from Hugging Face using the provided repo ID.Parameters: repo_id The Hugging Face repo ID in the format 'org/repo_name'. --include (Optional) Flag to specify string patterns to include files for downloading. Supports multiple patterns. --exclude (Optional) Flag to specify string patterns to exclude files from downloading. Supports multiple patterns. include/exclude_pattern The patterns to match against filenames, supports wildcard characters. e.g., '--exclude *.safetensor *.txt', '--include vae/*'. --hf_username (Optional) Hugging Face username for authentication. **NOT EMAIL**. --hf_token (Optional) Hugging Face token for authentication. --tool (Optional) Download tool to use. Can be aria2c (default) or wget. -x (Optional) Number of download threads for aria2c. Defaults to 4. --dataset (Optional) Flag to indicate downloading a dataset. --local-dir (Optional) Local directory path where the model or dataset will be stored.Example: hfd bigscience/bloom-560m --exclude *.safetensors hfd meta-llama/Llama-2-7b --hf_username myuser --hf_token mytoken -x 4 hfd lavita/medical-qa-shared-task-v1-toy --datasetEOF exit 1}MODEL_ID=$1shift# Default valuesTOOL=&quot;aria2c&quot;THREADS=4HF_ENDPOINT=${HF_ENDPOINT:-&quot;https://huggingface.co&quot;}INCLUDE_PATTERNS=()EXCLUDE_PATTERNS=()while [[ $# -gt 0 ]]; do case $1 in --include) shift while [[ $# -gt 0 &amp;&amp; ! $1 =~ ^-- ]]; do INCLUDE_PATTERNS+=(&quot;$1&quot;) shift done ;; --exclude) shift while [[ $# -gt 0 &amp;&amp; ! $1 =~ ^-- ]]; do EXCLUDE_PATTERNS+=(&quot;$1&quot;) shift done ;; --hf_username) HF_USERNAME=&quot;$2&quot;; shift 2 ;; --hf_token) HF_TOKEN=&quot;$2&quot;; shift 2 ;; --tool) TOOL=&quot;$2&quot;; shift 2 ;; -x) THREADS=&quot;$2&quot;; shift 2 ;; --dataset) DATASET=1; shift ;; --local-dir) LOCAL_DIR=&quot;$2&quot;; shift 2 ;; *) shift ;; esacdone# Check if aria2, wget, curl, git, and git-lfs are installedcheck_command() { if ! command -v $1 &amp;&gt;/dev/null; then echo -e &quot;${RED}$1 is not installed. Please install it first.${NC}&quot; exit 1 fi}# Mark current repo safe when using shared file system like samba or nfsensure_ownership() { if git status 2&gt;&amp;1 | grep &quot;fatal: detected dubious ownership in repository at&quot; &gt; /dev/null; then git config --global --add safe.directory &quot;${PWD}&quot; printf &quot;${YELLOW}Detected dubious ownership in repository, mark ${PWD} safe using git, edit ~/.gitconfig if you want to reverse this.\\n${NC}&quot; fi}[[ &quot;$TOOL&quot; == &quot;aria2c&quot; ]] &amp;&amp; check_command aria2c[[ &quot;$TOOL&quot; == &quot;wget&quot; ]] &amp;&amp; check_command wgetcheck_command curl; check_command git; check_command git-lfs[[ -z &quot;$MODEL_ID&quot; || &quot;$MODEL_ID&quot; =~ ^-h ]] &amp;&amp; display_helpif [[ -z &quot;$LOCAL_DIR&quot; ]]; then LOCAL_DIR=&quot;${MODEL_ID#*/}&quot;fiif [[ &quot;$DATASET&quot; == 1 ]]; then MODEL_ID=&quot;datasets/$MODEL_ID&quot;fiecho &quot;Downloading to $LOCAL_DIR&quot;if [ -d &quot;$LOCAL_DIR/.git&quot; ]; then printf &quot;${YELLOW}%s exists, Skip Clone.\\n${NC}&quot; &quot;$LOCAL_DIR&quot; cd &quot;$LOCAL_DIR&quot; &amp;&amp; ensure_ownership &amp;&amp; GIT_LFS_SKIP_SMUDGE=1 git pull || { printf &quot;${RED}Git pull failed.${NC}\\n&quot;; exit 1; }else REPO_URL=&quot;$HF_ENDPOINT/$MODEL_ID&quot; GIT_REFS_URL=&quot;${REPO_URL}/info/refs?service=git-upload-pack&quot; echo &quot;Testing GIT_REFS_URL: $GIT_REFS_URL&quot; response=$(curl -s -o /dev/null -w &quot;%{http_code}&quot; &quot;$GIT_REFS_URL&quot;) if [ &quot;$response&quot; == &quot;401&quot; ] || [ &quot;$response&quot; == &quot;403&quot; ]; then if [[ -z &quot;$HF_USERNAME&quot; || -z &quot;$HF_TOKEN&quot; ]]; then printf &quot;${RED}HTTP Status Code: $response.\\nThe repository requires authentication, but --hf_username and --hf_token is not passed. Please get token from https://huggingface.co/settings/tokens.\\nExiting.\\n${NC}&quot; exit 1 fi REPO_URL=&quot;https://$HF_USERNAME:$HF_TOKEN@${HF_ENDPOINT#https://}/$MODEL_ID&quot; elif [ &quot;$response&quot; != &quot;200&quot; ]; then printf &quot;${RED}Unexpected HTTP Status Code: $response\\n${NC}&quot; printf &quot;${YELLOW}Executing debug command: curl -v %s\\nOutput:${NC}\\n&quot; &quot;$GIT_REFS_URL&quot; curl -v &quot;$GIT_REFS_URL&quot;; printf &quot;\\n${RED}Git clone failed.\\n${NC}&quot;; exit 1 fi echo &quot;GIT_LFS_SKIP_SMUDGE=1 git clone $REPO_URL $LOCAL_DIR&quot; GIT_LFS_SKIP_SMUDGE=1 git clone $REPO_URL $LOCAL_DIR &amp;&amp; cd &quot;$LOCAL_DIR&quot; || { printf &quot;${RED}Git clone failed.\\n${NC}&quot;; exit 1; } ensure_ownership while IFS= read -r file; do truncate -s 0 &quot;$file&quot; done &lt;&lt;&lt; $(git lfs ls-files | cut -d ' ' -f 3-)fiprintf &quot;\\nStart Downloading lfs files, bash script:\\ncd $LOCAL_DIR\\n&quot;files=$(git lfs ls-files | cut -d ' ' -f 3-)declare -a urlsfile_matches_include_patterns() { local file=&quot;$1&quot; for pattern in &quot;${INCLUDE_PATTERNS[@]}&quot;; do if [[ &quot;$file&quot; == $pattern ]]; then return 0 fi done return 1}file_matches_exclude_patterns() { local file=&quot;$1&quot; for pattern in &quot;${EXCLUDE_PATTERNS[@]}&quot;; do if [[ &quot;$file&quot; == $pattern ]]; then return 0 fi done return 1}while IFS= read -r file; do url=&quot;$HF_ENDPOINT/$MODEL_ID/resolve/main/$file&quot; file_dir=$(dirname &quot;$file&quot;) mkdir -p &quot;$file_dir&quot; if [[ &quot;$TOOL&quot; == &quot;wget&quot; ]]; then download_cmd=&quot;wget -c \\&quot;$url\\&quot; -O \\&quot;$file\\&quot;&quot; [[ -n &quot;$HF_TOKEN&quot; ]] &amp;&amp; download_cmd=&quot;wget --header=\\&quot;Authorization: Bearer ${HF_TOKEN}\\&quot; -c \\&quot;$url\\&quot; -O \\&quot;$file\\&quot;&quot; else download_cmd=&quot;aria2c --console-log-level=error --file-allocation=none -x $THREADS -s $THREADS -k 1M -c \\&quot;$url\\&quot; -d \\&quot;$file_dir\\&quot; -o \\&quot;$(basename &quot;$file&quot;)\\&quot;&quot; [[ -n &quot;$HF_TOKEN&quot; ]] &amp;&amp; download_cmd=&quot;aria2c --header=\\&quot;Authorization: Bearer ${HF_TOKEN}\\&quot; --console-log-level=error --file-allocation=none -x $THREADS -s $THREADS -k 1M -c \\&quot;$url\\&quot; -d \\&quot;$file_dir\\&quot; -o \\&quot;$(basename &quot;$file&quot;)\\&quot;&quot; fi if [[ ${#INCLUDE_PATTERNS[@]} -gt 0 ]]; then file_matches_include_patterns &quot;$file&quot; || { printf &quot;# %s\\n&quot; &quot;$download_cmd&quot;; continue; } fi if [[ ${#EXCLUDE_PATTERNS[@]} -gt 0 ]]; then file_matches_exclude_patterns &quot;$file&quot; &amp;&amp; { printf &quot;# %s\\n&quot; &quot;$download_cmd&quot;; continue; } fi printf &quot;%s\\n&quot; &quot;$download_cmd&quot; urls+=(&quot;$url|$file&quot;)done &lt;&lt;&lt; &quot;$files&quot;for url_file in &quot;${urls[@]}&quot;; do IFS='|' read -r url file &lt;&lt;&lt; &quot;$url_file&quot; printf &quot;${YELLOW}Start downloading ${file}.\\n${NC}&quot; file_dir=$(dirname &quot;$file&quot;) if [[ &quot;$TOOL&quot; == &quot;wget&quot; ]]; then [[ -n &quot;$HF_TOKEN&quot; ]] &amp;&amp; wget --header=&quot;Authorization: Bearer ${HF_TOKEN}&quot; -c &quot;$url&quot; -O &quot;$file&quot; || wget -c &quot;$url&quot; -O &quot;$file&quot; else [[ -n &quot;$HF_TOKEN&quot; ]] &amp;&amp; aria2c --header=&quot;Authorization: Bearer ${HF_TOKEN}&quot; --console-log-level=error --file-allocation=none -x $THREADS -s $THREADS -k 1M -c &quot;$url&quot; -d &quot;$file_dir&quot; -o &quot;$(basename &quot;$file&quot;)&quot; || aria2c --console-log-level=error --file-allocation=none -x $THREADS -s $THREADS -k 1M -c &quot;$url&quot; -d &quot;$file_dir&quot; -o &quot;$(basename &quot;$file&quot;)&quot; fi [[ $? -eq 0 ]] &amp;&amp; printf &quot;Downloaded %s successfully.\\n&quot; &quot;$url&quot; || { printf &quot;${RED}Failed to download %s.\\n${NC}&quot; &quot;$url&quot;; exit 1; }doneprintf &quot;${GREEN}Download completed successfully.\\n${NC}&quot; Refï¼šhttps://gist.github.com/padeoe/697678ab8e528b85a2a7bddafea1fa4f#file-hfd-sh-L1","link":"/posts/20d2b052/"},{"title":"ONNXç®—å­ç®€ä»‹","text":"è¯¦ç»†è‹±æ–‡ä»‹ç»è§ONNXç®—å­ ï¼ˆç®—å­è¾ƒå¤šï¼Œå–„ç”¨Ctrl+FæŸ¥æ‰¾ï¼‰ åºå· ç®—å­ å«ä¹‰ å‚æ•° 1 Abs æ±‚ç»å¯¹å€¼ ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘**outputï¼šè¾“å‡ºTensor 2 Acos åä½™å¼¦ ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œæ•°å€¼èŒƒå›´[-1, 1]ï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘**outputï¼šè¾“å‡ºTensorï¼Œæ•°å€¼èŒƒå›´[0, pi]ï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 3 Add äºŒå…ƒç‚¹åŠ  ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œç¬¬1ä¸ªæ“ä½œæ•°- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œç¬¬2ä¸ªæ“ä½œæ•°ã€çº¦æŸã€‘æ”¯æŒä¸¤ç»„è¾“å…¥çš„ç»´åº¦ä¸ä¸€è‡´ï¼Œè¿›è¡Œå¹¿æ’­æ“ä½œï¼ˆå¹¿æ’­å³ç»´åº¦è¡¥é½ï¼‰ï¼Œç›®å‰æ”¯æŒä»¥ä¸‹å‡ ç§å¹¿æ’­åœºæ™¯ï¼š- NCHW+NCHW(å¤‡æ³¨, ä¸¤ä¸ªç»´åº¦ç›¸åŒtensor)- NCHW+scalar- NCHW+W, CHW+W, HW+W(å¤‡æ³¨, Wç»´åº¦åšbroadcast)- NCHW + NCH1, CHW + CH1, HW + H1- CHW + C1W(å¤‡æ³¨ï¼ŒHç»´åº¦åšbroadcast)å¯¹äºä¸¤ä¸ªè¾“å…¥ç»´åº¦ä¸ªæ•°ä¸ç›¸åŒçš„åœºæ™¯ï¼Œéœ€è¦å°†ç»´åº¦è¡¥é½åˆ°å››ç»´ã€‚ä¾‹å¦‚ï¼Œx.shape=(1, 5, 6, 7) å’Œ y.shape=(6, 7)éœ€è¦å°†yçš„ç»´åº¦è¡¥é½åˆ°4ç»´ï¼Œå³y.shape=(1, 1, 6, 7)ã€‚è¯´æ˜ï¼šä¸¤ä¸ªTensorçš„è¾“å…¥é¡ºåºå¯ä»¥äº’æ¢ã€‚ã€è¾“å‡ºã€‘Cï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒB 4 And å–ä¸è¿ç®— ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šbool- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šboolã€çº¦æŸã€‘inputè¾“å…¥ä¸æ”¯æŒNCHWæ ¼å¼æ•°æ®ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šbool 5 ArgMax åœ¨æŒ‡å®šè½´ä¸Šæ‰¾åˆ°æœ€å¤§å€¼ç´¢å¼• ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- axisï¼šintï¼Œdefaultå€¼ä¸º0ï¼Œå–å€¼èŒƒå›´[-r, r-1]ï¼Œr = rank(data)- keepdimsï¼šintï¼Œdefaultå€¼ä¸º1ã€è¾“å‡ºã€‘**outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šint64 6 Asin åæ­£å¼¦ ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œæ•°å€¼èŒƒå›´[-1, 1]ï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œæ•°å€¼èŒƒå›´[-pi/2, pi/2]ï¼Œç±»å‹ä¸inputè¾“å…¥ç›¸åŒ 7 Atan åæ­£åˆ‡ ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸inputè¾“å…¥ç›¸åŒ 8 AveragePool å¹³å‡æ± åŒ– ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- auto_padï¼šoptional, stringï¼Œpadçš„è®¡ç®—æ¨¡å¼ï¼Œé»˜è®¤æ˜¯NOTSET- ceil_modeï¼šoptional, intï¼Œä½¿ç”¨ceilï¼ˆå‘ä¸Šå–æ•´ï¼‰è¿˜æ˜¯floorï¼ˆå‘ä¸‹å–æ•´ï¼‰è®¡ç®—è¾“å‡ºç»´åº¦ï¼Œé»˜è®¤æ˜¯0ï¼ˆceilï¼‰- count_include_padï¼šoptionalï¼Œintï¼Œè®¡ç®—è¾¹ç¼˜æ—¶æ˜¯å¦åŒ…å«padï¼Œé»˜è®¤æ˜¯0ï¼Œä¸åŒ…å«pad- kernel_shapeï¼šlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„çª—å£å¤§å°- padsï¼šlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„padå€¼ï¼Œé»˜è®¤å€¼ä¸º0- stridesï¼šlist of intsï¼Œå…¶ä¸­æ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„æ»‘åŠ¨æ­¥é•¿ï¼Œé»˜è®¤å€¼ä¸º1ã€çº¦æŸã€‘- auto_padå‚æ•°ä¸æ”¯æŒSAME_UPPERï¼ŒSAME_LOWER- count_include_padå‚æ•°åªæ”¯æŒé»˜è®¤å€¼ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸Xè¾“å…¥ç›¸åŒ 9 BatchNormalization å¯¹è¾“å…¥åšæ ‡å‡†åŒ– ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- scaleï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œç”¨äºç¼©æ”¾- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œåå·®- meanï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œç”¨äºæ¨ç†æ€»ä½“å‡å€¼- varï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œç”¨äºæ¨ç†æ€»ä½“æ–¹å·®- training_modeï¼šè¾“å…¥Tensorï¼Œoptionalï¼Œè®­ç»ƒæ¨¡å¼ã€å‚æ•°ã€‘- epsilonï¼šfloat32ï¼Œåœ¨Xçš„æ–¹å·®ä¸­æ·»åŠ çš„ä¸€ä¸ªå°çš„æµ®ç‚¹æ•°ï¼Œé»˜è®¤å€¼æ˜¯1e-05- momentumï¼šfloat32ï¼Œè®¡ç®—meanå’Œvarçš„å› å­ï¼Œé»˜è®¤å€¼ä¸º0.9- spatialï¼šintï¼Œè®¡ç®—meanå’Œvarçš„æ–¹å¼ï¼Œé»˜è®¤å€¼1ã€çº¦æŸã€‘- ä¸æ”¯æŒè®­ç»ƒåœºæ™¯- ä¸æ”¯æŒtraining_modeè¾“å…¥- ä¸æ”¯æŒoutput_meanã€output_varã€saved_meanã€saved_varè¾“å‡º- opset7ä¸­ä¸æ”¯æŒspatialè®¾ç½®ã€è¾“å‡ºã€‘- Yï¼šè¾“å‡ºTensorï¼Œå’ŒXè¾“å…¥æœ‰ç›¸åŒçš„ç»´åº¦- output_meanï¼šè®­ç»ƒæ¨¡å¼ä¸‹æ˜¯æ»‘åŠ¨å‡å€¼ï¼Œéè®­ç»ƒæ¨¡å¼ä¸‹æ˜¯ä¼°è®¡å‡å€¼- output_varï¼šè®­ç»ƒæ¨¡å¼ä¸‹æ˜¯æ»‘åŠ¨æ–¹å·®ï¼Œéè®­ç»ƒæ¨¡å¼ä¸‹æ˜¯ä¼°è®¡æ–¹å·®- saved_meanï¼šå·²ä¿å­˜çš„å‡å€¼- saved_varï¼šå·²ä¿å­˜çš„å‡å€¼ 10 Cast æ•°æ®ç±»å‹è½¬æ¢ ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œboolï¼Œint32ï¼Œuint8ã€å‚æ•°ã€‘toï¼šæ•°æ®ç±»å‹int- FLOAT = 1- UINT8 = 2- INT8 = 3- UINT16 = 4- INT16 = 5- INT32 = 6- INT64 = 7- STRING = 8- BOOL = 9- FLOAT16 = 10- DOUBLE = 11- UINT32 = 12ã€çº¦æŸã€‘æ”¯æŒä¸‹é¢ç±»å‹è½¬æ¢ï¼š- fp16 -&gt; fp32- fp32 -&gt; fp16- u8 -&gt; fp16- fp16 -&gt; u8- int32 -&gt; fp32- fp32-&gt;int32- fp16 -&gt; int8- int8 -&gt; fp16- in32 -&gt; fp16- fp16 -&gt; int32- bool -&gt; fp16- fp16 -&gt; boolã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensor 11 Ceil å‘ä¸Šå–å€¼ ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸inputè¾“å…¥ç›¸åŒ 12 Clip å°†è¾“å…¥é™åˆ¶åœ¨ä¸€ä¸ªåŒºé—´ä¸­ ã€è¾“å…¥ã€‘- inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- minï¼šScalar Tensorï¼Œoptionalï¼Œç±»å‹ï¼šfloat32ï¼ŒåŒºé—´æœ€å°å€¼- maxï¼šScalar Tensorï¼Œoptionalï¼Œç±»å‹ï¼šfloat32ï¼ŒåŒºé—´æœ€å¤§å€¼ã€å‚æ•°ã€‘åœ¨opset 7~10ä¸­minå’Œmaxæ˜¯å‚æ•°ã€çº¦æŸã€‘- minè¾“å…¥å¿…é¡»æ˜¯å¸¸é‡- maxè¾“å…¥å¿…é¡»æ˜¯å¸¸é‡ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸inputè¾“å…¥ç›¸åŒ 13 Concat æ•°æ®æŒ‰ç»´åº¦æ‹¼æ¥ ã€è¾“å…¥ã€‘- inputsï¼šList of tensorsï¼Œç±»å‹ï¼šfloat32ï¼Œint32ã€å‚æ•°ã€‘- axisï¼šintï¼Œè½´å‚æ•°ï¼Œæ§åˆ¶éœ€è¦æ‹¼æ¥çš„æ•°æ®è½´ï¼Œè´Ÿå€¼è¡¨ç¤ºä»ç»´åº¦æœ€åä¸€ä½å¾€å‰æ•°ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘concat_resultï¼šæ‹¼æ¥ä¹‹åçš„Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint32 14 Constant è¾“å‡º1ä¸ªå¸¸é‡Tensor ã€è¾“å…¥ã€‘æ— ã€å‚æ•°ã€‘- sparse_valueï¼šç¨€ç–ç±»å‹çš„è¾“å‡ºå€¼- valueï¼šTensorï¼Œè¾“å‡ºTensorçš„å€¼- value_floatï¼šfloat32ç±»å‹çš„æ ‡é‡è¾“å‡ºTensorçš„å€¼- value_floatsï¼šlist of floatsï¼Œfloat32ç±»å‹çš„1Dè¾“å‡ºTensorçš„å€¼- value_intï¼šintï¼Œint32ç±»å‹çš„æ ‡é‡è¾“å‡ºTensorçš„å€¼- value_intsï¼šlist of intsï¼Œint32ç±»å‹çš„1Dè¾“å‡ºTensorçš„å€¼- value_stringï¼šstringï¼Œstringç±»å‹çš„æ ‡é‡UTF-8è¾“å‡ºTensorçš„å€¼- value_stringsï¼šlist of stringsï¼Œstringç±»å‹çš„1D UTF-8è¾“å‡ºTensorçš„å€¼ã€çº¦æŸã€‘- ä¸æ”¯æŒsparse_valueå‚æ•°- ä¸æ”¯æŒvalue_stringå‚æ•°- ä¸æ”¯æŒvalue_stringså‚æ•°ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œå’Œæä¾›çš„Tensorå…·æœ‰ç›¸åŒçš„å€¼ 15 ConstantOfShape æ ¹æ®ç»™å®šçš„å€¼å’Œç»´åº¦ï¼Œç”Ÿæˆ1ä¸ªTensor ã€è¾“å…¥ã€‘inputï¼š1-D Tensorï¼Œç±»å‹ï¼šint32ï¼Œuint8ã€å‚æ•°ã€‘valueï¼šoptionalï¼Œ0-D Tensorï¼Œéœ€è¦å¡«å……çš„å€¼ï¼Œé»˜è®¤ä¸º0ï¼Œé»˜è®¤ç±»å‹float32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒvalue 16 Conv å·ç§¯ ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- Wï¼šè¾“å…¥Tensorï¼Œå…·æœ‰ç»´åº¦(M C/group kH kW)ï¼Œå…¶ä¸­Cæ˜¯channelsçš„æ•°é‡ï¼ŒkHå’ŒkWæ˜¯å·ç§¯æ ¸çš„é«˜å’Œå®½ï¼ŒMæ˜¯feature mapsçš„æ•°é‡- Bï¼šoptionalï¼Œ1D å¸¸é‡Tensorï¼Œå·ç§¯è®¡ç®—æ—¶æ·»åŠ çš„åç½®ã€å‚æ•°ã€‘- auto_padï¼šoptional, stringï¼Œpadçš„è®¡ç®—æ¨¡å¼ï¼Œé»˜è®¤æ˜¯NOTSET- dilationsï¼šoptionalï¼Œlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”å·ç§¯æ ¸å¯¹åº”ç©ºé—´è½´ä¸Šçš„æ‰©å¼ å€¼ï¼Œé»˜è®¤å€¼1- groupï¼šoptionalï¼Œintï¼Œç»„çš„æ•°é‡- kernel_shapeï¼šlist of intsï¼Œå·ç§¯æ ¸çš„ç»´åº¦- padsï¼šlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„padå€¼- list of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„æ»‘åŠ¨æ­¥é•¿ï¼Œé»˜è®¤å€¼ä¸º1ã€çº¦æŸã€‘auto_padå‚æ•°ä¸æ”¯æŒSAME_UPPER, SAME_LOWER*ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒX 17 ConvTranspose åå·ç§¯ ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- Wï¼šè¾“å…¥Tensorï¼Œå…·æœ‰ç»´åº¦(M C/group kH kW)ï¼Œå…¶ä¸­Cæ˜¯channelsçš„æ•°é‡ï¼ŒkHå’ŒkWæ˜¯å·ç§¯æ ¸çš„é«˜å’Œå®½ï¼ŒMæ˜¯feature mapsçš„æ•°é‡- Bï¼šoptionalï¼Œ1D å¸¸é‡Tensorï¼Œå·ç§¯è®¡ç®—æ—¶æ·»åŠ çš„åç½®ã€å‚æ•°ã€‘- auto_padï¼šoptional, stringï¼Œpadçš„è®¡ç®—æ¨¡å¼ï¼Œé»˜è®¤æ˜¯NOTSET- dilationsï¼šoptionalï¼Œlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”å·ç§¯æ ¸å¯¹åº”ç©ºé—´è½´ä¸Šçš„æ‰©å¼ å€¼ï¼Œé»˜è®¤å€¼1- groupï¼šoptionalï¼Œintï¼Œç»„çš„æ•°é‡- kernel_shapeï¼šlist of intsï¼Œå·ç§¯æ ¸çš„ç»´åº¦- output_paddingï¼šä¸ºè¾“å‡ºåæ ‡æŒ‡æ•°è¾ƒé«˜çš„è¾¹æ·»åŠ çš„é¢å¤–å€¼- output_shapeï¼šè¾“å‡ºçš„shape- padsï¼šlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„padå€¼- list of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„æ»‘åŠ¨æ­¥é•¿ï¼Œé»˜è®¤å€¼ä¸º1ã€çº¦æŸã€‘- auto_padå‚æ•°ä¸æ”¯æŒSAME_UPPER, SAME_LOWER- output_paddingå‚æ•°ä¸æ”¯æŒ- Wè¾“å…¥å¿…é¡»ä¸ºå¸¸é‡*ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 18 Cos è®¡ç®—ä½™å¼¦ ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 19 DepthToSpace é‡ç»„æ•°æ®ï¼Œæ ¹æ®blocksize ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- blocksizeï¼šæ•°æ®ç±»å‹ï¼šint- mode: æ•°æ®ç±»å‹ stringã€çº¦æŸã€‘modeä»…æ”¯æŒDCR CRDä¸¤ç§æ¨¡å¼ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 20 Div åšé™¤æ³•è¿ç®— ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint32- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint32ã€çº¦æŸã€‘å¯¹äºä¸¤ä¸ªè¾“å…¥ç»´åº¦ä¸ªæ•°ä¸ç›¸åŒçš„åœºæ™¯ï¼Œéœ€è¦å°†ç»´åº¦è¡¥é½åˆ°å››ç»´ã€‚ä¾‹å¦‚ï¼Œx.shape=(1, 5, 6, 7) å’Œ y.shape=(6, 7)éœ€è¦å°†yçš„ç»´åº¦è¡¥é½åˆ°4ç»´ï¼Œå³y.shape=(1, 1, 6, 7)ã€‚ã€è¾“å‡ºã€‘Cï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 21 Elu æ ¹æ®f(x) = alpha * (exp(x) - 1.) è¯¥å…¬å¼åšè®¡ç®— ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘alphaï¼šfloat32ï¼Œç¼ºçœå€¼ä¸º1.0ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 22 Equal åˆ¤æ–­è¾“å…¥æ˜¯å¦ç›¸ç­‰ ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šuint8,float32,bool,int32ï¼ˆint32åªæ”¯æŒæ ‡é‡ï¼‰- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šuint8,float32,bool,int32ï¼ˆint32åªæ”¯æŒæ ‡é‡ï¼‰ã€çº¦æŸã€‘æš‚ä¸æ”¯æŒå¹¿æ’­åœºæ™¯ã€è¾“å‡ºã€‘Cï¼šè¾“å‡ºTensorï¼Œç±»å‹ bool 23 Erf å¯¹è¾“å…¥æ•°æ®é€ä¸ªå…ƒç´ åšerror functionè®¡ç®— ã€è¾“å…¥ã€‘xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘yï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 24 Exp æŒ‡æ•°å‡½æ•°ï¼Œoutput = e^input ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œdoubleã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 25 Expand æ ¹æ®æŒ‡å®šçš„shapeåšå¹¿æ’­ ã€è¾“å…¥ã€‘- inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint8, uint8, bool- shapeï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šint32ï¼Œ1Dçš„tensorï¼ŒæŒ‡å®šè¾“å‡ºçš„shapeã€çº¦æŸã€‘- æ”¯æŒä»»æ„æ»¡è¶³broadcastæ¡ä»¶çš„Broadcaståœºæ™¯- å¯¹äºéœ€è¦æ’broadcastToç®—å­çš„Addã€Subã€Mulã€Divã€Maxï¼Œä¸æ”¯æŒé‡åŒ–åŠŸèƒ½- æ”¯æŒåœ¨Kirin 9000åŠä»¥åçš„èŠ¯ç‰‡ä¸Šè¿è¡Œã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 26 Flatten æ•°æ®æŒ‰ç»´åº¦å±•å¼€ ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥ Tensorï¼Œç±»å‹float32ã€å‚æ•°ã€‘axisï¼šintï¼Œæ ‡è¯†æ•°æ®åœ¨å“ªä¸ªç»´åº¦ä¸Šå±•å¼€ï¼Œå€¼çš„èŒƒå›´[-r, r]ï¼Œræ˜¯è¾“å…¥Tensorçš„ç»´åº¦ä¸ªæ•°ï¼Œè´Ÿå€¼è¡¨ç¤ºä»æœ€å1ä¸ªç»´åº¦å¾€å›è®¡ç®—ã€çº¦æŸã€‘axiså‚æ•°å¿…é¡»ä¸º1ã€è¾“å‡ºã€‘outputï¼š2-D Tensorï¼Œç±»å‹float32 27 Floor å¯¹è¾“å…¥è¿›è¡Œå‘ä¸‹å–æ•´ ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 28 Gather æ ¹æ®è¾“å…¥çš„indicesï¼Œä»dataä¸­è·å–entryç»„æˆè¾“å‡ºtensor ã€è¾“å…¥ã€‘- dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32, int32- indicesï¼šè¾“å…¥Tensorï¼Œæ•°æ®ç±»å‹int32ã€å‚æ•°ã€‘axisï¼šint, [-r, r-1] ,r = rank(data)ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒdataè¾“å…¥ 29 Gemm é€šç”¨çŸ©é˜µä¹˜æ³•ï¼ŒY = alpha Aâ€™ Bâ€™ + beta * C ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- Cï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- alphaï¼šfloat32ï¼ŒA Bçš„æ ‡é‡ä¹˜æ•°ï¼Œé»˜è®¤å€¼1.0- betaï¼šfloat32ï¼ŒCçš„æ ‡é‡ä¹˜æ•°ï¼Œé»˜è®¤å€¼1.0- transAï¼šintï¼ŒAè¾“å…¥æ˜¯å¦éœ€è¦è½¬ç½®ï¼Œé»˜è®¤å€¼0- transBï¼šintï¼ŒBè¾“å…¥æ˜¯å¦éœ€è¦è½¬ç½®ï¼Œé»˜è®¤å€¼0ã€çº¦æŸã€‘- transAå‚æ•°ä¸æ”¯æŒtrue- è¾“å…¥Bå’ŒCåªæ”¯æŒå¸¸é‡- å¦‚æœAæ˜¯MKï¼ŒBæ˜¯KNï¼ŒCå¯ä»¥æ˜¯Næˆ–1Næˆ–ä¸æŒ‡å®šã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç»´åº¦æ˜¯ï¼ˆM, Nï¼‰ 30 GlobalAveragePool å¯¹è¾“å…¥è¿›è¡Œå…¨å±€å¹³å‡æ± åŒ– ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œç»´åº¦æ˜¯ï¼ˆN C H Wï¼‰ã€çº¦æŸã€‘æ— *ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 31 GlobalMaxPool å¯¹è¾“å…¥è¿›è¡Œå…¨å±€æœ€å¤§æ± åŒ– ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹float32ï¼Œç»´åº¦æ˜¯ï¼ˆN C H Wï¼‰ã€çº¦æŸã€‘æ— *ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 32 Greater é€ä¸ªå…ƒç´ æ¯”è¾ƒå“ªä¸ªå¤§ ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹float32ï¼Œ- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹float32ï¼Œã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Cï¼šè¾“å‡ºTensorï¼Œç±»å‹ bool 33 InstanceNormalization æŒ‰ç…§ä¸‹é¢å…¬å¼åšå½’ä¸€åŒ–è¿ç®—y = scale * (x - mean) / sqrt(variance + epsilon) + B ã€è¾“å…¥ã€‘- inputï¼šè¾“å…¥4D Tensorï¼Œç±»å‹float32ï¼Œ- scaleï¼šè¾“å…¥Tensorï¼Œç±»å‹float32ï¼Œ- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹float32ï¼Œã€å‚æ•°ã€‘alphaï¼šfloat32ï¼Œé¿å…é™¤é›¶é”™è¯¯ï¼Œé»˜è®¤å€¼1e-05ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒinputè¾“å…¥ 34 LeakyRelu å¯¹è¾“å…¥è¿›è¡ŒLeakyReluæ¿€æ´»å‡½æ•°è®¡ç®—f(x) = alpha * x for x &lt; 0, f(x) = x for x &gt;= 0 ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘alphaï¼šfloat32ï¼Œæ³„æ¼ç³»æ•°ï¼Œé»˜è®¤å€¼0.01ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 35 Less å¯¹è¾“å…¥Aå’ŒBè¿›è¡Œé€å…ƒç´ Lessé€»è¾‘è¿ç®— ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘Cï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šbool 36 Log å–è‡ªç„¶å¯¹æ•°è¿ç®— ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼š float32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒinputè¾“å…¥ 37 LogSoftmax å¯¹è¾“å…¥è¿›è¡Œlogsoftmaxï¼ˆlog of softmaxï¼‰è®¡ç®— ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘axisï¼šintï¼Œè¾“å…¥å˜ä¸º2Dç»´åº¦æ—¶çš„è½´ï¼Œé»˜è®¤å€¼1ã€çº¦æŸã€‘axiså‚æ•°ä»…æ”¯æŒæœ€åä¸€ç»´ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç»´åº¦å’Œè¾“å…¥ç›¸åŒ 38 MatMul çŸ©é˜µä¹˜ ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘- A: è¾“å…¥tensorï¼Œ2&lt;=rank&lt;=4- B: è¾“å…¥tensorï¼Œç±»å‹ä¸rankåŒAã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 39 Max é€ä¸ªå…ƒç´ å–æœ€å¤§å€¼ ã€è¾“å…¥ã€‘- X1ï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- X2ï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘- å¯¹äºä¸¤ä¸ªè¾“å…¥ç»´åº¦ä¸ªæ•°ä¸ç›¸åŒçš„åœºæ™¯ï¼Œéœ€è¦å°†ç»´åº¦è¡¥é½åˆ°å››ç»´ã€‚ä¾‹å¦‚ï¼Œx.shape=(1, 5, 6, 7) å’Œ y.shape=(6, 7)éœ€è¦å°†yçš„ç»´åº¦è¡¥é½åˆ°4ç»´ï¼Œå³y.shape=(1, 1, 6, 7)ï¼›Kirin 9000å¹³å°ä¸‹ï¼Œå·²ç»æ”¯æŒbroadcastï¼›1&lt;=N &lt;= 65535- åªæ”¯æŒ2ä¸ªè¾“å…¥ã€è¾“å‡ºã€‘yï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 40 MaxPool æœ€å¤§æ± åŒ– ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- auto_padï¼šoptional, stringï¼Œpadçš„è®¡ç®—æ¨¡å¼ï¼Œé»˜è®¤æ˜¯NOTSET- ceil_modeï¼šoptional, intï¼Œä½¿ç”¨ceilï¼ˆå‘ä¸Šå–æ•´ï¼‰è¿˜æ˜¯floorï¼ˆå‘ä¸‹å–æ•´ï¼‰è®¡ç®—è¾“å‡ºç»´åº¦ï¼Œé»˜è®¤å€¼0ï¼ˆceilï¼‰- dilationsï¼šoptionalï¼Œlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”æ± åŒ–æ ¸å¯¹åº”ç©ºé—´è½´ä¸Šçš„æ‰©å¼ å€¼ï¼Œé»˜è®¤å€¼1- kernel_shapeï¼šlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„çª—å£å¤§å°- padsï¼šlist of intsï¼Œæ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„padå€¼ï¼Œé»˜è®¤å€¼ä¸º0- storage_orderï¼šintï¼ŒTensorçš„å­˜å‚¨é¡ºåºï¼Œé»˜è®¤å€¼0ï¼ŒæŒ‰è¡Œå­˜å‚¨- stridesï¼šlist of intsï¼Œå…¶ä¸­æ¯ä¸ªå€¼å¯¹åº”ç›¸åº”ç»´åº¦çš„æ»‘åŠ¨æ­¥é•¿ï¼Œé»˜è®¤å€¼ä¸º1ã€çº¦æŸã€‘- auto_padå‚æ•°åªæ”¯æŒé»˜è®¤å€¼- storage_orderå‚æ•°åªæ”¯æŒé»˜è®¤å€¼- dilationså‚æ•°åªæ”¯æŒé»˜è®¤å€¼- Indiceså¯é€‰è¾“å‡ºä¸æ”¯æŒã€è¾“å‡ºã€‘- Yï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸Xè¾“å…¥ç›¸åŒ- Indicesï¼šoptionalï¼Œè¾“å‡ºTensor 41 Min é€ä¸ªå…ƒç´ å–æœ€å° ã€è¾“å…¥ã€‘- X1ï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32, int32- X2ï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32,int32ã€çº¦æŸã€‘- 5Dè¾“å…¥ä¸æ”¯æŒå¸¸é‡å¹¿æ’­- åªæ”¯æŒ2ä¸ªè¾“å…¥ã€è¾“å‡ºã€‘yï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸Xnè¾“å…¥ç›¸åŒ 42 Mul äºŒå…ƒç‚¹ä¹˜ ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œç¬¬1ä¸ªæ“ä½œæ•°- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œç¬¬2ä¸ªæ“ä½œæ•°ã€çº¦æŸã€‘æ”¯æŒä¸¤ç»„è¾“å…¥çš„ç»´åº¦ä¸ä¸€è‡´ï¼Œè¿›è¡Œå¹¿æ’­æ“ä½œï¼ˆå¹¿æ’­å³ç»´åº¦è¡¥é½ï¼‰ï¼Œç›®å‰æ”¯æŒä»¥ä¸‹å‡ ç§å¹¿æ’­åœºæ™¯ï¼š- NCHW+NCHW(å¤‡æ³¨, ä¸¤ä¸ªç»´åº¦ç›¸åŒtensor)- NCHW+scalar- NCHW+W, CHW+W, HW+W(å¤‡æ³¨, Wç»´åº¦åšbroadcast)- NCHW + NCH1, CHW + CH1, HW + H1- CHW + C1W(å¤‡æ³¨ï¼ŒHç»´åº¦åšbroadcast)å¯¹äºä¸¤ä¸ªè¾“å…¥ç»´åº¦ä¸ªæ•°ä¸ç›¸åŒçš„åœºæ™¯ï¼Œéœ€è¦å°†ç»´åº¦è¡¥é½åˆ°å››ç»´ã€‚ä¾‹å¦‚ï¼Œx.shape=(1, 5, 6, 7) å’Œ y.shape=(6, 7)éœ€è¦å°†yçš„ç»´åº¦è¡¥é½åˆ°4ç»´ï¼Œå³y.shape=(1, 1, 6, 7)ã€‚è¯´æ˜ï¼šä¸¤ä¸ªTensorçš„è¾“å…¥é¡ºåºå¯ä»¥äº’æ¢ã€‚ã€è¾“å‡ºã€‘Cï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒB 43 Neg å¯¹Tensorçš„æ¯ä¸ªå…ƒç´ å–åï¼Œy=-x ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 44 NonMaxSuppression è¿›è¡Œéæœ€å¤§å€¼å‹ç¼©åœ¨æŒ‡å®šæ¡†ä¸­ ã€è¾“å…¥ã€‘- boxesï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- scoresï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- max_output_boxes_per_classï¼ˆå¯é€‰ï¼‰ï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šint32- iou_thresholdï¼ˆå¯é€‰ï¼‰ï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- score_thresholdï¼ˆå¯é€‰ï¼‰ï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘- max_output_boxes_per_classã€iou_thresholdã€score_thresholdä»…æ”¯æŒæƒå€¼è¾“å…¥- max_output_boxes_per_classä¸æ”¯æŒå–0- iou_thresholdä¸æ”¯æŒå–0å’Œ1ã€è¾“å‡ºã€‘selected_indicesï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 45 Or å¯¹è¾“å…¥Tensorçš„æ¯ä¸ªå…ƒç´ å–é€»è¾‘æˆ– ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šbool- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šboolã€çº¦æŸã€‘inputè¾“å…¥ä¸æ”¯æŒNCHWæ ¼å¼æ•°æ®ã€è¾“å‡ºã€‘Cï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šbool 46 PRelu æ ¹æ®ä¸‹é¢å…¬å¼åšè¿ç®—f(x) = slope * x for x &lt; 0, f(x) = x for x &gt;= 0 ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- slopeï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘- slopeè¾“å…¥å¿…é¡»æ˜¯å¸¸é‡- slopeå¿…é¡»æ˜¯æ ‡é‡æˆ–è€…1C11æˆ–C11çš„å½¢å¼ï¼Œå…¶ä¸­Cæ˜¯Xè¾“å…¥çš„channel- Xè¾“å…¥å¿…é¡»æ˜¯4Dã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 47 Pad å¯¹è¾“å…¥Tensoråšè¡¥padå¤„ç† ã€è¾“å…¥ã€‘- dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- padsï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šint64- constant_valueï¼šoptionalï¼Œè¾“å…¥Tensorï¼Œæ ‡é‡ï¼Œç±»å‹åŒdataè¾“å…¥ï¼Œé»˜è®¤å€¼0ã€å‚æ•°ã€‘- modeï¼šstringï¼Œæ”¯æŒçš„æ¨¡å¼- åœ¨opset 7~10ä¸­padsè¾“å…¥æ˜¯å‚æ•°- åœ¨opset 7~10ä¸­å­˜åœ¨valueå‚æ•°ï¼Œè¡¨ç¤ºè¦è¢«å¡«å……çš„å€¼ã€çº¦æŸã€‘- modeä»…æ”¯æŒconstantæ¨¡å¼- padsè¾“å…¥å¿…é¡»æ˜¯å¸¸é‡ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 48 Pow é€ä¸ªå…ƒç´ åšæŒ‡æ•°è¿ç®— ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32, int32- Yï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32, int32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘Zï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32, int32 49 Range åˆ›å»ºä¸€ä¸ªTensorï¼ŒTensorçš„æ•°æ®ä»¥startå¼€å§‹ï¼Œä»¥deltaä½œä¸ºæ­¥é•¿æ‰©å±•ç›´åˆ°limit ã€è¾“å…¥ã€‘- startï¼šè¾“å…¥Tensorï¼Œæ ‡é‡ï¼Œç±»å‹ï¼šfloat32ï¼Œint32ï¼Œè¾“å‡ºæ•°æ®çš„èµ·å§‹å€¼- limitï¼šè¾“å…¥Tensorï¼Œæ ‡é‡ï¼Œç±»å‹ï¼šfloat32ï¼Œint32ï¼Œè¾“å‡ºæ•°æ®çš„ä¸Šé™å€¼- deltaï¼šè¾“å…¥Tensorï¼Œæ ‡é‡ï¼Œç±»å‹ï¼šfloat32ï¼Œint32ï¼Œæ­¥é•¿ã€çº¦æŸã€‘- è¾“å…¥startå¿…é¡»æ˜¯å¸¸é‡- è¾“å…¥limitå¿…é¡»æ˜¯å¸¸é‡- è¾“å…¥deltaå¿…é¡»æ˜¯å¸¸é‡ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œæ ‡é‡ï¼Œç±»å‹float32ï¼Œint32 50 ReduceLogSumExp è®¡ç®—è¾“å…¥Tensoræ²¿ç€æŒ‡å®šè½´ä¸Šçš„å¯¹æ•°å’Œçš„æŒ‡æ•° ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- axesï¼šlist of intsï¼ŒæŒ‡å®šçš„è½´- keepdimsï¼šintsï¼Œæ˜¯å¦ä¿ç•™æŒ‡å®šè½´ä¸Šçš„ç»´åº¦ï¼Œé»˜è®¤å€¼æ˜¯1ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘reducedï¼šè¾“å‡ºTensor 51 ReduceMax è®¡ç®—è¾“å…¥Tensoræ²¿ç€æŒ‡å®šè½´ä¸Šçš„æœ€å¤§å€¼ ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- axesï¼šlist of intsï¼ŒæŒ‡å®šçš„è½´- keepdimsï¼šintsï¼Œæ˜¯å¦ä¿ç•™æŒ‡å®šè½´ä¸Šçš„ç»´åº¦ï¼Œå¦‚æœæ˜¯1ï¼Œä¿ç•™ï¼Œå¦‚æœæ˜¯0ï¼Œåˆ™ä¸ä¿ç•™ï¼Œé»˜è®¤å€¼æ˜¯1ã€çº¦æŸã€‘axeså‚æ•°ä¸ºå¿…é€‰å‚æ•°ã€è¾“å‡ºã€‘reducedï¼šè¾“å‡ºTensor 52 ReduceMean è®¡ç®—è¾“å…¥Tensoræ²¿ç€æŒ‡å®šè½´ä¸Šçš„å¹³å‡å€¼ ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- axesï¼šlist of intsï¼ŒæŒ‡å®šçš„è½´- keepdimsï¼šintsï¼Œæ˜¯å¦ä¿ç•™æŒ‡å®šè½´ä¸Šçš„ç»´åº¦ï¼Œå¦‚æœæ˜¯1ï¼Œä¿ç•™ï¼Œå¦‚æœæ˜¯0ï¼Œåˆ™ä¸ä¿ç•™ï¼Œé»˜è®¤å€¼æ˜¯1ã€çº¦æŸã€‘axeså‚æ•°ä¸ºå¿…é€‰å‚æ•°ã€è¾“å‡ºã€‘reducedï¼šè¾“å‡ºTensor 53 ReduceMin è®¡ç®—è¾“å…¥Tensoræ²¿ç€æŒ‡å®šè½´ä¸Šçš„æœ€å°å€¼ ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- axesï¼šlist of intsï¼ŒæŒ‡å®šçš„è½´- keepdimsï¼šintï¼Œæ˜¯å¦ä¿ç•™ç»´åº¦ï¼Œé»˜è®¤å€¼1ã€çº¦æŸã€‘- axeså‚æ•°ä¸ºå¿…é€‰å‚æ•°- keepdimså‚æ•°ä»…æ”¯æŒè®¾ç½®ä¸º1ã€è¾“å‡ºã€‘reducedï¼šè¾“å‡ºTensor 54 ReduceSum è®¡ç®—è¾“å…¥Tensoræ²¿ç€æŒ‡å®šè½´ä¸Šçš„å’Œ ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- axesï¼šlist of intsï¼ŒæŒ‡å®šçš„è½´- keepdimsï¼šintï¼Œæ˜¯å¦ä¿ç•™ç»´åº¦ï¼Œé»˜è®¤å€¼1ã€çº¦æŸã€‘axeså‚æ•°ä¸ºå¿…é€‰å‚æ•°ã€è¾“å‡ºã€‘reducedï¼šè¾“å‡ºTensor 55 Relu æ•´æµçº¿æ€§å•ä½å‡½æ•° ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 56 Reshape æ”¹å˜è¾“å…¥Tensorçš„ç»´åº¦ ã€è¾“å…¥ã€‘- dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint32ï¼Œint64ï¼Œbool- shapeï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šint32ï¼Œint64ã€çº¦æŸã€‘shapeè¾“å…¥å¿…é¡»æ˜¯å¸¸é‡ã€è¾“å‡ºã€‘reshapedï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒdataè¾“å…¥ 57 Resize è°ƒæ•´è¾“å…¥tensorçš„ç»´åº¦ ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- roiï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- align_cornersï¼šboolï¼Œç¼ºçœå€¼ä¸ºfalse- half_pixel_centersï¼šboolï¼Œç¼ºçœå€¼ä¸ºfalseã€çº¦æŸã€‘- scaleså’Œsizesä¸¤ä¸ªè¾“å…¥ä»…æ”¯æŒæƒå€¼è¾“å…¥ï¼Œä¸æ”¯æŒéæƒå€¼è¾“å…¥- coordinate_transformation_modeæ”¯æŒhalf_pixelï¼Œpytorch_half_pixelã€‚å…¶ä¸­pytorch_half_pixelä»…æ”¯æŒresized_length&gt;1åœºæ™¯ï¼Œresized_length &lt;=1åœºæ™¯æŠ¥é”™- cubic_coeff_aä»…æ”¯æŒé»˜è®¤å€¼-0.75- exclude_outsideä»…æ”¯æŒé»˜è®¤å€¼0- extrapolation_valueä»…æ”¯æŒé»˜è®¤å€¼ï¼š0.0- mode æ”¯æŒnearest, linear- nearest_modeä»…æ”¯æŒé»˜è®¤å€¼round_prefer_floor- ä¸æ”¯æŒcropåŠŸèƒ½- roiæ˜¯æ— æ•ˆè¾“å…¥æ—¶ï¼Œä»…æ”¯æŒæƒå€¼è¾“å…¥- å…¶ä»–åœºæ™¯æŠ¥é”™å¤„ç†ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒdataè¾“å…¥ 58 RoiAlign å¯¹å…³æ³¨çš„åŒºåŸŸåšå¯¹é½æ“ä½œ ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- roiï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šint32- batch_indicesï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šint32ã€å‚æ•°ã€‘- modeï¼šstringï¼Œç¼ºçœå€¼ä¸ºavg- output_heightï¼šint32ï¼Œç¼ºçœå€¼ä¸º1- output_widthï¼šint32ï¼Œç¼ºçœå€¼ä¸º1- sampling_ratioï¼šint32ï¼Œç¼ºçœå€¼ä¸º1- spatial_scaleï¼šfloat32ï¼Œç¼ºçœå€¼ä¸º1.0ã€çº¦æŸã€‘modeä»…æ”¯æŒavgæ¨¡å¼ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 59 Round é€ä¸ªå…ƒç´ å–æ•´ ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 60 ScatterElements ç»˜åˆ¶æ•£ç‚¹å›¾ ã€è¾“å…¥ã€‘- dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32, int8, uint8, bool- indicesï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šint32, int64- updatesï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32, int8, uint8, boolã€å‚æ•°ã€‘axisï¼šintï¼Œç¼ºçœå€¼ä¸º0ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒdataè¾“å…¥ 61 Selu å¯¹è¾“å…¥åšä¸‹é¢å…¬å¼è®¡ç®—y = gamma (alpha e^x - alpha) for x &lt;= 0, y = gamma * x for x &gt; 0 ã€è¾“å…¥ã€‘xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- alphaï¼šfloat32ï¼Œç¼ºçœå€¼ä¸º1.67326- gammaï¼šfloat32ï¼Œç¼ºçœå€¼ä¸º1.0507ã€çº¦æŸã€‘ä»…æ”¯æŒalphaå’Œgammaå‚æ•°æ˜¯é»˜è®¤å€¼ã€è¾“å‡ºã€‘yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒxè¾“å…¥ 62 Shape è·å–è¾“å…¥Tensorçš„ç»´åº¦ï¼Œå¹¶è¾“å‡º ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint32ï¼Œboolï¼Œuint8ã€çº¦æŸã€‘ä¸æ”¯æŒæŒ‡å®šä¸ºè¾“å‡ºèŠ‚ç‚¹ã€è¾“å‡ºã€‘shapeï¼šè¾“å‡ºTensorï¼Œdataè¾“å…¥çš„ç»´åº¦ 63 Sigmoid sigmoidå‡½æ•°ï¼Œy = 1 / (1 + exp(-x)) ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 64 Sign signå‡½æ•°ï¼ˆç¬¦å·å‡½æ•°ï¼‰ï¼Œå½“x&gt;0ï¼Œsign(x)=1å½“x=0ï¼Œsign(x)=0å½“x&lt;0ï¼Œsign(x)=-1 ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹å’Œç»´åº¦åŒinputè¾“å…¥ 65 Sin è®¡ç®—æ­£å¼¦ ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— é™åˆ¶ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ä¸xè¾“å…¥ç›¸åŒ 66 Slice å¯¹è¾“å…¥Tensoræ²¿ç€æŒ‡å®šè½´åˆ‡åˆ† ã€è¾“å…¥ã€‘- dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint32ï¼Œuint8ï¼Œbool- startsï¼š1-Dè¾“å…¥Tensorï¼Œç±»å‹ï¼šint64ï¼Œint32ï¼Œè¡¨ç¤ºåœ¨æŒ‡å®šè½´ä¸Šåˆ‡åˆ†çš„èµ·å§‹ä½ç½®- endsï¼š1-Dè¾“å…¥Tensorï¼Œç±»å‹ï¼šint64ï¼Œint32ï¼Œè¡¨ç¤ºåœ¨æŒ‡å®šè½´ä¸Šåˆ‡åˆ†çš„ç»“æŸä½ç½®- axesï¼šoptionalï¼Œ1-Dè¾“å…¥Tensorï¼Œç±»å‹ï¼šint64ï¼Œint32ï¼ŒæŒ‡å®šéœ€è¦åˆ‡åˆ†çš„è½´ï¼Œç¼ºçœè¡¨ç¤ºæ²¿æ‰€æœ‰çš„ç»´åº¦åˆ‡åˆ†ï¼Œè´Ÿå€¼è¡¨ç¤ºä»åå¾€å‰ç»Ÿè®¡ç»´åº¦å€¼- stepsï¼šoptionalï¼Œ1-Dè¾“å…¥Tensorï¼Œç±»å‹ï¼šint64ï¼Œint32ï¼Œåˆ‡åˆ†çš„æ­¥é•¿ã€å‚æ•°ã€‘opset9åŠä¹‹å‰ç‰ˆæœ¬ï¼Œaxesï¼Œendsï¼Œstartsæ˜¯å‚æ•°ã€çº¦æŸã€‘- è¾“å…¥startsï¼Œendsï¼Œaxesï¼Œstepså¿…é¡»ä¸ºå¸¸é‡- ä¸æ”¯æŒåˆ‡åˆ†åï¼Œå­˜åœ¨ç»´åº¦ä¸º0çš„åœºæ™¯ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œåˆ‡åˆ†åçš„Tensor 67 Softmax å½’ä¸€åŒ–é€»è¾‘å‡½æ•° ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘axisï¼šintï¼Œè¾“å…¥å˜ä¸º2Dç»´åº¦æ—¶çš„è½´ï¼Œé»˜è®¤å€¼1ã€çº¦æŸã€‘axiså‚æ•°ä»…æ”¯æŒæœ€åä¸€ç»´ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹å’Œç»´åº¦åŒinputè¾“å…¥ 68 Softplus softplusæ¿€æ´»å‡½æ•°ï¼Œy = ln(exp(x) + 1) ã€è¾“å…¥ã€‘Xï¼š1-Dè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Yï¼š1-Dè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 69 Split åœ¨æŒ‡å®šè½´ä¸Šåšæ‹†åˆ†,è¾“å‡ºå¤šä¸ªtensor ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼š float32ã€å‚æ•°ã€‘- axisï¼šint, ç¼ºçœå€¼ä¸º0- split: list of ints å€¼å¿…é¡»å¤§äºç­‰äº0ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputsï¼šDè¾“å‡ºTensorï¼Œç±»å‹åŒè¾“å…¥ 70 Sqrt æ±‚å¹³æ–¹æ ¹ ã€è¾“å…¥ã€‘Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒXè¾“å…¥ 71 Squeeze åœ¨æŒ‡å®šè½´ä¸Šé™ç»´ ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘axesï¼šlist of intsï¼Œè½´ï¼Œç¼ºçœå€¼ä¸ºæ‰€æœ‰ç»´åº¦ï¼Œè´Ÿå€¼è¡¨ç¤ºä»åå¾€å‰éå†ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘squeezedï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 72 Sub é€ä¸ªå…ƒç´ çš„å‡æ³•è¿ç®— ã€è¾“å…¥ã€‘- Aï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32 ï¼Œç¬¬1ä¸ªæ“ä½œæ•°- Bï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32 ï¼Œç¬¬2ä¸ªæ“ä½œæ•°ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘Cï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 73 Tan æ­£åˆ‡å‡½æ•° ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 74 Tanh åŒæ›²å‡½æ•° ã€è¾“å…¥ã€‘inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 75 Tile å¯¹è¾“å…¥Tensoråšå¹³é“ºæ“ä½œ ã€è¾“å…¥ã€‘- inputï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint8ï¼Œuint8ï¼Œbool- repeatsï¼š1-Dè¾“å…¥Tensorï¼Œç±»å‹ï¼šint32, int64ã€çº¦æŸã€‘repeatsè¾“å…¥å¿…é¡»æ˜¯å¸¸é‡ã€è¾“å‡ºã€‘outputï¼šè¾“å‡ºTensorï¼Œç±»å‹åŒinputè¾“å…¥ 76 TopK å®ç°æœ€å¤§æˆ–è€…æœ€å°çš„Kä¸ªå…ƒç´ åœ¨æŒ‡å®šçš„è½´ä¸Šã€‚ ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- Kï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šint32, int64ã€å‚æ•°ã€‘- axisï¼šintï¼Œç¼ºçœå€¼ä¸º-1- largestï¼šintï¼Œç¼ºçœå€¼ä¸º1- sortedï¼šintï¼Œç¼ºçœå€¼ä¸º1ã€çº¦æŸã€‘Kè¾“å…¥å¿…é¡»æ˜¯å¸¸é‡ã€è¾“å‡ºã€‘- valuesï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32- indices: è¾“å‡ºTensorï¼Œç±»å‹ï¼šint32 77 Transpose æ ¹æ®å±æ€§permä¸­å„ä¸ªè½´çš„æ’åˆ—é¡ºåºï¼Œå¯¹è¾“å…¥Tensorå’Œshapeåšç›¸åº”è½¬æ¢ ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘permï¼šlist of intsï¼Œè½´è°ƒæ•´æ’åˆ—çš„é¡ºåºè¡¨ã€çº¦æŸã€‘æ— ã€è¾“å‡ºã€‘transposedï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 78 Unsqueeze åœ¨æŒ‡å®šè½´ä¸Šæ‰©ç»´ ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ï¼Œint32ï¼Œuint8ï¼Œboolã€å‚æ•°ã€‘axesï¼šlist of intsï¼ŒæŒ‡å®šéœ€è¦æ‰©ç»´çš„è½´ã€çº¦æŸã€‘ä»…æ”¯æŒaxesä¸ªæ•°ä¸º1ã€è¾“å‡ºã€‘expandedï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32ï¼Œint32ï¼Œuint8ï¼Œbool 79 Upsample ä¸Šé‡‡æ · ã€è¾“å…¥ã€‘- Xï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32- scalesï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- modeï¼šstringï¼Œæ¨¡å¼ï¼Œæœ‰2ä¸ªæ’å€¼æ¨¡å¼ï¼Œnearestæ¨¡å¼å’Œlinearæ¨¡å¼ï¼ˆåŒ…å«bilinear, trilinearç­‰ï¼‰ï¼Œé»˜è®¤æ˜¯nearestæ¨¡å¼- åœ¨opset7ä¸­scalesè¾“å…¥æ˜¯å‚æ•°ã€çº¦æŸã€‘- ä»…æ”¯æŒnearestã€bilinearä¸¤ç§æ’å€¼æ¨¡å¼- Xä»…æ”¯æŒ4Dè¾“å…¥Tensor- Nã€Cæ–¹å‘çš„scaleä»…æ”¯æŒç­‰äº1.0ã€è¾“å‡ºã€‘Yï¼šè¾“å‡ºTensorï¼Œç±»å‹ï¼šfloat32 80 ReduceL2ï¼ˆV510æ–°å¢ï¼‰ è®¡ç®—è¾“å…¥Tensoræ²¿ç€æŒ‡å®šè½´ä¸Šçš„æ¬§å‡ é‡Œå¾—èŒƒæ•° ã€è¾“å…¥ã€‘dataï¼šè¾“å…¥Tensorï¼Œç±»å‹ï¼šfloat32ã€å‚æ•°ã€‘- axesï¼šlist of intsï¼ŒæŒ‡å®šçš„è½´- keepdimsï¼šintï¼Œæ˜¯å¦ä¿ç•™ç»´åº¦ï¼Œé»˜è®¤å€¼1ã€çº¦æŸã€‘- åªæ”¯æŒkeepdims=1çš„æƒ…å½¢ï¼Œæ‰€ä»¥è¾“å…¥å’Œè¾“å‡ºçš„realDimç›¸ç­‰- è¾“å…¥N &lt;= 65535- axesèŒƒå›´ï¼šæ”¯æŒrealDimä¸º3å’ŒrealDimä¸º4æ—¶å¯¹æœ€åä¸€ç»´åšreduceL2ã€è¾“å‡ºã€‘reducedï¼šè¾“å‡ºTensor","link":"/posts/5ae3bedd/"},{"title":"Autoware è½¯ä»¶å¼€å‘æŒ‡å—","text":"ç›®å½• ä¸€ã€Autoware æ¦‚è¿°åŠå®‰è£…æŒ‡å— äºŒã€Autoware æ„ŸçŸ¥æ¨¡å—è§£æ 2.1 åŸºäºDarknetçš„Yolov3å›¾åƒè¯†åˆ« 2.2 voxel_grid_filterç‚¹äº‘é™é‡‡æ ·ç¨‹åºæ³¨è§£ 2.3 ring_ground_filteråœ°é¢ç‚¹äº‘å»é™¤ç¨‹åºæ³¨è§£ ä¸‰ã€Autoware å®šä½æ¨¡å—è§£æ 3.0 åŸºç¡€çŸ¥è¯† 3.1 ndt_mappingèŠ‚ç‚¹è§£æ 3.2 ndt_matchingèŠ‚ç‚¹è§£æ å››ã€Autoware å†³ç­–è§„åˆ’æ¨¡å—è§£æ 4.1 èŠ‚ç‚¹waypoint_loader 4.2 èŠ‚ç‚¹waypoint_replanner 4.3 èŠ‚ç‚¹lane_navi 4.4 èŠ‚ç‚¹lane_rule 4.5 èŠ‚ç‚¹lane_select 4.6 èŠ‚ç‚¹ astar_avoid 4.7 èŠ‚ç‚¹velocity_set äº”ã€Autoware æ§åˆ¶æ¨¡å—è§£æ 5.1 èŠ‚ç‚¹pure_pursuit 5.2 èŠ‚ç‚¹twist_filter 5.3 èŠ‚ç‚¹listener_car_drive ä¸€ã€Autoware æ¦‚è¿°åŠå®‰è£…æŒ‡å—1.1 Autowareç®€ä»‹â€‹ Autoware æœ€æ—©æ˜¯ç”±åå¤å±‹å¤§å­¦ç ”ç©¶å°ç»„åœ¨åŠ è—¤ä¼¸å¹³æ•™æˆ(Prof. Shinpei Kato)çš„é¢†å¯¼ä¸‹äº2015å¹´8æœˆæ­£å¼å‘å¸ƒã€‚2015å¹´12æœˆä¸‹æ—¬ï¼ŒåŠ è—¤ä¼¸å¹³æ•™æˆåˆ›ç«‹äº†Tier IVï¼Œä»¥ç»´æŠ¤Autowareå¹¶å°†å…¶åº”ç”¨äºçœŸæ­£çš„è‡ªåŠ¨é©¾é©¶æ±½è½¦ã€‚éšç€æ—¶é—´çš„æµé€ï¼ŒAutowareå·²æˆä¸ºå…¬è®¤çš„å¼€æºé¡¹ç›®ã€‚Autoware ä¹Ÿæ˜¯ä¸–ç•Œä¸Šç¬¬ä¸€ä¸ªç”¨äºè‡ªåŠ¨é©¾é©¶æŠ€æœ¯çš„â€œå¤šåˆä¸€â€å¼€æºè½¯ä»¶ã€‚Autoware.aiç‰ˆæœ¬åŸºäºROS 1ï¼Œå¹¶åœ¨Apache 2.0è®¸å¯ä¸‹å¯ç”¨ã€‚Autowareçš„åŠŸèƒ½ä¸»è¦é€‚åˆä¸åŸå¸‚ï¼Œä½†ä¹Ÿå¯ä»¥è¦†ç›–é«˜é€Ÿå…¬è·¯ã€‚æ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼šè·¯å¾„è§„åˆ’ã€è·¯å¾„è·Ÿéšã€åŠ é€Ÿ/åˆ¶åŠ¨/è½¬å‘æ§åˆ¶ã€æ•°æ®è®°å½•ã€æ±½è½¦/è¡Œäºº/ç‰©ä½“æ£€æµ‹ã€3Dæœ¬åœ°åŒ–ã€3Dæ˜ å°„ã€äº¤é€šä¿¡å·æ£€æµ‹ã€äº¤é€šç¯è¯†åˆ«ã€è½¦é“æ£€æµ‹ã€å¯¹è±¡è·Ÿè¸ªã€ä¼ æ„Ÿå™¨æ ¡å‡†ã€ä¼ æ„Ÿå™¨èåˆã€é¢å‘äº‘çš„åœ°å›¾è¿æ¥è‡ªåŠ¨åŒ–ã€æ™ºèƒ½æ‰‹æœºå¯¼èˆªã€è½¯ä»¶ä»¿çœŸã€è™šæ‹Ÿç°å®ç­‰ã€‚ â€‹ Autoware ä½œä¸ºç¬¬ä¸€æ¬¾å¼€æºçš„è‡ªåŠ¨é©¾é©¶æ¡†æ¶ï¼Œå½“å‰å„å¤§è‡ªåŠ¨é©¾é©¶å…¬å¸çš„æ¡†æ¶å‡ ä¹éƒ½å€Ÿé‰´è¿‡ï¼ŒAutowareæ¡†æ¶æ˜¯ç†è§£è‡ªåŠ¨é©¾é©¶ç³»ç»ŸçŸ¥è¯†æœ€å¥½çš„å­¦ä¹ æ¨¡æ¿ä¹‹ä¸€ã€‚å…¶åŒ…å«äº†è‡ªåŠ¨é©¾é©¶æ‰€æœ‰å…³é”®æŠ€æœ¯æ¨¡å—ï¼šå»ºå›¾ã€å®šä½ã€æ„ŸçŸ¥ã€è§„åˆ’å’Œè¿åŠ¨æ§åˆ¶ã€‚ 1.2 Autowareä¸»ä½“æ¡†æ¶â€‹ autowareä¸»è¦åŒ…æ‹¬sensingã€computingï¼ˆperceptionã€decisionã€planningï¼‰ã€actuationç­‰å‡ ä¸ªéƒ¨åˆ†ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ â€‹ sensingæ¨¡å—å¯¹åº”çš„æ˜¯å„ç±»ä¼ æ„Ÿå™¨å¯¹çœŸå®ä¸–ç•Œä¸­å„ç±»æ•°æ®çš„é‡‡æ ·ï¼Œä¾‹å¦‚cameraé‡‡æ ·å›¾åƒã€LiDARé‡‡æ ·æ¿€å…‰ç‚¹äº‘ç­‰ï¼Œé‡‡æ ·æ•°æ®å±äºæœªå¤„ç†çš„åŸå§‹æ•°æ®ï¼Œéœ€è¦è¾“å…¥åˆ°computingæ¨¡å—è¿›è¡Œè®¡ç®—å¤„ç†ã€‚ â€‹ computingæ¨¡å—ä¸»è¦æ˜¯ä¸ºäº†å¯¹ä¼ æ„Ÿå™¨é‡‡æ ·çš„åŸå§‹æ•°æ®è¿›è¡ŒåŠ å·¥å¤„ç†ï¼Œæœ€åä»¥ä¸ºå®ç°å®‰å…¨é«˜æ•ˆçš„å¯¼èˆªä¸ºç›®çš„ï¼Œå°†è§„åˆ’ç»“æœè¾“å‡ºç»™actuationæ¨¡å—ã€‚å…¶ä¸­computingæ¨¡å—ä¸»è¦åˆ†ä¸ºä¸‰ä¸ªå°æ¨¡å—ã€‚â‘  perceptionï¼ˆæ„ŸçŸ¥æ¨¡å—ï¼‰ï¼Œè¿™éƒ¨åˆ†è¦å¤„ç†localizationï¼ˆé€šè¿‡è½¦è¾†å½“å‰é‡‡é›†ä¼ æ„Ÿå™¨æ•°æ®å’Œå·²æœ‰åœ°å›¾è¿›è¡Œè‡ªèº«å®šä½ï¼Œè‹¥æ— åœ°å›¾éœ€è¦é€šè¿‡SLAMæ„å»ºåœ°å›¾ï¼‰ï¼Œç„¶ådetectionæ¨¡å—è´Ÿè´£æ£€æµ‹å‘¨å›´ä¸è½¦è¾†æœ‰åœºæ™¯äº¤äº’çš„éè‡ªèº«ä¸ªä½“ï¼ˆè½¦è¾†ã€è¡Œäººç­‰ï¼‰ï¼Œpredictionæ¨¡å—ä¼šå¯¹æ£€æµ‹åˆå¾—ç‰©ä½“è¿›è¡Œæœªæ¥é¢„æµ‹ä¼°è®¡ï¼Œä»¥ä¾¿æå‰è§„åˆ’é˜²æ­¢ç¢°æ’ã€‚â‘¡ decisionï¼ˆå†³ç­–æ¨¡å—ï¼‰ï¼Œæ ¹æ®ä¹‹å‰æ„ŸçŸ¥çš„ç»“æœï¼ŒAutowareå†³ç­–ä¸€ä¸ªç”±æœ‰é™çŠ¶æ€æœºè¡¨ç¤ºçš„é©¾é©¶è¡Œä¸ºï¼Œä»¥ä¾¿å¯ä»¥é€‰æ‹©é€‚å½“çš„è®¡åˆ’åŠŸèƒ½ã€‚å½“å‰çš„å†³ç­–æ–¹æ³•æ˜¯åŸºäºè§„åˆ™çš„ç³»ç»Ÿã€‚â‘¢ planningï¼ˆè§„åˆ’æ¨¡å—ï¼‰ï¼Œä¸»è¦æ˜¯æ ¹æ®å†³ç­–å’Œèµ·å§‹ç‚¹å’Œç›®æ ‡ç‚¹ï¼Œé‡‡ç”¨missionå’Œmotionæ¨¡å—å¯ä»¥è®¡ç®—å‡ºä¸€æ¡kinodynamicçš„è·¯å¾„ã€‚â‘£ actuationæ¨¡å—ï¼Œè¡¨ç¤ºé©±åŠ¨å™¨æ¨¡å—ï¼Œå¦‚YMCé©±åŠ¨å™¨ç­‰ï¼Œæ¥æ”¶planningæ¨¡å—å‡ºæ¥çš„è§„åˆ’ç»“æœï¼Œé€šè¿‡é©±åŠ¨å™¨å®ç°é©±åŠ¨æ§åˆ¶ã€‚ â€‹ å…¶å„ä¸ªæ¨¡å—éƒ½æœ‰å¯¹åº”ä¸åŒçš„rosèŠ‚ç‚¹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š 1.3 Autowareå®‰è£…æŒ‡å—1.3.1 ç³»ç»Ÿç‰ˆæœ¬åŠé©±åŠ¨ç¡®è®¤â€‹ è¯·ç¡®è®¤ç³»ç»Ÿç‰ˆæœ¬ä¸ºUbuntu18.04ï¼Œå¹¶æ­£ç¡®å®‰è£…è‹±ä¼Ÿè¾¾æ˜¾å¡é©±åŠ¨460ç‰ˆæœ¬ã€CUDAç‰ˆæœ¬10.0ã€cuDNNç‰ˆæœ¬10.0ã€‚ç³»ç»ŸåŠé©±åŠ¨å®‰è£…æ•™ç¨‹ä¸å†èµ˜è¿°ã€‚ 1.3.2 å®‰è£…caffeâ‘  caffeç›¸å…³ä¾èµ–åŒ…123$ sudo apt install -y libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler$ sudo apt install -y --no-install-recommends libboost-all-dev$ sudo apt install -y libgflags-dev libgoogle-glog-dev liblmdb-dev â‘¡ å®‰è£…caffe1sudo apt install caffe-cuda 1.3.3 å®‰è£…eigen3.3.712345$ cd &amp;&amp; wget http://bitbucket.org/eigen/eigen/get/3.3.7.tar.gz$ mkdir eigen &amp;&amp; tar --strip-components=1 -xzvf 3.3.7.tar.gz -C eigen$ cd eigen &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make$ sudo make install$ cd &amp;&amp; rm -rf 3.3.7.tar.gz &amp;&amp; rm -rf eigen 1.3.4 å®‰è£…Autoware 1.14â‘  å®‰è£…Ubuntu 18.04 ä¾èµ–1234$ sudo apt update$ sudo apt install -y python-catkin-pkg python-rosdep ros-$ROS_DISTRO-catkin$ sudo apt install -y python3-pip python3-colcon-common-extensions python3-setuptools python3-vcstool$ pip3 install -U setuptools â‘¡ å»ºç«‹workspace12$ mkdir -p autoware.ai/src$ cd autoware.ai â‘¢ ä¸‹è½½Autoware 1.1412$ wget -O autoware.ai.repos &quot;https://gitlab.com/autowarefoundation/autoware.ai/autoware/raw/1.14.0/autoware.ai.repos?inline=false&quot;$ vcs import src &lt; autoware.ai.repos â‘£ å®‰è£…ROSä¾èµ–12$ rosdep update$ rosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO â‘¤ ç¼–è¯‘ç¯å¢ƒ1$ AUTOWARE_COMPILE_WITH_CUDA=1 colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release 1.4 å‚è€ƒæ–‡çŒ®[1] Autoware Foundation. Autoware-Documentation[DB/OL]. [2023-02-13]. https://autowarefoundation.github.io/autoware-documentation/main/. [2] Github-Computing Platforms Federated Laboratory. Autoware Manuals[DB/OL]. [2020-05-02]. https://github.com/CPFL/Autoware-Manuals. äºŒã€Autoware æ„ŸçŸ¥æ¨¡å—è§£æâ€‹ Autowareæ˜¯ä¸€ä¸ªå®Œæ•´ã€ç³»ç»ŸåŒ–çš„è‡ªåŠ¨é©¾é©¶å¹³å°ï¼Œå…¶ä¸­ï¼Œcore_perceptionæ¨¡å—åŒ…å«äº†è§†è§‰å’Œç‚¹äº‘æ„ŸçŸ¥å¤„ç†ç®—æ³•çš„å®ç°è¿‡ç¨‹ã€‚æœ¬èŠ‚ä»¥è§†è§‰æ„ŸçŸ¥ç®—æ³•YoloV3ã€voxel grid filteråŠring ground filterç‚¹äº‘å¤„ç†ç®—æ³•ä¸ºä¾‹ç®€è¦ä»‹ç»Autowareæ„ŸçŸ¥ç›¸å…³ç®—æ³•åŸç†åŠä»£ç å®ç°è¿‡ç¨‹ï¼Œæ¢³ç†ç›¸å…³æ¡†æ¶åŠé€»è¾‘ã€‚ 2.1 åŸºäºDarknetçš„Yolov3å›¾åƒè¯†åˆ«â€‹ Yoloçš„å…¨ç§°æ˜¯You Only Look Onceï¼ŒæŒ‡åªéœ€è¦æµè§ˆä¸€æ¬¡å°±å¯ä»¥è¯†åˆ«å‡ºå›¾ä¸­çš„ç‰©ä½“çš„ç±»åˆ«å’Œä½ç½®ã€‚Yoloç®—æ³•æ˜¯ä¸€ç§one-stageçš„ç›®æ ‡æ£€æµ‹ç®—æ³•ï¼Œä¸two-stageç›®æ ‡æ£€æµ‹ç®—æ³•ï¼ˆå¦‚R-CNNç³»åˆ—ï¼‰çš„ä¸»è¦åŒºåˆ«åœ¨äºtwo-stageç®—æ³•éœ€è¦å…ˆç”Ÿæˆproposal(ä¸€ä¸ªæœ‰å¯èƒ½åŒ…å«å¾…æ£€ç‰©ä½“çš„é¢„é€‰æ¡†)ï¼Œç„¶åè¿›è¡Œç»†ç²’åº¦çš„ç‰©ä½“æ£€æµ‹ã€‚è€Œone-stageç®—æ³•ä¼šç›´æ¥åœ¨ç½‘ç»œä¸­æå–ç‰¹å¾æ¥é¢„æµ‹ç‰©ä½“åˆ†ç±»å’Œä½ç½®ã€‚two-stageç®—æ³•é€Ÿåº¦ç›¸å¯¹è¾ƒæ…¢ä½†æ˜¯å‡†ç¡®ç‡é«˜ï¼Œone-stageç®—æ³•å‡†ç¡®ç‡æ²¡æœ‰two-stageç®—æ³•é«˜ä½†æ˜¯é€Ÿåº¦è¾ƒå¿«ã€‚ â€‹ Yoloç³»åˆ—ç®—æ³•å°†å›¾ç‰‡åˆ’åˆ†æˆè‹¥å¹²ä¸ªç½‘æ ¼ï¼Œå†åŸºäºanchoræœºåˆ¶ç”Ÿæˆå…ˆéªŒæ¡†ï¼Œåªç”¨ä¸€æ­¥å°±ç”Ÿæˆæ£€æµ‹æ¡†ï¼Œè¿™ç§æ–¹æ³•å¤§å¤§æå‡äº†ç®—æ³•çš„é¢„æµ‹é€Ÿåº¦ï¼ŒYOLOv3çš„è®ºæ–‡äº2018å¹´å‘è¡¨åœ¨CVPRä¸Šã€‚æ•´ä¸ªæ¡†æ¶å¯åˆ’åˆ†ä¸º3ä¸ªéƒ¨åˆ†ï¼šåˆ†åˆ«ä¸ºDarknet-53ç»“æ„(ä¸‹å›¾Backboneéƒ¨åˆ†)ã€ç‰¹å¾å±‚èåˆç»“æ„(ä¸‹å›¾é»„è‰²æ¢¯å½¢concatéƒ¨åˆ†)ã€ä»¥åŠåˆ†ç±»æ£€æµ‹ç»“æ„(ä¸‹å›¾æœªç”»å‡º)ã€‚ â€‹ ä»ç½‘ç»œç»“æ„çš„è¾“å…¥è¯´èµ·ï¼Œç»™ä¸€å¼ å›¾åƒï¼Œè¾“å…¥åˆ°Darkenet-53ç½‘ç»œç»“æ„ï¼Œè¿›è¡Œä¸€ç³»åˆ—çš„å·ç§¯ä»¥åŠæ®‹å·®ç½‘ç»œï¼Œåˆ†åˆ«å¾—åˆ°åŸå›¾åƒ1/8ã€1/16ã€1/32çš„ç‰¹å¾å›¾ï¼ˆå³feature mapï¼‰ï¼Œè¿™ä¸ªè¿‡ç¨‹å°±æ˜¯æ‰€è°“çš„ç‰¹å¾æå–è¿‡ç¨‹ã€‚åœ¨ä¸Šå›¾ä¹Ÿå¯ä»¥çœ‹åˆ°ç»è¿‡Darkenet-53ç½‘ç»œä¹‹åæœ‰3ä¸ªåˆ†æ”¯ï¼Œåˆ†åˆ«å¯¹åº”çš„å°±æ˜¯3ä¸ªä¸åŒå°ºå¯¸çš„feature mapã€‚åˆ’åˆ†ä¸åŒå°ºå¯¸çš„feature mapç‰¹å¾å›¾ï¼Œæ˜¯ä¸ºäº†è®©YOLOç®—æ³•èƒ½é€‚åº”ä¸åŒå¤§å°ç›®æ ‡çš„æ£€æµ‹ï¼›æ¯”å¦‚ï¼š19Ã—19Ã—255çš„ç‰¹å¾å›¾ï¼Œå…¶ä¸€ä¸ªç‰¹å¾ç‚¹å°±å¯¹åº”åŸå›¾å¤§å°ä¸º32Ã—32ï¼ˆ608/19=32ï¼‰çš„å—çš„æ£€æµ‹ï¼Œé€‚åˆäºå¤§ç›®æ ‡çš„æ£€æµ‹ï¼›è€Œ76Ã—76Ã—255çš„ç‰¹å¾å›¾ï¼Œå…¶ä¸€ä¸ªç‰¹å¾ç‚¹å¯¹åº”åŸå›¾å¤§å°ä¸º8Ã—8ï¼ˆ608/76ï¼‰çš„å—çš„æ£€æµ‹ã€‚é€‚åˆä¸å°ç›®æ ‡çš„æ£€æµ‹ï¼ŒåŒç†38Ã—38Ã—255é€‚åˆäºä¸­ç›®æ ‡çš„æ£€æµ‹ã€‚ä½†ç”±äºæå–çš„è¿™äº›ç‰¹å¾æœ‰æ—¶ä¸èƒ½å……åˆ†çš„ååº”åŸå›¾ä¸­çš„ç›®æ ‡ä¿¡æ¯ã€‚æ‰€ä»¥æ¥ä¸‹æ¥éœ€è¦å°†3ä¸ªç‰¹å¾å›¾è¿›è¡Œç‰¹å¾èåˆï¼Œä»¥è·å¾—æ›´å¼ºçš„ç‰¹å¾è¡¨ç°åŠ›ï¼Œä»è€Œè¾¾åˆ°æ›´å¥½çš„æ•ˆæœï¼›å…¶ä¸­ç”±äºå°ºå¯¸ä¸ä¸€æ ·ï¼Œä¸­é—´éœ€è¦è¿›è¡Œä¸Šé‡‡æ ·ä»¥åŠä¸‹é‡‡æ ·ï¼ˆå…¶å®å°±æ˜¯å·ç§¯ï¼‰ï¼Œä½¿ç‰¹å¾å›¾å˜æˆç›¸åŒå¤§å°ï¼Œç„¶åè¿›è¡Œå †å ã€èåˆåŠç›¸åº”çš„å·ç§¯ç­‰æ“ä½œåï¼Œå¾—åˆ°æœ€ç»ˆçš„3ä¸ªç‰¹å¾å±‚ï¼Œå³ä¸Šå›¾ä¸­çš„19Ã—19Ã—255ï¼ˆY1ï¼‰ã€38Ã—38Ã—255ï¼ˆY2ï¼‰ã€76Ã—76Ã—255ï¼ˆY3ï¼‰ï¼Œè¿™3ä¸ªç‰¹å¾å›¾æ°å¥½åˆ†åˆ«ä¸ºåŸå›¾åƒxçš„1/32ã€1/16ã€1/8ã€‚ 2.1.1 ä¾èµ–é¡¹ NVIDIA GPU é©±åŠ¨ã€ CUDA åŸºäºCOCOæ•°æ®é›†é¢„è®­ç»ƒçš„YOLOv3æƒé‡æ–‡ä»¶è¯¦æƒ…è§ : YOLO website. weightsæ–‡ä»¶éœ€æ”¾ç½®åœ¨ vision_darknet_detect/darknet/data/ ç›®å½•ä¸‹ 2.1.2 ç¨‹åºè·¯å¾„12345678//æºä»£ç è·¯å¾„~/autoware.ai/src/autoware/core_perception/vision_darknet_detect/src/vision_darknet_detect.cpp//launchæ–‡ä»¶è·¯å¾„~/autoware.ai/src/autoware/core_perception/vision_darknet_detect/launch/vision_yolo3_detect.launch//è®­ç»ƒnamesæ–‡ä»¶~/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/cfg/coco.names 2.1.3 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch vision_darknet_detect vision_yolo3_detect.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹Computing é€‰é¡¹å¡ -&gt; Detection/ vision_detector -&gt; vision_darknet_detectï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®å’Œæ–‡ä»¶è·¯å¾„ç­‰å‚æ•°ã€‚ 2.1.4 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ score_threshold Double Detections with a confidence value larger than this value will be displayed. Default 0.5. nms_threshold Double Non-Maximum suppresion area threshold ratio to merge proposals. Default 0.45. network_definition_file String Network architecture definition configuration file. Default yolov3.cfg. pretrained_model_file String Path to pretrained model. Default yolov3.weights. camera_id String Camera workspace. Default /. image_src String Image source topic. Default /image_raw. names_file String Path to pretrained model. Default coco.names. 2.1.5 è®¢é˜…è¯é¢˜å Topic æ¶ˆæ¯ç±»å‹ è¯´æ˜ /image_raw sensor_msgs/Image è¦æ£€æµ‹çš„åŸå§‹å›¾åƒæµ /config/Yolo3 autoware_config_msgs/ConfigSSD é˜ˆå€¼çš„é…ç½®è°ƒæ•´å‚æ•° 2.1.6 å‘å¸ƒè¯é¢˜å Topic æ¶ˆæ¯ç±»å‹ è¯´æ˜ /detection/vision_objects autoware_msgs::DetectedObjectArray æ£€æµ‹åˆ°å¯¹è±¡çš„è¾¹ç•Œæ¡†åæ ‡ 2.1.7 ä»£ç æ³¨è§£â‘  Yolo3DetectorNodeç±»â€‹ å£°æ˜äº†ROSç›¸å…³èŠ‚ç‚¹åŠå‚æ•°ç±»å‹ï¼Œå®šä¹‰ç›®æ ‡æ£€æµ‹æ‰€éœ€å…³é”®æ–¹æ³•ã€‚æœ€ååœ¨å…¬æœ‰åŸŸä¸­æ‰§è¡ŒRunã€‚ 123456789101112131415161718192021222324252627282930class Yolo3DetectorNode { //å®šä¹‰ROSä¸­ç›¸åº”èŠ‚ç‚¹ ros::Subscriber subscriber_image_raw_; ros::Subscriber subscriber_yolo_config_; ros::Publisher publisher_objects_; ros::NodeHandle node_handle_; //å®šä¹‰ç±»æ–¹æ³•Yolo3Detector darknet::Yolo3Detector yolo_detector_; image darknet_image_ = {}; //å®šä¹‰å‚æ•°ç±»å‹ float score_threshold_; float nms_threshold_; double image_ratio_; uint32_t image_top_bottom_border_; uint32_t image_left_right_border_; std::vector&lt;cv::Scalar&gt; colors_; std::vector&lt;std::string&gt; custom_names_; bool use_coco_names_; //å®šä¹‰ç›®æ ‡æ£€æµ‹ä¸­æ‰€ä½¿ç”¨çš„æ–¹æ³• void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::DetectedObjectArray&amp; out_message); void rgbgr_image(image&amp; im); image convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg); void image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message); void config_cb(const autoware_config_msgs::ConfigSSD::ConstPtr&amp; param); std::vector&lt;std::string&gt; read_custom_names_file(const std::string&amp; in_path);//å…¬æœ‰åŒ–å‚æ•°åŸŸpublic: void Run();}; â‘¡ convert_rect_to_image_objå‡½æ•°â€‹ å¯¹çŸ©å½¢æ¡†é¢„æµ‹ç»“æœè¿›è¡Œå¤„ç†ï¼ŒåŒ…æ‹¬åæ ‡å€¼è½¬æ¢ã€ç›®æ ‡ç±»åˆ«æ ‡ç­¾è·å–ç­‰ï¼Œç„¶åå‘å¸ƒæ£€æµ‹ç»“æœã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041void Yolo3DetectorNode::convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::DetectedObjectArray&amp; out_message){ for (unsigned int i = 0; i &lt; in_objects.size(); ++i) { { autoware_msgs::DetectedObject obj; //yolov3æ£€æµ‹ç®—æ³•ä¸­å¯¹ç›®æ ‡çŸ©å½¢æ¡†å››ä¸ªåæ ‡å€¼çš„å¤„ç† obj.x = (in_objects[i].x /image_ratio_) - image_left_right_border_/image_ratio_; obj.y = (in_objects[i].y /image_ratio_) - image_top_bottom_border_/image_ratio_; obj.width = in_objects[i].w /image_ratio_; obj.height = in_objects[i].h /image_ratio_; if (in_objects[i].x &lt; 0) obj.x = 0; if (in_objects[i].y &lt; 0) obj.y = 0; if (in_objects[i].w &lt; 0) obj.width = 0; if (in_objects[i].h &lt; 0) obj.height = 0; //ç›®æ ‡ç±»å‹åˆ†æ•° obj.score = in_objects[i].score; //ä½¿ç”¨Cocoæ•°æ®é›†æ—¶ï¼Œå°†æ£€æµ‹ç»“æœä¸ç›¸åº”çš„ç±»åˆ«æ ‡ç­¾å¯¹åº” //GetClassString()æ–¹æ³•ç”¨äºæ˜ å°„ç›®æ ‡ç±»åˆ«æ ‡ç­¾æ–¹æ³• if (use_coco_names_) { obj.label = in_objects[i].GetClassString(); } else { if (in_objects[i].class_type &lt; custom_names_.size()) obj.label = custom_names_[in_objects[i].class_type]; else obj.label = &quot;unknown&quot;; } obj.valid = true; //å‘é€æ£€æµ‹ç»“æœ out_message.objects.push_back(obj); } }} â‘¢ rgbgr_imageå‡½æ•°â€‹ rgbgr_imageä¸»è¦ç”¨äºå¯¹è¾“å…¥å›¾ç‰‡è¿›è¡Œé€šé“å˜æ¢å¤„ç†ï¼Œä»¥é€‚åº”ç½‘ç»œçš„è¾“å…¥ç±»å‹ã€‚ 12345678910void Yolo3DetectorNode::rgbgr_image(image&amp; im){ int i; for(i = 0; i &lt; im.w*im.h; ++i) { float swap = im.data[i]; im.data[i] = im.data[i+im.w*im.h*2]; im.data[i+im.w*im.h*2] = swap; }} â‘£ convert_ipl_to_imageå‡½æ•°â€‹ convert_ipl_to_imageå‡½æ•°ä¸»è¦å¯¹è¾“å…¥å›¾ç‰‡çš„å°ºå¯¸è¿›è¡Œå¤„ç†ä»¥é€‚åº”ç½‘ç»œè¾“å…¥å¤§å°ã€‚å½“å›¾ç‰‡å°ºå¯¸ä¸è¾“å…¥å¤§å°ä¸ç¬¦ï¼Œè®¡ç®—æ¯”å€¼å¹¶å°†å…¶ä½œä¸ºç¼©æ”¾å› å­å¯¹å›¾ç‰‡è¿›è¡Œè£å‰ªå¡«å……å¤„ç†ï¼Œæœ€åè¿›è¡Œå½’ä¸€åŒ–ä»¥æé«˜ç½‘ç»œè®­ç»ƒçš„æ•°å€¼ç¨³å®šæ€§ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354image Yolo3DetectorNode::convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg){ //cv_bridgeå®šä¹‰opencvç±»å‹çš„cv_image cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(msg, &quot;bgr8&quot;); cv::Mat mat_image = cv_image-&gt;image; int network_input_width = yolo_detector_.get_network_width(); int network_input_height = yolo_detector_.get_network_height(); int image_height = msg-&gt;height, image_width = msg-&gt;width; IplImage ipl_image; cv::Mat final_mat; if (network_input_width!=image_width || network_input_height != image_height) { //ç½‘ç»œè¾“å…¥å’Œå›¾åƒä¸ç¬¦æ—¶ï¼Œè®¡ç®—ä¸¤è€…æ¯”å€¼ image_ratio_ = (double ) network_input_width / (double)mat_image.cols; //å¯¹å›¾åƒè¿›è¡Œresizeï¼Œç¼©æ”¾å› å­ä¸ºç½‘ç»œè¾“å…¥ä¸å›¾åƒçš„æ¯”å€¼ cv::resize(mat_image, final_mat, cv::Size(), image_ratio_, image_ratio_); //å¡«å…… image_top_bottom_border_ = abs(final_mat.rows-network_input_height)/2; image_left_right_border_ = abs(final_mat.cols-network_input_width)/2; cv::copyMakeBorder(final_mat, final_mat, image_top_bottom_border_, image_top_bottom_border_, image_left_right_border_, image_left_right_border_, cv::BORDER_CONSTANT, cv::Scalar(0,0,0)); } else final_mat = mat_image; ipl_image = final_mat; unsigned char *data = (unsigned char *)ipl_image.imageData; int h = ipl_image.height; int w = ipl_image.width; int c = ipl_image.nChannels; int step = ipl_image.widthStep; int i, j, k; image darknet_image = make_image(w, h, c); //å¡«å……åçš„å›¾åƒè¿›è¡Œå½’ä¸€åŒ– for(i = 0; i &lt; h; ++i){ for(k= 0; k &lt; c; ++k){ for(j = 0; j &lt; w; ++j){ darknet_image.data[k*w*h + i*w + j] = data[i*step + j*c + k]/255.; } } } rgbgr_image(darknet_image); return darknet_image;} â‘¤ image_callbackå‡½æ•°â€‹ image_callbackå‡½æ•°é€šè¿‡convert_ipl_to_imageå¯¹å›¾ç‰‡é¢„å¤„ç†ï¼Œç„¶ååˆ©ç”¨convert_rect_to_image_objå°†æ£€æµ‹ç»“æœè¿›ä¸€æ­¥è½¬æ¢ä¸ºå…·ä½“çš„ç›®æ ‡ä¿¡æ¯å¹¶å‘å¸ƒã€‚ 123456789101112131415void Yolo3DetectorNode::image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message){ std::vector&lt; RectClassScore&lt;float&gt; &gt; detections; //è°ƒç”¨convert_ipl_to_imageå¯¹å›¾ç‰‡resize darknet_image_ = convert_ipl_to_image(in_image_message); //ä»¥resizeåçš„å›¾åƒä½œä¸ºyolov3æ£€æµ‹å™¨çš„è¾“å…¥ detections = yolo_detector_.detect(darknet_image_); autoware_msgs::DetectedObjectArray output_message; output_message.header = in_image_message-&gt;header; //è°ƒç”¨convert_rect_to_image_obj()å°†æ£€æµ‹ç»“æœè½¬æ¢ä¸ºç›¸åº”çš„ç›®æ ‡ä¿¡æ¯ convert_rect_to_image_obj(detections, output_message); //å‘å¸ƒæ£€æµ‹ç»“æœ publisher_objects_.publish(output_message); free(darknet_image_.data);} â‘¥ read_custom_names_fileå‡½æ•°â€‹ read_custom_names_fileå‡½æ•°ä¸»è¦ç”¨äºè·å–æ–‡ä»¶è·¯å¾„ã€æ–‡ä»¶åç­‰ä¿¡æ¯ 1234567891011121314std::vector&lt;std::string&gt; Yolo3DetectorNode::read_custom_names_file(const std::string&amp; in_names_path){ //æ–‡ä»¶è·¯å¾„ std::ifstream file(in_names_path); std::string str; //æ–‡ä»¶å std::vector&lt;std::string&gt; names; while (std::getline(file, str)) { names.push_back(str); std::cout &lt;&lt; str &lt;&lt; std::endl; } return names;} â‘¦ Runå‡½æ•°â€‹ é¦–å…ˆå£°æ˜äº†ROSå‡½æ•°å‘½åç©ºé—´ï¼Œå¹¶é€šè¿‡èŠ‚ç‚¹ååˆ¤æ–­æ¥æ¥å—ç›¸åº”çš„å‚æ•°ä¿¡æ¯ï¼Œç„¶åè°ƒç”¨yolo_detectoræ£€æµ‹å™¨é€šè¿‡é…ç½®æ–‡ä»¶ã€é¢„è®­ç»ƒæ¨¡å‹æ–‡ä»¶ã€åƒç´ å‡å€¼ç­‰å‚æ•°æ¥åˆå§‹åŒ–yolov3æ¨¡å‹è¿›è¡Œç›®æ ‡æ£€æµ‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void Yolo3DetectorNode::Run(){ //ROSæ„é€ å‡½æ•°æŒ‡å®šå‘½åç©ºé—´ ros::NodeHandle private_node_handle(&quot;~&quot;); //å£°æ˜æ ‡å‡†å­—ç¬¦å˜é‡æ¥å—å›¾ç‰‡ std::string image_raw_topic_str; if (private_node_handle.getParam(&quot;image_raw_node&quot;, image_raw_topic_str)) { ROS_INFO(&quot;Setting image node to %s&quot;, image_raw_topic_str.c_str()); } else { ROS_INFO(&quot;No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC&quot;); image_raw_topic_str = &quot;/image_raw&quot;; } //å£°æ˜æ ‡å‡†å­—ç¬¦å˜é‡ï¼Œæ¥æ”¶ç½‘ç»œé…ç½®æ–‡ä»¶ std::string network_definition_file; //å£°æ˜æ ‡å‡†å­—ç¬¦å˜é‡ï¼Œæ¥æ”¶é¢„è®­ç»ƒæ¨¡å‹æ–‡ä»¶ std::string pretrained_model_file, names_file; //åˆ¤æ–­æ˜¯å¦æœ‰ç½‘ç»œé…ç½®æ–‡ä»¶èŠ‚ç‚¹å if (private_node_handle.getParam(&quot;network_definition_file&quot;, network_definition_file)) { ROS_INFO(&quot;Network Definition File (Config): %s&quot;, network_definition_file.c_str()); } else { ROS_INFO(&quot;No Network Definition File was received. Finishing execution.&quot;); return; } //åˆ¤æ–­æ˜¯å¦æœ‰é¢„è®­ç»ƒæ¨¡å‹èŠ‚ç‚¹å if (private_node_handle.getParam(&quot;pretrained_model_file&quot;, pretrained_model_file)) { ROS_INFO(&quot;Pretrained Model File (Weights): %s&quot;, pretrained_model_file.c_str()); } else { ROS_INFO(&quot;No Pretrained Model File was received. Finishing execution.&quot;); return; } if (private_node_handle.getParam(&quot;names_file&quot;, names_file)) { ROS_INFO(&quot;Names File: %s&quot;, names_file.c_str()); use_coco_names_ = false; custom_names_ = read_custom_names_file(names_file); } else { ROS_INFO(&quot;No Names file was received. Using default COCO names.&quot;); use_coco_names_ = true; } //å®šä¹‰ç§æœ‰èŠ‚ç‚¹å‚æ•°score_thresholdï¼Œé˜ˆå€¼ä¸º0.5 private_node_handle.param&lt;float&gt;(&quot;score_threshold&quot;, score_threshold_, 0.5); ROS_INFO(&quot;[%s] score_threshold: %f&quot;,__APP_NAME__, score_threshold_); //å®šä¹‰ç§æœ‰èŠ‚ç‚¹å‚æ•°nms_thresholdï¼Œé˜ˆå€¼ä¸º0.45 private_node_handle.param&lt;float&gt;(&quot;nms_threshold&quot;, nms_threshold_, 0.45); ROS_INFO(&quot;[%s] nms_threshold: %f&quot;,__APP_NAME__, nms_threshold_); //è°ƒç”¨yolo_detector_å‡½æ•°ï¼Œåˆå§‹åŒ–æ¨¡å‹ ROS_INFO(&quot;Initializing Yolo on Darknet...&quot;); yolo_detector_.load(network_definition_file, pretrained_model_file, score_threshold_, nms_threshold_); ROS_INFO(&quot;Initialization complete.&quot;); #if (CV_MAJOR_VERSION &lt;= 2) cv::generateColors(colors_, 80); #else generateColors(colors_, 80); #endif publisher_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;(&quot;/detection/image_detector/objects&quot;, 1); ROS_INFO(&quot;Subscribing to... %s&quot;, image_raw_topic_str.c_str()); subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;Yolo3DetectorNode::image_callback, this); std::string config_topic(&quot;/config&quot;); config_topic += &quot;/Yolo3&quot;; subscriber_yolo_config_ = node_handle_.subscribe(config_topic, 1, &amp;Yolo3DetectorNode::config_cb, this); ROS_INFO_STREAM( __APP_NAME__ &lt;&lt; &quot;&quot; ); ros::spin(); ROS_INFO(&quot;END Yolo&quot;);} 2.2 voxel_grid_filterç‚¹äº‘é™é‡‡æ ·ç¨‹åºæ³¨è§£2.2.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch points_downsampler points_downsample.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹Sensing é€‰é¡¹å¡ -&gt; Points Downsampler -&gt; voxel_grid_filterï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 2.2.2 ç‚¹äº‘æ¶ˆæ¯æ•°æ®ç»“æ„æ¿€å…‰é›·è¾¾é›·è¾¾åæ ‡ç³»åç§°ï¼švelodyne ç‚¹äº‘è¯é¢˜åï¼š/points_raw æ¶ˆæ¯ç±»å‹ä¸ºsensor_msgs/PointCloud2ï¼Œä¸‹é¢ä¸ºæ¶ˆæ¯ç±»å‹çš„è¯¦ç»†ä»‹ç»ã€‚ 123456789101112header: // ç‚¹äº‘å¤´ seq: // åºåˆ—å· stamp: // è¯é¢˜æ—¶é—´æˆ³ frame_id: // ç‚¹äº‘åæ ‡ç³»åç§°height: // ç‚¹äº‘çš„äºŒç»´ç»“æ„ã€‚å¦‚æœäº‘æ˜¯æ— åºçš„ï¼Œåˆ™é«˜åº¦ä¸º1ï¼Œå®½åº¦ä¸ºç‚¹äº‘çš„é•¿åº¦ã€‚width: // ç‚¹äº‘çš„é•¿åº¦fields: // æè¿°äºŒè¿›åˆ¶æ•°æ®blobä¸­çš„é€šé“åŠå…¶å¸ƒå±€ã€‚is_bigendian: // æ•°æ®å­˜å‚¨æ–¹å¼ï¼ŒåŒ…æ‹¬å¤§ç«¯ä¸å°ç«¯point_step: // ä¸€ä¸ªç‚¹å çš„å­—èŠ‚æ•° row_step: // ä¸€è¡Œçš„é•¿åº¦å ç”¨çš„å­—èŠ‚æ•°data:[] // ç‚¹äº‘æ•°æ®is_dense: // æœ‰æ²¡æœ‰éæ³•æ•°æ®ç‚¹ 2.2.3 ç¨‹åºè·¯å¾„12345// æºä»£ç è·¯å¾„~/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.cpp// launchå¯åŠ¨æ–‡ä»¶è·¯å¾„~/autoware.ai/src/autoware/core_perception/points_downsampler/launch/points_downsample.launch 2.2.4 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ voxel_leaf_size int æ»¤æ³¢å™¨å¤„ç†æ—¶é‡‡ç”¨çš„ä½“ç´ å¤§å° measurement_range double æµ‹é‡è·ç¦» output_log bool æ˜¯å¦è¾“å‡ºlog points_topic string ç‚¹äº‘æ¥æ”¶è¯é¢˜å 2.2.5 è®¢é˜…è¯é¢˜å è¯é¢˜å æ¶ˆæ¯ç±»å‹ /config/voxel_grid_filter autoware_config_msgs/ConfigVoxelGridFilter /points_raw sensor_msgs/PointCloud2 2.2.6 å‘å¸ƒè¯é¢˜å è¯é¢˜å æ¶ˆæ¯ç±»å‹ /filtered_points sensor_msgs::PointCloud2 /points_downsampler_info points_downsampler::PointsDownsamplerInfo 2.2.7 ä»£ç æ³¨è§£â‘  mainå‡½æ•°â€‹ mainå‡½æ•°ä¸»è¦åˆå§‹åŒ–ROSï¼Œè®¢é˜…ç‚¹äº‘åŠå‚æ•°ä¿¡æ¯ï¼Œåˆå§‹åŒ–å‘å¸ƒè€…ã€‚ä½¿ç”¨ä½“ç´ åŒ–ç½‘æ ¼æ–¹æ³•å®ç°é™é‡‡æ ·ï¼Œå³å‡å°‘ç‚¹çš„æ•°é‡ï¼Œå‡å°‘ç‚¹äº‘æ•°æ®ï¼Œå¹¶åŒæ—¶ä¿æŒç‚¹äº‘çš„å½¢çŠ¶ç‰¹å¾ï¼Œåœ¨æé«˜é…å‡†ã€æ›²é¢é‡å»ºã€å½¢çŠ¶è¯†åˆ«ç­‰ç®—æ³•é€Ÿåº¦ä¸­éå¸¸å®ç”¨ã€‚PCLå®ç°çš„VoxelGridç±»é€šè¿‡è¾“å…¥çš„ç‚¹äº‘æ•°æ®åˆ›å»ºä¸€ä¸ªä¸‰ç»´ä½“ç´ æ …æ ¼ï¼ˆå¯æŠŠä½“ç´ æ …æ ¼æƒ³è±¡ä¸ºå¾®å°çš„ç©ºé—´ä¸‰ç»´ç«‹æ–¹ä½“çš„é›†åˆï¼‰ï¼Œç„¶ååœ¨æ¯ä¸ªä½“ç´ ï¼ˆå³ ä¸‰ç»´ç«‹æ–¹ä½“ï¼‰å†…ï¼Œç”¨ä½“ç´ ä¸­æ‰€æœ‰ç‚¹çš„é‡å¿ƒæ¥è¿‘ä¼¼æ˜¾ç¤ºä½“ç´ ä¸­å…¶ä»–ç‚¹ï¼Œè¿™æ ·è¯¥ä½“ç´ å°±å†…æ‰€æœ‰ç‚¹å°±ç”¨ä¸€ä¸ªé‡å¿ƒç‚¹æœ€ç»ˆè¡¨ç¤ºï¼Œå¯¹äºæ‰€æœ‰ä½“ç´ å¤„ç†åå¾—åˆ°è¿‡æ»¤åçš„ç‚¹äº‘ã€‚è¿™ç§æ–¹æ³•æ¯”ç”¨ä½“ç´ ä¸­å¿ƒæ¥é€¼è¿‘çš„æ–¹æ³•æ›´æ…¢ï¼Œä½†å®ƒå¯¹äºé‡‡æ ·ç‚¹å¯¹åº”æ›²é¢çš„è¡¨ç¤ºæ›´ä¸ºå‡†ç¡®ã€‚ 1234567891011121314151617181920212223242526272829303132int main(int argc, char** argv){ ros::init(argc, argv, &quot;voxel_grid_filter&quot;); ros::NodeHandle nh; ros::NodeHandle private_nh(&quot;~&quot;); //å‚æ•°æœåŠ¡å™¨è·å–æ¿€å…‰ç‚¹äº‘topicä»¥åŠæ˜¯å¦è¾“å‡ºlog private_nh.getParam(&quot;points_topic&quot;, POINTS_TOPIC); private_nh.getParam(&quot;output_log&quot;, _output_log); //è¾“å‡ºlog if(_output_log == true){ char buffer[80]; std::time_t now = std::time(NULL); std::tm *pnow = std::localtime(&amp;now); std::strftime(buffer,80,&quot;%Y%m%d_%H%M%S&quot;,pnow); filename = &quot;voxel_grid_filter_&quot; + std::string(buffer) + &quot;.csv&quot;; ofs.open(filename.c_str(), std::ios::app); } //å‚æ•°æœåŠ¡å™¨è·å–æ¿€å…‰æµ‹é‡è·ç¦»å‚æ•° private_nh.param&lt;double&gt;(&quot;measurement_range&quot;, measurement_range, MAX_MEASUREMENT_RANGE); // å‘å¸ƒé™é‡‡æ ·ç‚¹äº‘ã€info filtered_points_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/filtered_points&quot;, 10); points_downsampler_info_pub = nh.advertise&lt;points_downsampler::PointsDownsamplerInfo&gt;(&quot;/points_downsampler_info&quot;, 1000); // è®¢é˜…configã€ç‚¹äº‘è¯é¢˜ ros::Subscriber config_sub = nh.subscribe(&quot;config/voxel_grid_filter&quot;, 10, config_callback); ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback); ros::spin(); return 0;} â‘¡ config_callbackå‡½æ•°â€‹ config_callback å›è°ƒå‡½æ•°çš„å‚æ•°ä¸ºé™é‡‡æ ·å‚æ•°æ¶ˆæ¯(autoware_config_msgs::ConfigVoxelGridFilter.msgï¼‰ã€‚æ­¤å¤„æ¥æ”¶é™é‡‡æ ·å‚æ•°åŠæµ‹é‡è·ç¦»èŒƒå›´ä¿¡æ¯ã€‚ 12345static void config_callback(const autoware_config_msgs::ConfigVoxelGridFilter::ConstPtr&amp; input){ voxel_leaf_size = input-&gt;voxel_leaf_size; measurement_range = input-&gt;measurement_range;} â‘¢ scan_callbackå‡½æ•°â€‹ scan_callbackå‡½æ•°æ¥æ”¶æ¿€å…‰é›·è¾¾sensor_msgs::PointCloud2ç±»å‹æ¶ˆæ¯ï¼Œå¹¶å¯¹ç‚¹äº‘è¿›è¡Œé™é‡‡æ ·å¤„ç†ã€‚ â€‹ PCLç‚¹äº‘é™é‡‡æ ·åº“è¯¦æƒ…è¯·è§ï¼špcl::VoxelGridå®˜æ–¹æ–‡æ¡£web 1234567891011121314151617181920212223242526272829303132333435363738394041424344static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input){ // å£°æ˜pcl::PointCloud&lt;pcl::PointXYZI&gt;ç±»å‹çš„ç‚¹äº‘æ•°æ®ç”¨æ¥å‚¨å­˜æ¥æ”¶åˆ°çš„ç‚¹äº‘ pcl::PointCloud&lt;pcl::PointXYZI&gt; scan; // ç‚¹äº‘ç±»å‹è½¬æ¢sensor_msgs::PointCloud2 -&gt; pcl::PointCloud&lt;pcl::PointXYZI&gt; pcl::fromROSMsg(*input, scan); // åˆ¤æ–­è¦ä½¿ç”¨çš„æ¿€å…‰ç‚¹è·ç¦»æ˜¯å¦è¶…é™ï¼Œå¹¶ç§»é™¤è¶…é™çš„æ¿€å…‰ç‚¹ if(measurement_range != MAX_MEASUREMENT_RANGE){ scan = removePointsByRange(scan, 0, measurement_range); } pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan)); pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;()); sensor_msgs::PointCloud2 filtered_msg; filter_start = std::chrono::system_clock::now(); // è‹¥voxel_leaf_size &lt; 0.1ï¼Œvoxel_grid_filteræ— æ³•å®Œæˆé™é‡‡æ ·(PCLè§„èŒƒ) if (voxel_leaf_size &gt;= 0.1) { // ä½¿ç”¨VoxelGridæ»¤æ³¢å™¨å¯¹ç‚¹äº‘è¿›è¡Œé™é‡‡æ · pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter; voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size); voxel_grid_filter.setInputCloud(scan_ptr); voxel_grid_filter.filter(*filtered_scan_ptr); pcl::toROSMsg(*filtered_scan_ptr, filtered_msg); } else // è‹¥è®¾ç½®çš„voxel_leaf_size&lt;0.1ï¼Œæ— æ³•é™é‡‡æ ·ï¼Œç›´æ¥è¾“å‡ºåŸå§‹ç‚¹äº‘ { pcl::toROSMsg(*scan_ptr, filtered_msg); } // è®°å½•é™é‡‡æ ·ç»“æŸæ—¶é—´ filter_end = std::chrono::system_clock::now(); // å‘å¸ƒfiltered_msgé™é‡‡æ ·åç‚¹äº‘æ¶ˆæ¯ filtered_msg.header = input-&gt;header; filtered_points_pub.publish(filtered_msg); // å‘å¸ƒpoints_downsampler_info_msgé™é‡‡æ ·infoæ¶ˆæ¯ points_downsampler_info_msg.header = input-&gt;header; //...ï¼ˆä¸‹ç•¥ï¼‰} 2.3 ring_ground_filteråœ°é¢ç‚¹äº‘å»é™¤ç¨‹åºæ³¨è§£2.3.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch points_preprocessor ring_ground_filter.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹Sensing é€‰é¡¹å¡ -&gt; Points Preprocessor -&gt; ring_ground_filterï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 2.3.2 ç¨‹åºè·¯å¾„12345// æºä»£ç è·¯å¾„~/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/ring_ground_filter/ring_ground_filter.cpp// launchå¯åŠ¨æ–‡ä»¶è·¯å¾„~/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ring_ground_filter.launch 2.3.3 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ point_topic string ç‚¹äº‘æ¥æ”¶è¯é¢˜å remove_floor bool æ˜¯å¦ç§»é™¤åœ°é¢ sensor_model int æ¿€å…‰é›·è¾¾å‘å°„çº¿æŸæ•°é‡(16,32,64) sensor_height double æ¿€å…‰é›·è¾¾å®‰è£…é«˜åº¦ max_slope double ç¯å¢ƒåœ°é¢æœ€å¤§å¡åº¦ vertical_thres double éšœç¢ç‰©å’Œåœ°é¢çš„å·®å¼‚åº¦ï¼Œå¤§äºè¿™ä¸ªå€¼åˆ™è¢«è®¤ä¸ºæ˜¯éšœç¢ 2.3.4 è®¢é˜…è¯é¢˜å è¯é¢˜å æ¶ˆæ¯ç±»å‹ /points_raw sensor_msgs::PointCloud2 2.3.5 å‘å¸ƒè¯é¢˜å è¯é¢˜å æ¶ˆæ¯ç±»å‹ è¯´æ˜ /points_no_ground sensor_msgs::PointCloud2 å»é™¤åœ°é¢ç‚¹äº‘ /points_ground sensor_msgs::PointCloud2 åœ°é¢ç‚¹äº‘ 2.3.6 ä»£ç æ³¨è§£â‘  VelodyneCallbackå‡½æ•°â€‹ VelodyneCallbackå‡½æ•°ä¸»è¦æ¥æ”¶æ¥è‡ªæ¿€å…‰é›·è¾¾çš„ç‚¹äº‘ä¿¡æ¯ï¼Œå°†åŸå§‹ç‚¹äº‘æ•°æ®ä¼ ç»™FilterGroundå‡½æ•°å¤„ç†ï¼Œå¹¶å‘å¸ƒå¤„ç†å¥½çš„åœ°é¢ç‚¹äº‘ã€å»é™¤åœ°é¢ç‚¹äº‘æ•°æ®ã€‚ 12345678910111213141516171819202122void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg){ // å£°æ˜pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;ç±»å‹çš„ç‚¹äº‘æ•°æ® pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; vertical_points; pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; ground_points; vertical_points.header = in_cloud_msg-&gt;header; ground_points.header = in_cloud_msg-&gt;header; //åˆå§‹åŒ–æ¸…ç©º vertical_points.clear(); ground_points.clear(); // è°ƒç”¨FilterGroundå‡½æ•°è¿›è¡Œåœ°é¢è¿‡æ»¤ FilterGround(in_cloud_msg, vertical_points, ground_points); if (!floor_removal_) { vertical_points = *in_cloud_msg; } //å‘å¸ƒå¤„ç†å®Œæ¯•çš„ç‚¹äº‘ groundless_points_pub_.publish(vertical_points); ground_points_pub_.publish(ground_points);} â‘¡ FilterGroundå‡½æ•°â€‹ FilterGroundå‡½æ•°ç”¨äºå°†VelodyneCallbackä¼ å…¥çš„ç‚¹äº‘è¿›è¡Œåœ°é¢å»é™¤ï¼Œå¹¶è¾“å‡ºå¤„ç†å¥½çš„åœ°é¢ç‚¹äº‘ã€å»é™¤åœ°é¢ç‚¹äº‘æ•°æ®ã€‚é¦–å…ˆï¼Œå°†æ‰€æœ‰ä¸ç‚¹é›†å…·æœ‰ç›¸åŒæ°´å¹³è§’çš„ç‚¹åˆ†ç»„ï¼Œç„¶åé€ç‚¹é›†è¿›è¡Œè®¡ç®—ã€‚åœ¨æ¯ä¸ªç‚¹é›†ä¸­ï¼Œæ­¤ç®—æ³•åº”ç”¨ä¸¤æ­¥æ»¤æ³¢å™¨ï¼Œè¯¥æ»¤æ³¢å™¨ä½¿ç”¨ä¸¤ä¸ªè¿ç»­ç‚¹çš„è§’åº¦å’Œè·ç¦»æ¥åŒºåˆ†åœ°é¢ç‚¹äº‘å’Œå‚ç›´åœ°é¢(éšœç¢ç‰©)ç‚¹äº‘ã€‚ (1) åŸºäºè§’åº¦çš„æ»¤æ³¢å™¨ â€‹ ä¸¤æ­¥æ»¤æ³¢å™¨çš„ç¬¬ä¸€æ­¥æ˜¯åŸºäºè§’åº¦çš„æ»¤æ³¢å™¨ï¼Œè‹¥ä¸¤ä¸ªè¿ç»­ç‚¹çš„è§’åº¦å°äºè§’åº¦é˜ˆå€¼ï¼Œåˆ™å°†å…¶æ·»åŠ è¿›â€œå€™é€‰ç»„â€ï¼Œè®¡ç®—ä¸€ç›´æŒç»­åˆ°è§’åº¦å¤§äºé˜ˆå€¼ä¸ºæ­¢ï¼Œç„¶åæ£€æŸ¥â€œå€™é€‰ç»„â€çš„å¤§å°ã€‚å¦‚æœç‚¹æ•°è¶³å¤Ÿå¤§ï¼Œè¿™ä¸€ç‚¹é›†ä¸­çš„æ‰€æœ‰ç‚¹éƒ½ä¼šè¢«æ ‡è®°ä¸ºåœ°é¢ç‚¹äº‘ã€‚ (2) åŸºäºè·ç¦»çš„æ»¤æ³¢å™¨ â€‹ é€šè¿‡æ¯”è¾ƒè¿ç»­ç‚¹ä¸åŠ¨æ€é˜ˆå€¼ä¹‹é—´çš„è·ç¦»æ¥è¿‡æ»¤ä¸Šä¸€æ­¥çš„å…¶ä½™ç‚¹ã€‚å¦‚æœè¿™äº›ç‚¹å½¼æ­¤è¶³å¤Ÿæ¥è¿‘ï¼Œåˆ™å°†å…¶æ ‡è®°ä¸ºå‚ç›´åœ°é¢çš„ç‚¹äº‘(éšœç¢ç‰©ç‚¹äº‘)ï¼Œå…¶ä½™çš„ç‚¹è¢«æ ‡è®°ä¸ºåœ°é¢ç‚¹äº‘ã€‚ ç®—æ³•å…·ä½“æµç¨‹å›¾åŠä¼ªä»£ç è¯·è§ï¼šround_filterä»‹ç»pdf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg, pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points, pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points){ velodyne_pointcloud::PointXYZIR point; InitDepthMap(horizontal_res_); // è®¡ç®—ç‚¹äº‘é›†ä¸­æ¯ä¸ªç‚¹çš„è§’åº¦ï¼Œå¹¶ä½¿æ¯ä¸ªæ¿€å…‰ç‚¹å¯¹åº”åˆ°åˆ—è¡¨ä¸­çš„è¡Œå’Œåˆ— for (size_t i = 0; i &lt; in_cloud_msg-&gt;points.size(); i++) { double u = atan2(in_cloud_msg-&gt;points[i].y,in_cloud_msg-&gt;points[i].x) * 180/M_PI; if (u &lt; 0) { u = 360 + u; } int column = horizontal_res_ - (int)((double)horizontal_res_ * u / 360.0) - 1; int row = vertical_res_ - 1 - in_cloud_msg-&gt;points[i].ring; index_map_.at&lt;int&gt;(row, column) = i; } // æŒ‰æ¯æ¡æ¿€å…‰çº¿æŸä¸Šç‚¹çš„æ•°é‡éå†(ä»¥16çº¿é›·è¾¾ä¸ºä¾‹ï¼Œæ¯æ¡ç¯å½¢çº¿æœ‰1000ä¸ªæ¿€å…‰ç‚¹) for (int i = 0; i &lt; horizontal_res_; i++) { Label point_class[vertical_res_]; int point_index[vertical_res_]; int point_index_size = 0; double z_max = 0; double z_min = 0; double r_ref = 0; std::copy(class_label_, class_label_ + vertical_res_, point_class); // æŒ‰æ¿€å…‰çº¿æŸIDéå†æ¯çº¿æ¿€å…‰ for (int j = 0; j &lt; vertical_res_; j++) { // å¦‚æœå­˜åœ¨åˆ—è¡¨ä¸­(j,i)è¿™ä¸ªç‚¹ï¼Œä¸”æ­¤ç‚¹æ²¡æœ‰è¢«åˆ†ç±»åˆ°ä»»ä½•ä¸€ä¸ªç‚¹äº‘é›† if (index_map_.at&lt;int&gt;(j,i) &gt; -1 &amp;&amp; point_class[j] == UNKNOWN) { // è¯»å–æ¯ç‚¹xyzåæ ‡ double x0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].x; double y0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].y; double z0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].z; // è®¡ç®—è¯¥ç‚¹è·ç¦» double r0 = sqrt(x0*x0 + y0*y0); double r_diff = fabs(r0 - r_ref); if (r_diff &lt; radius_table_[j] || r_ref == 0) { r_ref = r0; if (z0 &gt; z_max || r_ref == 0) z_max = z0; if (z0 &lt; z_min || r_ref == 0) z_min = z0; point_index[point_index_size] = j; point_index_size++; } else { // åˆ¤æ–­ç‚¹äº‘é›†ç±»å‹ if (point_index_size &gt; 1 &amp;&amp; (z_max - z_min) &gt; vertical_thres_) { // ç‚¹äº‘ç±»å‹ä¸ºéåœ°é¢ç‚¹äº‘(éšœç¢ç‰©) for (int m = 0; m &lt; point_index_size; m++) { //...(ä¸‹ç•¥) point_class[point_index[m]] = VERTICAL; } // é‡ç½®point_index_size point_index_size = 0; } else // ç‚¹äº‘ç±»å‹ä¸ºåœ°é¢ç‚¹äº‘ { for (int m = 0; m &lt; point_index_size; m++) { //...(ä¸‹ç•¥) point_class[point_index[m]] = GROUND; } // é‡ç½®point_index_size point_index_size = 0; } r_ref = r0; z_max = z0; z_min = z0; point_index[point_index_size] = j; point_index_size++; } } // åˆ¤æ–­å‰©ä½™çš„ç‚¹äº‘ if (j == vertical_res_ - 1 &amp;&amp; point_index_size != 0) { // ç‚¹äº‘ç±»å‹ä¸ºéåœ°é¢ç‚¹äº‘(éšœç¢ç‰©) if (point_index_size &gt; 1 &amp;&amp; (z_max - z_min) &gt; vertical_thres_) { for (int m = 0; m &lt; point_index_size; m++) { //...(ä¸‹ç•¥) point_class[point_index[m]] = VERTICAL; } point_index_size = 0; } // ç‚¹äº‘ç±»å‹ä¸ºåœ°é¢ç‚¹äº‘ else { for (int m = 0; m &lt; point_index_size; m++) { //...(ä¸‹ç•¥) point_class[point_index[m]] = GROUND; } point_index_size = 0; } } } }} 2.4 å‚è€ƒæ–‡çŒ®[1] YOLO: Real-Time Object Detection[OB/OL].[2018-3-25]. https://pjreddie.com/darknet/yolo/. [2] Redmon J, Farhadi A. YOLOv3: An Incremental Improvement[J]. arXiv: Computer Vision and Pattern Recognition,2018. [3] Redmon J, Farhadi A. YOLO9000: Better, faster and stronger[C]. Computer Vision and Patter Recognition, 2017: 6517-6525. [4] Redmon J, Farhadi A. YOLOv3: An incremental improvement[J]. arXiv: Computer Vision and Pattern Recognition, 2018. [5] Simon M, Milz S, Amende K, et al. Complex-YOLO: Real-time 3D object detection on point clouds[J]. arXiv: Computer Vision and Pattern Recognition, 2018. [6] PCL VoxelGrid Class Template Reference[OB/OL]. [2015-8-26]. https://docs.ros.org/en/hydro/api/pcl/html/classpcl_1_1VoxelGrid.html. [7] Nagoya University. Ground Filter Method[OB/OL]. [2017-8-4]. https://github.com/CPFL/Autoware-Manuals/blob/master/en/pdfs/ground_filter.pdf. ä¸‰ã€Autoware å®šä½æ¨¡å—è§£æâ€‹ è‡ªåŠ¨é©¾é©¶è½¦è¾†åœ¨è¡Œé©¶è¿‡ç¨‹ä¸­éœ€è¦ä¸ºå†³ç­–æ¨¡å—æä¾›è‡ªèº«åœ¨è½¦é“ä¸Šçš„ç²¾ç¡®ä½å§¿ï¼Œç²¾åº¦ä¸€èˆ¬éœ€è¦è¾¾åˆ°å˜ç±³çº§åˆ«ã€‚ç›®å‰ä¸»æµçš„è‡ªåŠ¨é©¾é©¶å®šä½æŠ€æœ¯å¤§è‡´æœ‰ä¸‰ç§ï¼Œåˆ†åˆ«æ˜¯åŸºäºGNSSå®šä½ã€åŸºäºèˆªè¿¹æ¨ç®—çš„å®šä½ï¼Œä»¥åŠåŸºäºç¯å¢ƒç‰¹å¾åŒ¹é…çš„å®šä½æ–¹æ³•ã€‚å…¶ä¸­åŸºäºç¯å¢ƒç‰¹å¾åŒ¹é…çš„æ–¹æ³•é‡‡ç”¨æ¿€å…‰é›·è¾¾è·å–ç‚¹äº‘æ•°æ®ï¼Œç„¶åä¸åœ°å›¾ä¸­çš„ç‚¹äº‘æ•°æ®è¿›è¡Œç‰¹å¾åŒ¹é…ï¼Œå®ç°ç²¾ç¡®å®šä½ã€‚ 3.0 åŸºç¡€çŸ¥è¯†3.0.1 ä¸‰ç»´ç©ºé—´æè¿°ä¸åæ ‡å˜æ¢â€‹ æ— äººé©¾é©¶æ±½è½¦åœ¨ä¸‰ç»´ç©ºé—´ä¸­è¿åŠ¨ä¸å·¥ä½œï¼Œä¸ºå‡†ç¡®æè¿°å…¶åœ¨è¿åŠ¨è¿‡ç¨‹ä¸­è½¦è¾†æœ¬èº«ä¸ç›¸å…³ä¼ æ„Ÿå™¨çš„ç›¸å¯¹ä½å§¿å…³ç³»ï¼Œéœ€è¦å»ºç«‹åŒ…æ‹¬è½¦ä½“è‡ªèº«åœ¨å†…çš„å„ä¸ªå…ƒå™¨ä»¶æ‰€å¯¹åº”ä¸‰ç»´åæ ‡ç³»é—´çš„å…³ç³»ã€‚ 1ã€ä½ç½®æè¿°â€‹ è½¦è¾†åœ¨ä¸‰ç»´ç©ºé—´ä¸­è¿åŠ¨æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆå¯¹æ•´ä¸ªç©ºé—´å»ºç«‹ä¸€ä¸ªä¸‰ç»´åæ ‡ç³»ï¼Œå³Worldåæ ‡ç³»ã€‚å»ºç«‹å¥½ä¹‹åæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªå‘é‡æ¥è¡¨ç¤ºè½¦è¾†åœ¨Worldåæ ‡ç³»ä¸­çš„ä½ç½®ã€‚è½¦è¾†æœ¬èº«ä¹ŸåŒæ ·å»ºç«‹ä¸€ä¸ªå›ºå®šåœ¨è½¦ä½“ä¸Šçš„åæ ‡ç³»base_linkï¼Œä¸€èˆ¬æ»¡è¶³å³æ‰‹åæ ‡ç³»è§„åˆ™ã€‚ 2ã€å§¿æ€æè¿°â€‹ è½¦è¾†åœ¨Worldåæ ‡ç³»ä¸­çš„ä½ç½®ç¡®å®šä¹‹åï¼Œè½¦è¾†ä¸Worldä¹‹é—´çš„åæ ‡åŸç‚¹çš„è·ç¦»ä¹Ÿéšä¹‹ç¡®å®šã€‚æ¬²æ±‚å¾—è½¦è¾†çš„å§¿æ€ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå›ºå®šåæ ‡ç³»Worldï¼Œæ±‚å‡ºbase_linkç›¸å¯¹äºWorldåæ ‡ç³»çš„å…³ç³»ï¼Œä½¿ç”¨æ—‹è½¬çŸ©é˜µæ¥è¡¨ç¤ºã€‚ â€‹ å‡è®¾Worldåæ ‡ç³»çš„å•ä½æ­£äº¤åŸºåº•ä¸º _e1,e2,e3_ ï¼Œbase_linkåæ ‡ç³»çš„å•ä½æ­£äº¤åŸºåº•ä¸º _Î³1,Î³2,Î³3_ ï¼Œä¸¤åæ ‡ç³»é—´å­˜åœ¨æ—‹è½¬å…³ç³»ã€‚é‚£ä¹ˆå¯¹äºåŒä¸€ä¸ªå‘é‡ _Î±_ åœ¨ä¸¤åæ ‡ç³»ä¸‹çš„åæ ‡åˆ†åˆ«ä¸º _(Î±1,Î±2,Î±3)_ å’Œ _(Î²1,Î²2,Î²3)_ ï¼Œæ­¤æ—¶æœ‰ â€‹ ç­‰å¼ä¸¤ç«¯åŒä¹˜ _[e1,e2,e3]_ çš„è½¬ç½®çŸ©é˜µå¾—åˆ° â€‹ é€šè¿‡ä¸Šè¿°å˜æ¢ï¼Œå¾—åˆ°æ—‹è½¬çŸ©é˜µ _R_ ï¼Œå…¶æè¿°äº†å‘é‡ä»base_linkåæ ‡ç³»åˆ°Worldåæ ‡ç³»çš„æ—‹è½¬å˜æ¢å…³ç³»ã€‚ 3ã€è¿åŠ¨æè¿°â€‹ æˆ‘ä»¬ä¸€èˆ¬ç”¨ä½å§¿æ¥æè¿°åˆšä½“çš„è¿åŠ¨ï¼Œæ­¤æ—¶æˆ‘ä»¬é€šè¿‡å˜æ¢çŸ©é˜µ _T_ æ¥è¡¨ç¤ºä½å§¿åœ¨åæ ‡ç³»ä¹‹é—´çš„å˜æ¢å…³ç³»ã€‚ _R_ è¡¨ç¤ºæ—‹è½¬çŸ©é˜µï¼Œ_t_ è¡¨ç¤ºå¹³ç§»å‘é‡ã€‚æ‰€ä»¥å‘é‡ _Î±_ ä»base_linkåˆ°Worldçš„è½¬æ¢å…³ç³»å¯ä»¥ç”±ä¸‹å¼è¡¨ç¤ºã€‚ \\begin{array}{c} \\boldsymbol{T}=\\left[\\begin{array}{ll} \\boldsymbol{R} & \\boldsymbol{t} \\\\ 0 & 1 \\end{array}\\right] \\\\ {\\left[\\begin{array}{l} \\alpha_{1} \\\\ \\alpha_{2} \\\\ \\alpha_{3} \\end{array}\\right]=\\boldsymbol{T}\\left[\\begin{array}{l} \\beta_{1} \\\\ \\beta_{2} \\\\ \\beta_{3} \\end{array}\\right]} \\end{array}3.0.2 æ­£æ€åˆ†å¸ƒå˜æ¢ç®—æ³•NDTâ€‹ NDTï¼ŒNormal Distributions Transformæ­£æ€åˆ†å¸ƒå˜æ¢ç®—æ³•æ˜¯ä¸€ç§ç»Ÿè®¡å­¦æ¨¡å‹ã€‚å¦‚æœä¸€ç»„éšæœºå‘é‡æ»¡è¶³æ­£æ€åˆ†å¸ƒï¼Œé‚£ä¹ˆå®ƒçš„æ¦‚ç‡å¯†åº¦å‡½æ•°ä¸ºï¼š â€‹ å…¶ä¸­Dè¡¨ç¤ºç»´åº¦ï¼Œè¡¨ç¤ºå‡å€¼å‘é‡ï¼Œè¡¨ç¤ºéšæœºå‘é‡çš„åæ–¹å·®çŸ©é˜µã€‚ç”±äºæ‰«æå¾—åˆ°çš„æ¿€å…‰ç‚¹äº‘æ•°æ®ç‚¹æ˜¯ä¸‰ç»´ç©ºé—´ç‚¹åæ ‡ï¼Œæ‰€ä»¥éœ€è¦é‡‡ç”¨ä¸‰ç»´æ­£æ€åˆ†å¸ƒã€‚NDTèƒ½å¤Ÿé€šè¿‡æ¦‚ç‡çš„å½¢å¼æè¿°ç‚¹äº‘çš„åˆ†éƒ¨æƒ…å†µï¼Œè¿™æœ‰åˆ©äºå‡å°‘é…å‡†æ‰€éœ€è¦çš„æ—¶é—´ã€‚ â€‹ ä¸‹é¢ç®€è¦ä»‹ç»ä¸€ä¸‹NDTç®—æ³•çš„ä¸»è¦æµç¨‹ã€‚ 1ã€NDTç®—æ³•çš„ä¸»è¦æµç¨‹â‘  æ …æ ¼åŒ–ç›®æ ‡ç‚¹äº‘â€‹ é¦–å…ˆè¦å°†æ¿€å…‰é›·è¾¾æ”¶åˆ°çš„ç‚¹äº‘è¿›è¡Œæ …æ ¼åŒ–ï¼Œç‚¹äº‘é…å‡†ä¸€èˆ¬æ˜¯å¯¹ä¸¤ä¸ªç‚¹äº‘æ•°æ®è¿›è¡Œä¸¤ä¸¤é…å‡†ï¼Œéœ€è¦å…ˆå›ºå®šä¸€ä¸ªç‚¹äº‘æ•°æ®ï¼Œå¦å¤–ä¸€ä¸ªç‚¹äº‘æ•°æ®å†é€šè¿‡æ—‹è½¬å¹³ç§»æ¥å’Œå›ºå®šç‚¹äº‘è¿›è¡ŒåŒ¹é…æ‹¼æ¥ã€‚è¿™é‡Œçš„å›ºå®šç‚¹äº‘å°±æ˜¯ç›®æ ‡ç‚¹äº‘ï¼Œå¹³ç§»æ—‹è½¬çš„ç‚¹äº‘å°±æ˜¯æºç‚¹äº‘ã€‚æ …æ ¼åŒ–ç›®æ ‡ç‚¹äº‘ä¸»è¦æ˜¯åˆ©ç”¨ç«‹æ–¹ä½“å°†æ¿€å…‰ç‚¹äº‘æ‰€åœ¨ç©ºé—´è¿›è¡Œå‡åŒ€åˆ’åˆ†ï¼Œä½¿å¾—æ¿€å…‰ç‚¹å¤„äºç›¸åº”çš„ç«‹æ–¹ä½“ä¸­ï¼Œè¿™ä¸€æ­¥ä½œä¸ºNDTç®—æ³•çš„ç¬¬ä¸€æ­¥éå¸¸é‡è¦ã€‚ â‘¡ æ³¨å†Œæ¿€å…‰ç‚¹äº‘æ•°æ®â€‹ åœ¨ç¬¬ä¸€æ­¥æ …æ ¼åŒ–å®Œæˆåï¼Œå°†ç‚¹äº‘åŠ è½½åˆ°ç½‘æ ¼å†…ï¼Œè®¡ç®—å‡å€¼å‘é‡ï¼Œå…¶ä¸­è¡¨ç¤ºç½‘æ ¼ä¸­æ‰€æœ‰æ‰«æç‚¹çš„åæ ‡ã€‚ â€‹ ç„¶åè®¡ç®—åæ–¹å·®çŸ©é˜µå¹¶æ±‚å‡ºæ¯ä¸ªç½‘æ ¼å†…çš„æ­£æ€åˆ†å¸ƒæ¦‚ç‡å¯†åº¦å‡½æ•°ã€‚éœ€è¦æ³¨æ„ï¼Œç”±äºéœ€è¦ç”¨åˆ°åæ–¹å·®çŸ©é˜µçš„é€†çŸ©é˜µï¼Œæ‰€ä»¥æ¯ä¸ªç½‘æ ¼ä¸­åŒ…å«çš„æ¿€å…‰ç‚¹ä¸å¯å°‘äºä¸‰ä¸ªï¼Œä¸€èˆ¬è‡³å°‘è¦ä¿è¯æœ‰äº”ä¸ªç‚¹ã€‚ â‘¢ æ±‚å‡ºæºç‚¹äº‘ç›¸å¯¹äºç›®æ ‡ç‚¹äº‘çš„åˆå§‹åæ ‡å˜æ¢å‚æ•°â€‹ åæ ‡å˜æ¢é€šå¸¸æ¶‰åŠåˆ°å¹³ç§»ä¸æ—‹è½¬ï¼Œå¹³ç§»é€šè¿‡å¹³ç§»å‘é‡è¡¨ç¤ºï¼Œæ—‹è½¬åˆ™å¯ä»¥é€šè¿‡æ—‹è½¬çŸ©é˜µè¡¨ç¤ºï¼Œæ—‹è½¬æ˜¯å…³äºè‡ªèº«zyxä¸‰ä¸ªå›ºå®šè½´çš„æ—‹è½¬ï¼Œè½¬è§’åˆ†åˆ«ç”¨Î±ã€Î²ã€Î³è¡¨ç¤ºï¼Œåˆ†åˆ«ä¸yawï¼Œpitchï¼Œrollå¯¹åº”ã€‚é€šè¿‡è®¡ç®—æ—‹è½¬å¹³ç§»çŸ©é˜µï¼Œå¯ä»¥å¾—åˆ°åŒä¸€ä¸ªæ¿€å…‰ç‚¹äº‘åœ¨è¿™ä¸¤ä¸ªç‚¹äº‘åæ ‡ç³»ä¸‹çš„ä½ç½®åæ ‡å˜æ¢å…³ç³»ã€‚ â€‹ è¿™ä¸€æ­¥æ˜¯ä¸ºäº†å¯»æ‰¾ä¸€ä¸ªåˆé€‚çš„åˆå§‹åæ ‡å˜æ¢ä½¿å¾—æºç‚¹äº‘å¤§è‡´å¤„äºç›®æ ‡ç‚¹äº‘çš„åæ ‡å¹³é¢å½“ä¸­ã€‚è¿™ä¸€æ­¥æä¾›çš„å˜æ¢å‚æ•°çš„åˆå€¼ï¼Œä¸ºä¸‹ä¸€æ­¥å˜æ¢å‚æ•°çš„è¿­ä»£æä¾›è·ç¦»æœ€ä¼˜ç‚¹è¾ƒè¿‘çš„åˆå€¼ã€‚åœ¨è‡ªåŠ¨é©¾é©¶é‡Œåˆå§‹å€¼çš„æä¾›å¯ä»¥ä¾é GNSSã€Odomæˆ–è€…IMUæƒ¯æ€§å¯¼èˆªï¼Œåˆ©ç”¨è¿™äº›ä¼ æ„Ÿå™¨è·å–è½¦è¾†çš„å½“å‰ä½å§¿ï¼Œé€šè¿‡åæ ‡å˜æ¢å¾—åˆ°ç›¸å¯¹äºç›®æ ‡ç‚¹äº‘çš„åæ ‡å˜æ¢å‚æ•°ï¼Œä¹Ÿå°±æ˜¯æ—‹è½¬çŸ©é˜µ _R_ å’Œå¹³ç§»å‘é‡ _t_ ã€‚ â‘£ æºç‚¹äº‘è¿›è¡Œåˆå§‹åæ ‡å˜æ¢ï¼Œå¹¶è®¡ç®—åœ¨ç›®æ ‡ç‚¹äº‘ç½‘æ ¼ä¸­çš„æ¦‚ç‡â€‹ æºç‚¹äº‘æ ¹æ®åˆå§‹å˜æ¢å‚æ•°å°†åæ ‡è½¬æ¢åˆ°ç›®æ ‡ç‚¹äº‘ä¸­ã€‚æ­¤æ—¶æºç‚¹äº‘åˆ†å¸ƒåœ¨ç›®æ ‡ç‚¹äº‘ç½‘æ ¼ä¸­ï¼Œè½¬æ¢åæºç‚¹äº‘çš„åæ ‡Xâ€™ç”±å¯¹åº”æ‰€åœ¨çš„ç½‘æ ¼çš„æ­£æ€åˆ†å¸ƒæ¦‚ç‡å¯†åº¦å‡½æ•°ï¼Œæ±‚å‡ºæ¿€å…‰ç‚¹åæ ‡ä¸ºXâ€˜çš„æ¦‚ç‡ã€‚å°†æ¯ä¸ªç‚¹çš„æ¦‚ç‡ä¹˜ç§¯èµ·æ¥ä½œä¸ºç›®æ ‡ä¼¼ç„¶å‡½æ•°ã€‚é€šè¿‡ä¼¼ç„¶å‡½æ•°æ‰¾åˆ°æ¦‚ç‡ä¹˜ç§¯æœ€å¤§æ—¶å€™çš„åæ ‡è½¬æ¢å…³ç³»ã€‚ â€‹ ç®€å•æ¥è¯´å°±æ˜¯ç”±æœ€å¤§çš„æ¦‚ç‡æ‰¾åˆ°æœ€ä¼˜çš„åæ ‡å˜æ¢ã€‚ â‘¤ é«˜æ–¯ç‰›é¡¿æ³•è¿›è¡Œä¼˜åŒ–ï¼Œæ‰¾å‡ºæœ€ä½³å˜æ¢å‚æ•°på®Œæˆç‚¹äº‘é…å‡†2ã€ç‚¹äº‘é…å‡†åŸç†â€‹ åœ¨æ¿€å…‰ç‚¹äº‘åœ°å›¾å»ºå›¾è¿‡ç¨‹ä¸­ï¼Œç”±äºæ¿€å…‰é›·è¾¾æ‰«æè·ç¦»å­˜åœ¨é™åˆ¶ï¼Œä¸€æ¬¡æ‰«æéš¾ä»¥è·å–å®Œæ•´çš„ç›®æ ‡ç¯å¢ƒï¼Œå¹¶ä¸”è·ç¦»æ¿€å…‰é›·è¾¾è¶Šè¿œï¼Œç‚¹äº‘å°±ä¼šå˜å¾—è¶Šç¨€ç–ï¼Œæ‰€ä»¥éœ€è¦ç»è¿‡è¿ç»­å¤šæ¬¡æ‰«æï¼Œç„¶åå°†æ¯æ¬¡æ‰«æçš„ç‚¹äº‘æ•°æ®è¿›è¡Œé…å‡†æ‹¼æ¥ï¼Œæœ€ç»ˆæ‰èƒ½å½¢æˆè¿ç»­å®Œæ•´çš„æ¿€å…‰ç‚¹äº‘åœ°å›¾ã€‚ â€‹ ä»ä¸åŒè§’åº¦æ‰«æåŒä¸€åœºæ™¯æ‰€å¾—åˆ°çš„çš„ç‚¹äº‘æ•°æ®ç»Ÿä¸€è½¬æ¢åˆ°åŒä¸€åæ ‡ç³»çš„è¿‡ç¨‹å«åšç‚¹äº‘é…å‡†ã€‚ç®€å•åœ°è¯´å°±æ˜¯å°†ç¦»æ•£çš„ç‚¹äº‘æ•°æ®åœ¨ç»Ÿä¸€çš„åæ ‡ç³»ä¸‹æ‹¼æ¥æˆä¸€æ•´ä¸ªå®Œæ•´çš„ç‚¹äº‘æ•°æ®ã€‚é€šå¸¸ç‚¹äº‘é…å‡†ç®—æ³•èƒ½å¤Ÿåˆ©ç”¨ä¸¤ä¸ªç‚¹é›†ä¹‹é—´çš„æœ€å°è·ç¦»æˆ–è€…åˆ©ç”¨ç»Ÿè®¡å­¦æ–¹æ³•ï¼Œå¾—åˆ°ä¸¤ä¸ªç‚¹é›†ä¹‹é—´çš„å˜æ¢å…³ç³»ï¼Œä½¿å¾—ç‚¹äº‘è¾¾åˆ°å˜æ¢é…å‡†çš„æ•ˆæœã€‚é—®é¢˜å…³é”®åœ¨äºå¦‚ä½•å¾—åˆ°æ¿€å…‰ç‚¹äº‘ä¹‹é—´çš„RTçŸ©é˜µã€‚é€šå¸¸å¯ä»¥ç›´æ¥åˆ©ç”¨PCLå¼€æºç‚¹äº‘åº“æ¥å¯¹ç›¸å…³ç‚¹äº‘æ•°æ®è¿›è¡Œå¤„ç†ï¼ŒPCLç‚¹äº‘åº“ä¸­åŒ…å«äº†åŸºäºNDTæ­£æ€åˆ†å¸ƒå˜æ¢ç­‰å¤šç§ç‚¹äº‘é…å‡†ç®—æ³•ã€‚C++ PCLåº“æ¶æ„å›¾å¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒPCLæ›´å¤šèµ„æ–™è§ï¼šPCLå­¦ä¹ æŒ‡å— ç‚¹äº‘é…å‡†å…·ä½“çš„æ­¥éª¤å¦‚ä¸‹ï¼š â‘  è¾“å…¥å®æ—¶ç‚¹äº‘å¹¶ä¸‹é‡‡æ ·â€‹ æ¿€å…‰é›·è¾¾æ‰«æå¾—åˆ°çš„æ¿€å…‰ç‚¹äº‘æ•°æ®éœ€è¦å»é™¤è·ç¦»è½¦ä½“è¾ƒè¿‘ä¸è¾ƒè¿œçš„æ¿€å…‰ç‚¹é›†ï¼Œç„¶ååˆ©ç”¨ä½“ç´ æ»¤æ³¢è¿‡æ»¤å‰©ä¸‹çš„æ¿€å…‰ç‚¹äº‘æ•°æ®ï¼Œåœ¨ä¿æŒç‚¹äº‘ç»Ÿè®¡ç‰¹å¾çš„æƒ…å†µä¸‹ï¼Œé™ä½æ¿€å…‰ç‚¹äº‘æ•°æ®é›†çš„å°ºå¯¸å¤§å°ï¼Œæœ€å¥½å°†é™é‡‡æ ·åçš„è¿‡æ»¤ç‚¹äº‘ä½œä¸ºNDTé…å‡†ç®—æ³•çš„è¾“å…¥æºç‚¹äº‘ä»¥é™ä½è¿ç®—æ—¶é—´ï¼ŒèŠ‚çœèµ„æºã€‚ â‘¡ è¾“å…¥æºç‚¹äº‘(å…¨å±€åœ°å›¾)â€‹ åŠ è½½å…¨å±€åœ°å›¾ä½œä¸ºNDTé…å‡†çš„è¾“å…¥ç›®æ ‡ç‚¹äº‘ã€‚ç‰¹åˆ«çš„ï¼Œå»ºå›¾æ—¶ç¬¬ä¸€å¸§æ¿€å…‰ç‚¹äº‘ä½œä¸ºåˆå§‹å…¨å±€åœ°å›¾ã€‚ â‘¢ è¾“å…¥åˆå§‹ä½å§¿â€‹ ä¸ºäº†å¿«é€Ÿå¾—åˆ°å‡†ç¡®çš„é…å‡†ç»“æœï¼Œéœ€è¦ç»™NDTç®—æ³•æä¾›è‰¯å¥½çš„åˆå§‹å€¼ï¼Œè¯¥èŠ‚ç‚¹é€šè¿‡IMUã€Odomä»¥åŠä¸¤è€…è”åˆæ¥æ±‚å¾—åˆå§‹ä½å§¿ä¼°è®¡ã€‚ â‘£ ç‚¹äº‘é…å‡†â€‹ å°†å‰ä¸‰è€…å¾—åˆ°çš„ç»“æœä½œä¸ºå‚æ•°ä¼ å…¥åˆ°NDTé…å‡†ç®—æ³•ä¸­è¿›è¡Œæ¿€å…‰ç‚¹äº‘é…å‡†ã€‚ 3ã€ä¼ªä»£ç â€‹ å…·ä½“è¯¦è§4ä¸­ä¸¤ç¯‡å‚è€ƒè®ºæ–‡ï¼Œæ­¤å¤„ä»¥äºŒç»´ä¸¾ä¾‹ã€‚ 4ã€å‚è€ƒè®ºæ–‡ [1] Biber P, StraÃŸer W. The normal distributions transform: A new approach to laser scan matching[C] IROS 2003 . IEEE, 2003, 3: 2743-2748. [2] Merten H. The three-dimensional normal-distributions transform[J]. threshold, 2008, 10: 3. 3.1 ndt_mappingèŠ‚ç‚¹è§£æâ€‹ ndt_mappingä¸»è¦åˆ©ç”¨çš„æ˜¯scan_to_mapçš„æ–¹å¼å®ç°æ¿€å…‰ç‚¹äº‘å»ºå›¾ï¼Œè¯¥æ–¹æ³•ç»å¸¸ä½¿ç”¨åœ¨SLAMåŒæ—¶å®šä½ä¸å»ºå›¾ä¸­ï¼Œå½“æ¿€å…‰é›·è¾¾è¿›è¡Œæ‰«æå»ºå›¾çš„æ—¶å€™ï¼Œç”±äºå—åˆ°æ‰«æè·ç¦»ç­‰å› ç´ çš„é™åˆ¶ï¼Œä½¿å¾—æ¿€å…‰é›·è¾¾ä¸èƒ½ä¸€æ¬¡æ‰«æå¾—åˆ°å®Œæ•´çš„ç¯å¢ƒåœ°å›¾ï¼Œå› æ­¤éœ€è¦è¿›è¡Œè¿ç»­å¤šæ¬¡çš„æ‰«æã€‚æœ€ç»ˆæ‰«æå¾—åˆ°çš„æ•´ä¸ªç¯å¢ƒåœ°å›¾å°±æ˜¯å…¨å±€åœ°å›¾mapï¼Œè€Œå…¶ä¸­scanè¡¨ç¤ºå½“å‰æ‰«æå¾—åˆ°çš„æ¿€å…‰ç‚¹äº‘æ•°æ®ï¼Œå¯ä»¥é€šè¿‡å›ºå®šç›®æ ‡ç‚¹äº‘åœ°å›¾submapï¼Œç„¶ååˆ©ç”¨NDTé…å‡†ç®—æ³•ï¼Œå°†æ¯ä¸€å¸§æ‰«æå¾—åˆ°çš„æ¿€å…‰ç‚¹äº‘æ•°æ®scanå˜æ¢åˆ°ç›®æ ‡ç‚¹äº‘submapä¸­ï¼Œå¹¶ä½¿å¾—ä¸¤è€…æ‹¼æ¥åœ¨ä¸€èµ·ï¼Œæœ€ç»ˆå¾—åˆ°æ‹¼æ¥å®Œæ•´çš„å…¨å±€åœ°å›¾mapã€‚ndt_mappingç®€è¦æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ 3.1.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch lidar_localizer ndt_mapping.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹Computing é€‰é¡¹å¡ -&gt; Localization/ lidar_localizer -&gt; ndt_mappingï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 3.1.2 ç¨‹åºè·¯å¾„12345//æºä»£ç è·¯å¾„~/autoware.ai/src/autoware/core_perception/lidar_localizer/nodes/ndt_mapping/ndt_mapping.cpp//launchæ–‡ä»¶è·¯å¾„~/autoware.ai/src/autoware/core_perception/lidar_localizer/launch/ndt_mapping.launch 3.1.3 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ method_type int ndtä½¿ç”¨ç®—æ³•ç±»å‹ use_odom bool æ˜¯å¦ä½¿ç”¨é‡Œç¨‹è®¡å‡å°‘è¯¯å·® use_imu bool æ˜¯å¦ä½¿ç”¨IMUå‡å°‘è¯¯å·® imu_upside_down bool IMUåæ ‡ç³»æ˜¯å¦ç¿»è½¬ imu_topic String IMUè¯é¢˜å incremental_voxel_update bool æ˜¯å¦æ›´æ–°å¢é‡ä½“ç´  3.1.4 è®¢é˜…è¯é¢˜å è¯é¢˜å æ¶ˆæ¯ç±»å‹ /config/ndt_mapping autoware_config_msgs/ConfigNDTMapping /config/ndt_mapping_output autoware_config_msgs/ConfigNDTMappingOutput /points_raw sensor_msgs/PointCloud2 /vehicle/odom nav_msgs/Odometry /imu_raw sensor_msgs/Imu /vehicle/twist geometry_msgs/TwistStamped 3.1.5 å‘å¸ƒè¯é¢˜å è¯é¢˜å æ¶ˆæ¯ç±»å‹ /ndt_map sensor_msgs/PointCloud2 /current_pose geometry_msgs/PoseStamped 3.1.6 ä»£ç æ³¨è§£â‘  ä¸»å‡½æ•°â€‹ ä¸»å‡½æ•°åˆå§‹åŒ–ä½å§¿ã€ROSèŠ‚ç‚¹åŠå‚æ•°ï¼Œå¹¶å†™å…¥æ—¥å¿—æ–‡ä»¶ã€‚ä»å‚æ•°æœåŠ¡å™¨ä¸­è·å–å‚æ•°å€¼ï¼Œè®¡ç®—å˜æ¢çŸ©é˜µtf_btolï¼Œæœ€åå‘å¸ƒä¸è®¢é˜…ç›¸å…³æ¶ˆæ¯ã€‚ 1234567//ç§æœ‰å¥æŸ„è°ƒç”¨getparamå‡½æ•°ä»å‚æ•°æœåŠ¡å™¨ä¸Šå¾—åˆ°å‚æ•°å€¼ï¼Œè‹¥æ— å‚æ•°åˆ™ç½®ä¸ºé»˜è®¤å€¼ private_nh.getParam(&quot;method_type&quot;, method_type_tmp);_method_type = static_cast&lt;MethodType&gt;(method_type_tmp);private_nh.getParam(&quot;use_gnss&quot;, _use_gnss);private_nh.getParam(&quot;queue_size&quot;, _queue_size);private_nh.getParam(&quot;offset&quot;, _offset);//...(ä¸‹ç•¥) â€‹ è®¡ç®—mapä¸base_linkçš„åæ ‡è½¬æ¢å…³ç³» 12345678910// åˆå§‹å¹³ç§»å‘é‡tl_btolï¼Œæ¿€å…‰é›·è¾¾ç›¸å¯¹äºè½¦èº«åº•ç›˜åæ ‡ç³»çš„ä½å§¿Eigen::Translation3f tl_btol(tf_x, tf_y, tf_z);// tl: translation// åˆå§‹åŒ–æ—‹è½¬å‘é‡ï¼Œåˆ†åˆ«ç»•ç€xã€yã€zè½´æ—‹è½¬tf::Matrix3x3(tf_baselink2primarylidar.getRotation()).getRPY( tf_roll, tf_pitch,tf_yaw);Eigen::AngleAxisf rot_x_btol(tf_roll, Eigen::Vector3f::UnitX()); // rot: rotationEigen::AngleAxisf rot_y_btol(tf_pitch, Eigen::Vector3f::UnitY());Eigen::AngleAxisf rot_z_btol(tf_yaw, Eigen::Vector3f::UnitZ());tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();tf_ltob = tf_btol.inverse();//...(ä¸‹ç•¥) â‘¡ param_callbackå‡½æ•°â€‹ param_callbackå‡½æ•°é€šè¿‡autoware_config_msgs::ConfigNDTMappingæ–‡ä»¶è¿›è¡Œå‚æ•°é…ç½®ï¼Œä¸»è¦è®¾ç½®ndtç®—æ³•é…å‡†æ—¶çš„å‚æ•°ã€‚å…¶ä¸­å®šä¹‰äº†é…å‡†æ—¶çš„æ¶ˆæ¯ã€ç½‘æ ¼å¤§å°ã€é«˜æ–¯ç‰›é¡¿æ³•æ­¥é•¿ç­‰å‚æ•°ã€‚ 1234567891011121314static void param_callback(const autoware_config_msgs::ConfigNDTMapping::ConstPtr&amp; input){ //è®¾ç½®ndtå‚æ•°ï¼šåˆ†è¾¨ç‡ã€æ­¥é•¿ï¼Œæœ€å¤§è¿­ä»£æ¬¡æ•°ã€ä½“ç´ å¶å¤§å°ã€æ¿€å…‰æ‰«æèŒƒå›´ç­‰ ndt_res = input-&gt;resolution; //resolutionè¡¨ç¤ºç‚¹äº‘ç½‘æ ¼åŒ–æ—¶ç½‘æ ¼çš„è¾¹é•¿ï¼Œè¿‡å¤§ä¼šå½±å“ç²¾åº¦ï¼Œè¿‡å°åˆ™å½±å“å†…å­˜ä½¿ç”¨ step_size = input-&gt;step_size; //step_sizeè®¾ç½®åˆ©ç”¨ç‰›é¡¿æ³•ä¼˜åŒ–çš„æœ€å¤§æ­¥é•¿ trans_eps = input-&gt;trans_epsilon; //trans_epsilonè®¾ç½®ä¸¤è¿ç»­å˜æ¢çš„æœ€å¤§å·®å€¼ç”¨äºåˆ¤æ–­æ˜¯å¦æ”¶æ•›è‡³é˜ˆå€¼ max_iter = input-&gt;max_iterations; //max_iterationsè®¾ç½®ä¼˜åŒ–è¿­ä»£çš„æœ€å¤§æ¬¡æ•° voxel_leaf_size = input-&gt;leaf_size; //leaf_sizeè®¾ç½®ä½“ç´ æ»¤æ³¢å¶çš„å¤§å°ç”¨äºåŸå§‹ç‚¹äº‘è¿‡æ»¤ //æ¿€å…‰ç‚¹äº‘æœ‰æ•ˆæ‰«æè·ç¦» min_scan_range = input-&gt;min_scan_range; max_scan_range = input-&gt;max_scan_range; min_add_scan_shift = input-&gt;min_add_scan_shift; //...(ä¸‹ç•¥)} â‘¢ output_callbackå‡½æ•°â€‹ output_callbackä¸»è¦ä½¿ç”¨ä½“ç´ æ»¤æ³¢å°†åŸå§‹ç‚¹äº‘æ•°æ®è¿›è¡Œè¿‡æ»¤ï¼Œåœ¨ä¿æŒç‚¹äº‘ç‰¹æ€§çš„æƒ…å†µä¸‹é™ä½ç‚¹äº‘æ•°é‡ï¼Œç„¶åå°†æ»¤æ³¢åçš„ç‚¹äº‘é€šè¿‡ROSå‘å¸ƒï¼Œå¹¶å†™å…¥PCDæ–‡ä»¶ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static void output_callback(const autoware_config_msgs::ConfigNDTMappingOutput::ConstPtr&amp; input){ double filter_res = input-&gt;filter_res; std::string filename = input-&gt;filename; //...(ä¸‹ç•¥) pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map)); pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_filtered(new pcl::PointCloud&lt;pcl::PointXYZI&gt;()); map_ptr-&gt;header.frame_id = &quot;map&quot;; map_filtered-&gt;header.frame_id = &quot;map&quot;; sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2); // è¿ç”¨ä½“ç´ æ»¤æ³¢ï¼Œå¦‚æœä¸æ»¤æ³¢åˆ™è¾“å‡ºåŸå§‹ç‚¹äº‘ï¼Œå¹¶å°†pcl::PointCloud&lt;pcl::PointXYZI&gt;è½¬åŒ–ä¸ºsensor_msgs::PointCloud2ç±»å‹ if (filter_res == 0.0) { std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl; pcl::toROSMsg(*map_ptr, *map_msg_ptr); } else { // å£°æ˜ä½“ç´ æ»¤æ³¢å¯¹è±¡voxel_grid_filter pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter; // è®¾ç½®ä½“ç´ æ»¤æ³¢ç½‘æ ¼å¤§å°ï¼Œç½‘æ ¼æ˜¯è¾¹é•¿ä¸ºfilter_resçš„ç«‹æ–¹ä½“ voxel_grid_filter.setLeafSize(filter_res, filter_res, filter_res); // å°†mapä½œä¸ºè¾“å…¥åœ°å›¾ voxel_grid_filter.setInputCloud(map_ptr); // ç‚¹äº‘ä¸‹é‡‡æ ·å¹¶ä¿å­˜ç»“æœè‡³map_filtered voxel_grid_filter.filter(*map_filtered); std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Filtered: &quot; &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl; // å°†ç‚¹äº‘ç±»å‹è½¬æ¢ä¸ºROSå¯ç”¨çš„sensor_msgs::PointCloud2æ ¼å¼ pcl::toROSMsg(*map_filtered, *map_msg_ptr); } // å‘å¸ƒè¿‡æ»¤ç‚¹äº‘æ¶ˆæ¯ ndt_map_pub.publish(*map_msg_ptr); // ç‚¹äº‘æ•°æ®å†™å…¥PCDæ–‡ä»¶ if (filter_res == 0.0) { pcl::io::savePCDFileASCII(filename, *map_ptr); std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; data points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; } else { pcl::io::savePCDFileASCII(filename, *map_filtered); std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; &quot; data points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; }} â‘£ points_callbackå‡½æ•°â€‹ points_callbackå‡½æ•°ç”±ros::Subscriber points_sub = nh.subscribe(â€œpoints_rawâ€, 100000, points_callback)è°ƒç”¨ï¼Œå‚æ•°ä¸ºæ¿€å…‰é›·è¾¾æ‰€å–åˆ°çš„ sensormsgs::PointCloud2 ç±»å‹çš„æ¿€å…‰ç‚¹äº‘æ•°æ®ï¼Œrè¡¨ç¤ºæ¿€å…‰ç‚¹äº‘ä¸­æ¯ä¸€ä¸ªç‚¹ä¸æ¿€å…‰é›·è¾¾çš„è·ç¦»ï¼Œè¿™ç”¨æ¥åç»­æ»¤é™¤è·ç¦»è½¦ä½“è¾ƒè¿‘ä¸è¾ƒè¿œçš„æ¿€å…‰ç‚¹é›†ã€‚pè¡¨ç¤ºåŸå§‹æ¿€å…‰ç‚¹äº‘ä¸­çš„ç‚¹å¯¹è±¡ï¼Œç±»å‹ä¸ºpcl::PointXYZIã€‚å‡½æ•°å£°æ˜äº†ä¸¤ä¸ªç±»å‹ä¸ºpcl::PointxYZIçš„ç‚¹äº‘å¯¹è±¡ tmp, scanã€‚ tmpè¡¨ç¤ºä¸´æ—¶çš„åŸå§‹ç‚¹äº‘æ•°æ®ï¼Œscan è¡¨ç¤ºçš„æ˜¯ tmp æ»¤é™¤è·ç¦»æ¿€å…‰é›·è¾¾è¿‡è¿‘å’Œè¿‡è¿œçš„æ¿€å…‰ç‚¹çš„ç‚¹äº‘æ•°æ®ã€‚t_localizer ä¸ t_base_ link åˆ†åˆ«è¡¨ç¤ºä¸ºæ¿€å…‰é›·è¾¾ä¸è½¦ä½“ç›¸å¯¹äº map åæ ‡ç³»çš„å˜æ¢çŸ©é˜µï¼Œå¹¶ä¸”å‡åˆå§‹åŒ–ä¸º4é˜¶å•ä½é˜µã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒNDTé…å‡†ç®—æ³•æ˜¯å°†æ¿€å…‰é›·è¾¾è·å–åˆ°çš„æ¿€å…‰ç‚¹äº‘ä¸åœ°å›¾ç›®æ ‡ç‚¹äº‘è¿›è¡Œé…å‡†ï¼Œæ¿€å…‰ç‚¹äº‘æ˜¯ç›¸å¯¹äºæ¿€å…‰é›·è¾¾åæ ‡ç³»ï¼Œæ‰€ä»¥è¿›è¡Œ NDT é…å‡†çš„æ—¶å€™æ±‚å‡ºçš„æ˜¯æ¿€å…‰é›·è¾¾ç›¸å¯¹äºå…¨å±€åœ°å›¾åæ ‡ç³» map çš„å˜æ¢å…³ç³» t_localizerã€‚è¦æƒ³æ±‚å¾—è½¦èº«åº•ç›˜ç›¸å¯¹äºå…¨å±€åœ°å›¾map åæ ‡ç³»çš„å˜æ¢å…³ç³»ï¼Œéœ€è¦åœ¨t_localizer çš„åŸºç¡€ä¸Šè¡¥å¿ä¸€ä¸ªæ¿€å…‰é›·è¾¾ä¸è½¦èº«åº•ç›˜ä¹‹é—´çš„å˜æ¢çŸ©é˜µtf_ltobã€‚ â€‹ å‡½æ•°è·å–å½“å‰æ—¶é—´æˆ³ä½œä¸ºå½“å‰çš„ç‚¹äº‘æ‰«ææ—¶é—´ï¼Œç„¶ååˆ©ç”¨ pcl:fromROSMsg å‡½æ•°å°†è¾“å…¥çš„ sensor msgs:PointCloud2 ç±»å‹çš„ç‚¹äº‘æ•°æ®è½¬åŒ–ä¸º PCL ä½¿ç”¨çš„æ•°æ®ç±»å‹ã€‚ 123456789101112131415161718192021static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input){ // rè¡¨ç¤ºç‚¹äº‘åˆ°æ¿€å…‰é›·è¾¾çš„è·ç¦» double r; pcl::PointXYZI p; // å£°æ˜ç‚¹äº‘å¯¹è±¡tmp, scan pcl::PointCloud&lt;pcl::PointXYZI&gt; tmp, scan; pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;()); pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;()); tf::Quaternion q; Eigen::Matrix4f t_localizer(Eigen::Matrix4f::Identity()); Eigen::Matrix4f t_base_link(Eigen::Matrix4f::Identity()); // å£°æ˜tfå‘å¸ƒè€…br static tf::TransformBroadcaster br; // å£°æ˜å˜æ¢å¯¹è±¡transform tf::Transform transform; // è·å–å½“å‰å¸§ç‚¹äº‘æ‰«ææ—¶é—´æˆ³ current_scan_time = input-&gt;header.stamp; // ç‚¹äº‘ç±»å‹è½¬æ¢ pcl::fromROSMsg(*input, tmp); â€‹ è¿™ä¸€éƒ¨åˆ†ä»£ç å—ä¸»è¦å®ç°ä¸Šä¸€æ­¥æåˆ°çš„æ»¤é™¤è·ç¦»è½¦ä½“è¿‡è¿‘ä¸è¿‡è¿œçš„æ¿€å…‰ç‚¹é›†ã€‚tmp æ˜¯åŸå§‹çš„æ¿€å…‰ç‚¹äº‘æ•°æ®ï¼Œåœ¨forå¾ªç¯ä¸­é€ä¸€è·å–tmpä¸­çš„ç‚¹äº‘æ•°æ®ï¼Œç„¶ååˆ©ç”¨r=âˆšx^2+y^2æ±‚å‡ºæ¿€å…‰ç‚¹ä¸æ¿€å…‰é›·è¾¾ä¹‹é—´çš„è·ç¦»ï¼Œå…¶ä¸­ï¼Œx,yåˆ†åˆ«è¡¨ç¤ºæ¿€å…‰ç‚¹çš„æ¨ªçºµåæ ‡ã€‚å½“råœ¨æœ€å°æ‰«æè·ç¦»ä»¥åŠæœ€å¤§æ‰«æè·ç¦»ä¹‹é—´æ—¶ï¼Œåˆ™å°†æ¿€å…‰ç‚¹æ·»åŠ è‡³ scan ç‚¹äº‘å®¹å™¨ä¸­ã€‚ 123456789101112131415// å¤„ç†tmpç‚¹äº‘å®¹å™¨ä¸­çš„ç‚¹for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++){ p.x = (double)item-&gt;x; p.y = (double)item-&gt;y; p.z = (double)item-&gt;z; p.intensity = (double)item-&gt;intensity; // è®¡ç®—ç‚¹ä¸æ¿€å…‰é›·è¾¾çš„æ¬§æ°è·ç¦»rï¼Œé€ä¸€åˆ¤æ–­æ¯ä¸ªç‚¹ï¼Œå°†æ»¡è¶³æ‰«æè·ç¦»çš„ç‚¹æ’å…¥scan r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0)); if (min_scan_range &lt; r &amp;&amp; r &lt; max_scan_range) { scan.push_back(p); }}pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan)); â€‹ æ¿€å…‰ç‚¹äº‘åœ°å›¾éœ€è¦åˆå§‹åŒ–è½½å…¥ï¼Œå®é™…ä¸Šæ˜¯å°†ç¬¬ä¸€å¸§æ¿€å…‰ç‚¹äº‘åŠ å…¥åˆ°mapä¸­ã€‚initial_scan_loaded ç”¨æ¥è¡¨ç¤ºåˆå§‹åŒ–è½½å…¥æ˜¯å¦æˆåŠŸï¼Œå½“åœ°å›¾æ²¡æœ‰åˆå§‹åŒ–è½½å…¥æ—¶ï¼Œåˆ™å°†ç¬¬ä¸€å¸§ç‚¹äº‘æ•°æ®é€šè¿‡ pcl::transformPointcloud å‡½æ•°è¿›è¡Œè½¬æ¢ååŠ å…¥åˆ°mapï¼Œpcl::transformPointCloud å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºè¾“å…¥ç‚¹äº‘ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºè¾“å‡ºç‚¹äº‘ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ä¸ºå˜æ¢çŸ©é˜µtf_btol. 123456789// å°†åˆå§‹åŒ–ç‚¹äº‘åŠ å…¥åœ°å›¾ï¼Œè‹¥ç‚¹äº‘åœ°å›¾æœªåˆå§‹åŒ–if (initial_scan_loaded == 0){ // é€šè¿‡tf_btolå˜æ¢çŸ©é˜µä½œä¸ºè¾“å…¥å°†åŸå§‹ç‚¹äº‘è¿›è¡Œè½¬åŒ– pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, tf_btol); // å°†è½¬æ¢åçš„ç‚¹äº‘åŠ å…¥mapè¿›è¡Œæ‹¼æ¥ï¼Œå®é™…ä¸Šæ˜¯ä½œä¸ºç¬¬ä¸€å¸§ç‚¹äº‘å›¾åƒ map += *transformed_scan_ptr; initial_scan_loaded = 1;} â€‹ å³ä½¿ç­›é€‰æ‰è·ç¦»æ¿€å…‰é›·è¾¾è¿‡è¿‘ä¸è¿‡è¿œçš„æ¿€å…‰ç‚¹ï¼Œscan_ptr ä¸­å«æœ‰çš„æ¿€å…‰ç‚¹çš„æ•°é‡ä»ç„¶è¾ƒå¤§ï¼Œæ‰€ä»¥å‡½æ•°é€šè¿‡ä½“ç´ æ»¤æ³¢æ¥é™ä½ç‚¹äº‘æ•°æ®çš„è§„æ¨¡ã€‚PCLæä¾›çš„VoxelGrid ç±»å°†è¾“å…¥ç‚¹äº‘é›†åˆç©ºé—´è¿›è¡Œä¸‰ç»´ç½‘æ ¼åŒ–ï¼Œç„¶åä»¥æ¯ä¸€ä¸ªç½‘æ ¼(æ¯ä¸€ä¸ªç«‹æ–¹ä½“)å†…æ‰€æœ‰ç‚¹çš„é‡å¿ƒæ¥ä»£è¡¨ä½“ç´ å†…çš„æ‰€æœ‰ç‚¹ï¼Œä½“ç´ å†…æ‰€æœ‰ç‚¹ç”±ä¸€ä¸ªç‚¹æ¥è¡¨ç¤ºï¼Œè¿™å‡å°‘äº†æ•°æ®è§„æ¨¡ï¼Œè€Œä¸”è¿˜ä¿æŒäº†è¾“å…¥ç‚¹äº‘çš„å½¢çŠ¶ç‰¹å¾ã€‚ä½“ç´ æ»¤æ³¢ä¸»è¦è®¾ç½®ç½‘æ ¼å¤§å°voxel_leaf_ sizeï¼Œ ç„¶åå°†scan_ptrè¿‡æ»¤ï¼Œå¾—åˆ°è¾“å‡ºç‚¹äº‘*filtered_scan_ptrã€‚ 123456// å¯¹scan_ptrè¾“å…¥ç‚¹äº‘è¿›è¡Œä½“ç´ è¿‡æ»¤pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);voxel_grid_filter.setInputCloud(scan_ptr);voxel_grid_filter.filter(*filtered_scan_ptr);pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map)); â€‹ æ ¹æ® method_type å‚æ•°è¿›è¡Œç›¸åº”çš„NDTå‚æ•°è®¾ç½®ï¼Œåœ¨ndté…å‡†ç®—æ³•ä¸­Epsilonå‚æ•°ä¸»è¦è¡¨ç¤ºå¹³ç§»å‘é‡å’Œæ—‹è½¬è§’åº¦çš„ä¸´ç•Œé€’å¢é‡ï¼Œå½“å¢é‡å°äºè¯¥å‚æ•°æ—¶ï¼Œé…å‡†ç®—æ³•ç»“æŸï¼Œå®Œæˆé…å‡†ï¼Œè¯¥å‚æ•°æ˜¯ NDT é…å‡†ç®—æ³•çš„æ”¶æ•›æ¡ä»¶ã€‚æ­¥é•¿å‚æ•°step_sizeè¡¨ç¤ºçš„æ˜¯ç‰›é¡¿è¿­ä»£æ³•å…è®¸çš„æœ€å¤§æ­¥é•¿ï¼Œndt_res è¡¨ç¤ºçš„æ˜¯ NDT é…æ·®ç®—æ³•çš„ç½‘æ ¼åˆ’åˆ†åˆ†è¾¨ç‡çš„å¤§å°ï¼Œåˆ†è¾¨ç‡å¤§åˆ™ç½‘æ ¼æ‰€å«ç‚¹çš„æ•°é‡æ•´ä½“è¾ƒå¤šï¼Œä¸€èˆ¬ä¸å°‘äº5ä¸ªã€‚max_iter è¡¨ç¤ºçš„æ˜¯ç‰›é¡¿è¿­ä»£æ³•çš„æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œfiltered_scan_ptr ä½œä¸º NDT ç®—æ³•çš„è¾“å…¥æºç‚¹äº‘ã€‚ 12345678910// è®¾ç½®è½¬æ¢å‚æ•°Epsilonã€æœ€å¤§æ­¥é•¿ã€ç½‘æ ¼å¤§å°æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œè®¾ç½®è¾“å…¥ç‚¹äº‘ä¸ºå·²è¿‡æ»¤ç‚¹äº‘ if (_method_type == MethodType::PCL_GENERIC) { ndt.setTransformationEpsilon(trans_eps); ndt.setStepSize(step_size); ndt.setResolution(ndt_res); ndt.setMaximumIterations(max_iter); ndt.setInputSource(filtered_scan_ptr); } //...(ä¸‹ç•¥) â€‹ å…¨å±€åœ°å›¾map åˆå§‹åŒ–ä¹‹åï¼Œndt.setlnputTarget å‡½æ•°å°†ç¬¬ä¸€å¸§ç‚¹äº‘ä½œä¸º NDT é…å‡†ç®—æ³•çš„è¾“å…¥ç›®æ ‡ç‚¹äº‘ã€‚ç»“åˆä¸Šä¸€æ®µä»£ç å¯ä»¥å¾—åˆ° NDT ç›®æ ‡ç‚¹äº‘ä¸ºmapå…¨å±€åœ°å›¾ï¼ŒNDT æºç‚¹äº‘ä¸ºæ¯ä¸€æ¬¡æ¥æ”¶åˆ°çš„é™é‡‡æ ·è¿‡æ»¤ç‚¹äº‘ filtered_scan_ptrã€‚ 123456789// å°†ç¬¬ä¸€å¼ åœ°å›¾map_ptrè®¾ç½®è¾“å…¥NDTç‚¹äº‘ static bool is_first_map = true; if (is_first_map == true) { if (_method_type == MethodType::PCL_GENERIC) ndt.setInputTarget(map_ptr); //...(ä¸‹ç•¥) is_first_map = false; } â€‹ NDT é…å‡†ç®—æ³•éœ€è¦æä¾›ä¸€ä¸ªä½å§¿åˆå€¼ï¼Œè¯¥ä½å§¿åˆå€¼ç”¨æ¥è®¡ç®—é…å‡†ç®—æ³•çš„åˆå§‹å˜æ¢çŸ©é˜µï¼Œç„¶åå†åˆ©ç”¨ç‰›é¡¿è¿­ä»£æ³•è¿›è¡Œä¸æ–­é€‰ä»£ä¼˜åŒ–ç›´è‡³è¾¾åˆ°æ”¶æ•›æˆ–è€…æœ€å¤§è¿­ä»£æ¬¡æ•°ã€‚Autowareåˆ©ç”¨IMUã€é‡Œç¨‹è®¡æ•°æ®èåˆæä¾›ä¸€ä¸ªæ›´åŠ å‡†ç¡®çš„ä½å§¿åˆå€¼ã€‚è½¦è¾†ä½å§¿æ˜¯éšç€æ—¶é—´å˜åŒ–çš„ï¼Œä¸Šä¸€æ—¶åˆ»çš„ä½å§¿åŠ ä¸Šä½å§¿çš„å˜åŒ–é‡å¾—åˆ°å½“å‰æ—¶åˆ»çš„ä½å§¿ï¼ŒNDTé…å‡†ç®—æ³•æ‰€éœ€è¦çš„åˆå§‹ä½ç½®å¯ä»¥åˆ©ç”¨å‰ä¸€å¸§ä½å§¿åŠ ä¸Šå‰åä¸¤å¸§ä½å§¿å˜åŒ–æ¥å¾—åˆ°ã€‚æ ¹æ®ä¼ æ„Ÿå™¨çš„ä½¿ç”¨æƒ…å†µï¼Œæ¥é€‰æ‹©åˆå§‹ä½å§¿è®¡ç®—æ–¹æ³•ã€‚å…¶ä¸­ï¼Œimu_odom_calc, imu_calc, odom_calc åˆ†åˆ«è¡¨ç¤ºé€‰æ‹© imu ä¸é‡Œç¨‹è®¡è”åˆï¼Œå•ç‹¬ä½¿ç”¨imuæˆ–é‡Œç¨‹è®¡æ—¶çš„åˆå€¼è®¡ç®—å‡½æ•°ã€‚å½“ä¸ä½¿ç”¨ IMU ä¸é‡Œç¨‹è®¡è®¡ç®—åˆå€¼çš„è‚˜å€™ï¼Œä½¿ç”¨ guess_pose ä½œä¸º NDT é…å‡†ç®—æ³•çš„åˆå§‹ä½å§¿ guess_pose_for_ndtã€‚ä»£ç ä¸­ä½¿ç”¨ guess_pose_for_ndt åˆå§‹ä½å§¿æ¥æ„é€ åˆå§‹å˜æ¢çŸ©é˜µã€‚ 12345678910111213141516171819202122232425262728293031guess_pose.x = previous_pose.x + diff_x;guess_pose.y = previous_pose.y + diff_y;guess_pose.z = previous_pose.z + diff_z;guess_pose.roll = previous_pose.roll;guess_pose.pitch = previous_pose.pitch;guess_pose.yaw = previous_pose.yaw + diff_yaw;// é€‰æ‹©ä½¿ç”¨åˆå€¼çš„è®¡ç®—æ–¹æ³•ï¼Œç¬¬ä¸€ç§ä½¿ç”¨imuä¸é‡Œç¨‹è®¡èåˆif (_use_imu == true &amp;&amp; _use_odom == true) imu_odom_calc(current_scan_time);if (_use_imu == true &amp;&amp; _use_odom == false) imu_calc(current_scan_time);if (_use_imu == false &amp;&amp; _use_odom == true) odom_calc(current_scan_time);// å£°æ˜NDTåˆå€¼pose guess_pose_for_ndt;if (_use_imu == true &amp;&amp; _use_odom == true) guess_pose_for_ndt = guess_pose_imu_odom;else if (_use_imu == true &amp;&amp; _use_odom == false) guess_pose_for_ndt = guess_pose_imu;else if (_use_imu == false &amp;&amp; _use_odom == true) guess_pose_for_ndt = guess_pose_odom;else // è‹¥æœªä½¿ç”¨imuæˆ–é‡Œç¨‹è®¡ï¼Œç”¨guess_pose guess_pose_for_ndt = guess_pose;// åˆ©ç”¨guess_pose_for_ndtä½ç½®çš„ä½å§¿æ—‹è½¬é‡æ¥åˆå§‹åŒ–xyzè½´çš„æ—‹è½¬å‘é‡Eigen::AngleAxisf init_rotation_x(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX());Eigen::AngleAxisf init_rotation_y(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());Eigen::AngleAxisf init_rotation_z(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());// ä½¿ç”¨guess_pose_for_ndtçš„ä¸‰ç»´åæ ‡åˆå§‹åŒ–å¹³ç§»å‘é‡Eigen::Translation3f init_translation(guess_pose_for_ndt.x, guess_pose_for_ndt.y, guess_pose_for_ndt.z);Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol; â€‹ è¿™æ®µä»£ç ä¸»è¦è¿›è¡Œäº† NDT çš„é…å‡†æ“ä½œã€‚ä»£ç é¦–å…ˆè·å–å½“å‰æ—¶é—´æˆ³ä½œä¸ºé…å‡†è®¡æ—¶çš„èµ·å§‹æ—¶é—´t4ï¼Œç„¶åæ ¹æ®æ–¹æ³•ç±»å‹è¿›è¡Œ NDT é…å‡†ã€‚ndt.align å‡½æ•°å¼€å§‹è¿›è¡Œ NDT é…å‡†ï¼Œè¯¥å‡½æ•°ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è¾“å‡ºç‚¹äº‘ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯åˆå§‹åŒ–å˜æ¢çŸ©é˜µï¼Œå…¶ä¸­ï¼Œåˆå§‹åŒ–å˜æ¢çŸ©é˜µæ˜¯ä¸Šä¸€æ­¥å¾—åˆ°çš„ init_guessï¼Œndt.align å®é™…ä¸Šè°ƒç”¨äº† ndt.computeTransformation å‡½æ•°å¾—åˆ°æœ€ç»ˆçš„é…å‡†ç‚¹äº‘ã€‚ä»£ç ä½¿ç”¨ ndt.getFitnessScore()è®¡ç®—åŒ¹é…å¾—åˆ†ï¼Œä¸€èˆ¬æ¥è¯´åŒ¹é…å¾—åˆ†å°äº 1ã€‚t_localizer è¡¨ç¤ºçš„æ˜¯ NDT é…å‡†ç®—æ³•å¾—åˆ°çš„æ¿€å…‰é›·è¾¾ç›¸å¯¹äºmap åæ ‡ç³»çš„æœ€ç»ˆå˜æ¢çŸ©é˜µã€‚ 1234567891011121314151617181920t3_end = ros::Time::now();d3 = t3_end - t3_start;t4_start = ros::Time::now();pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);// æ ¹æ®_method_typeç±»å‹è¿›è¡Œé…å‡†if (_method_type == MethodType::PCL_GENERIC){ // å¼€å§‹é…å‡†ï¼Œndt.alignä»¥init_guessä¸ºåˆå€¼è¿›è¡Œè¿­ä»£ä¼˜åŒ– ndt.align(*output_cloud, init_guess); // åˆ©ç”¨ndt.getFitnessScore()è®¡ç®—ç›®æ ‡ç‚¹äº‘ä¸æºç‚¹äº‘æœ€è¿‘ç‚¹é—´çš„æ¬§å¼è·ç¦»å¹³æ–¹å’Œä½œä¸ºåŒ¹é…å¾—åˆ† fitness_score = ndt.getFitnessScore(); // é€šè¿‡NDTé…å‡†å¾—åˆ°æœ€ç»ˆé›·è¾¾ç›¸å¯¹äºmapåæ ‡ç³»çš„å˜æ¢çŸ©é˜µt_localizer t_localizer = ndt.getFinalTransformation(); // åˆ¤æ–­æ˜¯å¦æ”¶æ•› has_converged = ndt.hasConverged(); // å¾—åˆ°æœ€åçš„è¿­ä»£æ¬¡æ•° final_num_iteration = ndt.getFinalNumIteration(); transformation_probability = ndt.getTransformationProbability();}//...(ä¸‹ç•¥) â€‹ è¿™æ®µä»£ç é¦–å…ˆæ±‚å‡ºè½¦ä½“ç›¸å¯¹äºåŸç‚¹çš„å˜æ¢çŸ©é˜µ t_base linkï¼Œç„¶åpcl::transformPointcloud å‡½æ•°ä¸»è¦å°†é™é‡‡æ ·åçš„åŸå§‹ç‚¹äº‘ scan å˜æ¢ä¸ºç‚¹äº‘*transformed_scan_ptrï¼Œå˜æ¢æ—¶é‡‡ç”¨çš„å˜æ¢çŸ©é˜µä¸ºåŸºäº NDT é…å‡†æ–¹æ³•å¾—åˆ°çš„å˜æ¢çŸ©é˜µã€‚mat_lï¼Œmat_b åˆ†åˆ«è¡¨ç¤ºæ¿€å…‰é›·è¾¾ä¸è½¦ä½“ç›¸å¯¹äºå…¨å±€åœ°å›¾mapçš„æ—‹è½¬çŸ©é˜µï¼Œåˆ†åˆ«ç”± t_localizerä¸t_base_ link çŸ©é˜µçš„å‰ä¸‰åˆ—ä¸å‰ä¸‰è¡Œè¿›è¡Œå¯¹åº”èµ‹å€¼ã€‚ndt_pose è¡¨ç¤º NDT é…å‡†åçš„è½¦è¾†åœ¨å…¨å±€åœ°å›¾ä¸­çš„ä½å§¿ï¼Œå…¶åæ ‡ä½ç½®ç”±t_base_link å˜æ¢çŸ©é˜µçš„å¹³ç§»å‘é‡è¿›è¡Œèµ‹å€¼ã€‚â€‹ æ­¤æ—¶çš„ ndt_pose ä½œä¸ºå½“å‰æ—¶åˆ»çš„ä½å§¿ä¼°è®¡ current_poseã€‚æœ€ååˆ©ç”¨å½“å‰æ‰«ææ—¶é—´current_scan_time å‡å»ä¸Šä¸€å¸§æ‰«ææ—¶é—´ previous_scan_time å¾—åˆ°æ¿€å…‰é›·è¾¾çš„æ‰«æé—´éš”æ—¶é—´scan_durationã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445t_base_link = t_localizer * tf_ltob;// å°†åŸå§‹å›¾åƒç»è¿‡NDTå˜æ¢åè¾“å‡ºç‚¹äº‘transformed_scan_ptrpcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, t_localizer);tf::Matrix3x3 mat_l, mat_b;// t_localizeä¸º4*4çš„å˜æ¢çŸ©é˜µï¼Œå…¶ä¸­å‰ä¸‰è¡Œå‰ä¸‰åˆ—ä¸ºæ—‹è½¬çŸ©é˜µï¼Œç¬¬å››åˆ—ç¬¬ä¸‰è¡Œä¸ºå¹³ç§»å‘é‡mat_l.setValue(static_cast&lt;double&gt;(t_localizer(0, 0)), static_cast&lt;double&gt;(t_localizer(0, 1)), static_cast&lt;double&gt;(t_localizer(0, 2)), static_cast&lt;double&gt;(t_localizer(1, 0)), static_cast&lt;double&gt;(t_localizer(1, 1)), static_cast&lt;double&gt;(t_localizer(1, 2)), static_cast&lt;double&gt;(t_localizer(2, 0)), static_cast&lt;double&gt;(t_localizer(2, 1)), static_cast&lt;double&gt;(t_localizer(2, 2)));mat_b.setValue(static_cast&lt;double&gt;(t_base_link(0, 0)), static_cast&lt;double&gt;(t_base_link(0, 1)), static_cast&lt;double&gt;(t_base_link(0, 2)), static_cast&lt;double&gt;(t_base_link(1, 0)), static_cast&lt;double&gt;(t_base_link(1, 1)), static_cast&lt;double&gt;(t_base_link(1, 2)), static_cast&lt;double&gt;(t_base_link(2, 0)), static_cast&lt;double&gt;(t_base_link(2, 1)), static_cast&lt;double&gt;(t_base_link(2, 2)));// æ›´æ–°localizer_poselocalizer_pose.x = t_localizer(0, 3);localizer_pose.y = t_localizer(1, 3);localizer_pose.z = t_localizer(2, 3);//é€šè¿‡mat_l.getRPYè®¾ç½®localizer_poseçš„æ—‹è½¬rpyè§’åº¦mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);// æ›´æ–°ndt_posendt_pose.x = t_base_link(0, 3);ndt_pose.y = t_base_link(1, 3);ndt_pose.z = t_base_link(2, 3);mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);// å°†NDTé…å‡†åçš„ä½ç½®ä½œä¸ºå½“å‰ä½ç½®current_pose.x = ndt_pose.x;current_pose.y = ndt_pose.y;current_pose.z = ndt_pose.z;current_pose.roll = ndt_pose.roll;current_pose.pitch = ndt_pose.pitch;current_pose.yaw = ndt_pose.yaw;// ä»¥å½“å‰ä½ç½®ä¸ºåæ ‡åŸç‚¹transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));// å½“å‰ä½ç½®æ—‹è½¬è§’åº¦RPYï¼Œè®¾ç½®å››å…ƒæ•°Qq.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);transform.setRotation(q);// å‘å¸ƒåæ ‡å˜æ¢ä¿¡æ¯br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;map&quot;, &quot;base_link&quot;));// è®¡ç®—æ‰«æé—´éš”æ—¶é—´scan_duration = current_scan_time - previous_scan_time;double secs = scan_duration.toSec(); â€‹ è¿™ä¸€éƒ¨åˆ†ä»£ç è®¡ç®—äº†ç›¸é‚»ä¸¤å¸§ä¹‹é—´çš„ä½ç§» diff å’Œåèˆªè§’å˜åŒ– diff_yawã€‚ NDTå»ºå›¾è¿‡ç¨‹è¦æ±‚è½¦è¾†å°½é‡ä¿æŒåŒ€é€Ÿè¡Œé©¶ï¼Œç”±äºç›¸é‚»ä¸¤å¸§æ—¶é—®å·®è¾ƒå°ï¼Œæ‰€ä»¥è½¦è¾†çŸ­æ—¶é—´å†…è¿‘ä¼¼ä¸ºåŒ€é€Ÿæ¨¡å‹ï¼Œåˆ©ç”¨xï¼Œyï¼Œzæ–¹å‘çš„ä½ç§»å˜åŒ–ä¸æ¿€å…‰é›·è¾¾æ‰«æé—´éš”çš„æ¯”å€¼ä½œä¸ºå½“å‰çš„é€Ÿåº¦ current_velocityã€‚æœ€åä»£ç å°†å½“å‰ä½å§¿ current_pose èµ‹å€¼äºå‰ä¸€å¸§ä½å§¿previous_poseï¼Œ ä¸ºä¸‹ä¸€æ¬¡ NDT é…å‡†æä¾›è®¡ç®—åˆå€¼ã€‚ 123456789101112131415161718// è®¡ç®—ç›¸é‚»ä½å§¿åå·® (curren_pos - previous_pos)diff_x = current_pose.x - previous_pose.x;diff_y = current_pose.y - previous_pose.y;diff_z = current_pose.z - previous_pose.z;diff_yaw = calcDiffForRadian(current_pose.yaw, previous_pose.yaw);diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);// åˆ©ç”¨å‰åä¸¤å¸§æ‰«æä½ç½®åå·®ä¸æ‰«æé—´éš”è®¡ç®—æ­¤æ—¶çš„ç¬æ—¶é€Ÿåº¦current_velocity_x = diff_x / secs;current_velocity_y = diff_y / secs;current_velocity_z = diff_z / secs;// å½“å‰ä½å§¿current_poseèµ‹äºˆimuå½“å‰ä½å§¿å¹¶æ›´æ–°æ ¡æ­£current_pose_imu.x = current_pose.x;current_pose_imu.y = current_pose.y;current_pose_imu.z = current_pose.z;current_pose_imu.roll = current_pose.roll;current_pose_imu.pitch = current_pose.pitch;current_pose_imu.yaw = current_pose.yaw;//...(ä¸‹ç•¥) â€‹ è¿™ä¸€éƒ¨åˆ†ä»£ç ä¸»è¦è´Ÿè´£åœ°å›¾çš„æ›´æ–°ï¼Œæ¯éš”ä¸€å®šçš„è·ç¦»ä¼šæ›´æ–°ä¸€æ¬¡åœ°å›¾ï¼Œè¿™é‡Œçš„è·ç¦»ç”± shift è¡¨ç¤ºã€‚added_pose æ˜¯ä¸Šä¸€å¸§è½¦è¾†çš„ä½å§¿ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°åœ°å›¾ã€‚å½“å‰åä¸¤å¸§è·ç¦»å·® shift å¤§äºmin_add scan_ shift æœ€å°æ›´æ–°è·ç¦»æ—¶ï¼Œå°†è½¬æ¢åçš„ç‚¹äº‘æ•°æ®*transformed scan ptr åŠ å…¥åˆ° map å…¨å±€åœ°å›¾ï¼Œç„¶åå°†å½“å‰ä½å§¿ current_pose èµ‹å€¤äºadded_pose è¿›è¡Œä½å§¿æ›´æ–°ã€‚æœ€åæŠŠå½“å‰é…å‡†æ‹¼æ¥åçš„ç‚¹äº‘æ•°æ® map_ptr è®¾ç½®ä¸ºä¸‹ä¸€æ¬¡é…å‡†çš„è¾“å…¥ç›®æ ‡ç‚¹äº‘ã€‚ 12345678910111213141516171819202122232425 // è®¡ç®—added_poseä¸current_poseé—´è·ç¦» double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0)); if (shift &gt;= min_add_scan_shift) { // å°†ç»è¿‡åæ ‡è½¬æ¢åçš„transformed_scan_ptråŠ åˆ°mapä¸­å®Œæˆæ‹¼æ¥ map += *transformed_scan_ptr; added_pose.x = current_pose.x; added_pose.y = current_pose.y; added_pose.z = current_pose.z; added_pose.roll = current_pose.roll; added_pose.pitch = current_pose.pitch; added_pose.yaw = current_pose.yaw; if (_method_type == MethodType::PCL_GENERIC) ndt.setInputTarget(map_ptr); //...(ä¸‹ç•¥) } // å£°æ˜sensor_msgs::PointCloud2ç‚¹äº‘å¯¹è±¡ sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2); // æ•°æ®ç±»å‹è½¬æ¢ pcl::toROSMsg(*map_ptr, *map_msg_ptr); // å‘å¸ƒç‚¹äº‘ ndt_map_pub.publish(*map_msg_ptr); //...(ä¸‹ç•¥)} â‘¤ odom_callbackå‡½æ•°â€‹ odom_callback å‡½æ•°ç”±ros::Subscriber odom_sub = nh.subscribe(â€œvehicle/odomâ€, 100000, odom_callback)æ‰€è°ƒç”¨ã€‚odom_callback å‡½æ•°ä»¥é‡Œç¨‹è®¡æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‡½æ•°å‚æ•°ï¼Œä¸»è¦è°ƒç”¨ odom_calc åˆå€¼è®¡ç®—å‡½æ•°ï¼Œè¯¥å‡½æ•°ä»¥æ¥æ”¶åˆ°çš„é‡Œç¨‹è®¡æ•°æ®æ—¶é—´æˆ³ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œæ±‚å¾— NDT çš„åˆå§‹ä½å§¿ä¼°è®¡ã€‚ 12345static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input){ odom = *input; odom_calc(input-&gt;header.stamp);} â€‹ odom_calcé‡Œç¨‹è®¡åˆå§‹ä½å§¿è®¡ç®—å‡½æ•°å¦‚ä¸‹ 12345678910111213141516171819202122232425262728293031static void odom_calc(ros::Time current_time){ static ros::Time previous_time = current_time; // è·å–ä¸¤å¸§æ—¶é—´å·® double diff_time = (current_time - previous_time).toSec(); // è®¡ç®—ä¸¤å¸§æ—¶é—´é—´éš”å†…çš„é‡Œç¨‹è®¡æ—‹è½¬è§’åº¦ double diff_odom_roll = odom.twist.twist.angular.x * diff_time; double diff_odom_pitch = odom.twist.twist.angular.y * diff_time; double diff_odom_yaw = odom.twist.twist.angular.z * diff_time; // æ›´æ–°å½“å‰é‡Œç¨‹è®¡ä½ç½®çš„è§’åº¦ current_pose_odom.roll += diff_odom_roll; current_pose_odom.pitch += diff_odom_pitch; current_pose_odom.yaw += diff_odom_yaw; // diff_distanceä¸ºxæ–¹å‘çš„å˜åŒ–è·ç¦»ï¼Œoffsetä¸ºè½¦èº«ä¸ç¨³å®šé€ æˆçš„è®¡ç®—åå·® double diff_distance = odom.twist.twist.linear.x * diff_time; offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw); offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw); offset_odom_z += diff_distance * sin(-current_pose_odom.pitch); offset_odom_roll += diff_odom_roll; offset_odom_pitch += diff_odom_pitch; offset_odom_yaw += diff_odom_yaw; // å¯¹åˆå§‹ä½ç½®ä¿®æ­£ guess_pose_odom.x = previous_pose.x + offset_odom_x; guess_pose_odom.y = previous_pose.y + offset_odom_y; guess_pose_odom.z = previous_pose.z + offset_odom_z; guess_pose_odom.roll = previous_pose.roll + offset_odom_roll; guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch; guess_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw; previous_time = current_time;} â‘¥ imu_callbackå‡½æ•°â€‹ imu_callbackå‡½æ•°ç”±ros::Subscriber imu_sub = nh.subscribe(_imu_topic, 100000, imu_callback)è°ƒç”¨ã€‚è¯¥å‡½æ•°ä¸»è¦æ˜¯åˆ©ç”¨ imu_calc (input-&gt;header.stamp) å‡½æ•°è®¡ç®—ä½ç½®åˆå€¼ï¼Œä¸º NDT é…å‡†æä¾›åˆå§‹ä½ç½®ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input){ if (_imu_upside_down) imuUpsideDown(input); // æ¥æ”¶åˆ°imuæ¶ˆæ¯çš„æ—¶å€™è·å–å½“å‰æ—¶é—´æˆ³ const ros::Time current_time = input-&gt;header.stamp; static ros::Time previous_time = current_time; // è®¡ç®—å‰åä¸¤æ¬¡æ¥æ”¶æ¶ˆæ¯çš„å¾®å°æ—¶é—´å·® const double diff_time = (current_time - previous_time).toSec(); double imu_roll, imu_pitch, imu_yaw; // å£°æ˜ç”¨äºè½¬æ¢çš„å››å…ƒæ•° tf::Quaternion imu_orientation; // å°†IMUé‡‡é›†åˆ°çš„å››å…ƒæ•°æ¶ˆæ¯è½¬åŒ–ä¸ºTFç±»å‹ tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation); // åˆå§‹åŒ–3*3æ—‹è½¬çŸ©é˜µï¼Œä½¿ç”¨getRPYè·å–å½“å‰rpyæ—‹è½¬è§’ tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw); // è½¬åŒ–ä¸ºå¼§åº¦ imu_roll = wrapToPmPi(imu_roll); imu_pitch = wrapToPmPi(imu_pitch); imu_yaw = wrapToPmPi(imu_yaw); static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw; const double diff_imu_roll = calcDiffForRadian(imu_roll, previous_imu_roll); const double diff_imu_pitch = calcDiffForRadian(imu_pitch, previous_imu_pitch); const double diff_imu_yaw = calcDiffForRadian(imu_yaw, previous_imu_yaw); imu.header = input-&gt;header; // è·å–imuåœ¨xæ–¹å‘çš„çº¿æ€§åŠ é€Ÿåº¦ imu.linear_acceleration.x = input-&gt;linear_acceleration.x; imu.linear_acceleration.y = 0; imu.linear_acceleration.z = 0; if (diff_time != 0) { // è‹¥æ—¶é—´å·®ä¸ç­‰äº0ï¼Œimuåœ¨å·¥ä½œï¼Œè®¡ç®—imuç¬æ—¶è§’é€Ÿåº¦ imu.angular_velocity.x = diff_imu_roll / diff_time; imu.angular_velocity.y = diff_imu_pitch / diff_time; imu.angular_velocity.z = diff_imu_yaw / diff_time; } else { // å¦åˆ™è§’é€Ÿåº¦ç½®0 imu.angular_velocity.x = 0; imu.angular_velocity.y = 0; imu.angular_velocity.z = 0; } // è®¡ç®—ä½ç½®åˆå€¼ï¼Œæä¾›åˆå§‹ä½ç½® imu_calc(input-&gt;header.stamp); previous_time = current_time; previous_imu_roll = imu_roll; previous_imu_pitch = imu_pitch; previous_imu_yaw = imu_yaw;} 3.2 ndt_matchingèŠ‚ç‚¹è§£æâ€‹ ndt_matchingèŠ‚ç‚¹é¦–å…ˆè¯»å–points_map_loaderå‘å¸ƒçš„ç‚¹äº‘åœ°å›¾ï¼Œå°†æ­¤åœ°å›¾è®¾ç½®ä¸ºtargetã€‚åŒæ—¶ï¼Œä½¿ç”¨ä¸Šè¿°2.2å°èŠ‚ä¸­voxel_grid_filterå°†æ¿€å…‰é›·è¾¾å‘å¸ƒçš„/points_rawè¯é¢˜å‘å¸ƒçš„/sensor_msgs/PointCloud2ç‚¹äº‘æ¶ˆæ¯é™é‡‡æ ·ï¼Œå°†é™é‡‡æ ·åçš„ç‚¹äº‘è®¾ç½®ä¸ºsourceã€‚æ­¤ååˆ©ç”¨ndtè¿›è¡Œé…å‡†ï¼Œå¾—å‡ºé½æ¬¡å˜æ¢çŸ©é˜µï¼Œå¯ä»¥å¾—åˆ°è½¦çš„å‡ ä¸ªåæ ‡ç³»çš„ä½ç½®ä¿¡æ¯ï¼Œä»è€Œè¿›è¡Œå®šä½ã€‚ 3.2.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch lidar_localizer ndt_matching.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹Computing é€‰é¡¹å¡ -&gt; Localization/ lidar_localizer -&gt; ndt_matchingï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 3.2.2 ç¨‹åºè·¯å¾„12345//æºä»£ç è·¯å¾„~/autoware.ai/src/autoware/core_perception/lidar_localizer/nodes/ndt_matching/ndt_matching.cpp//launchå¯åŠ¨æ–‡ä»¶è·¯å¾„~/autoware.ai/src/autoware/core_perception/lidar_localizer/launch/ndt_matching.launch 3.2.3 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ method_type int ndtä½¿ç”¨ç®—æ³•ç±»å‹ use_gnss bool æ˜¯å¦ä½¿ç”¨gnss use_odom bool æ˜¯å¦ä½¿ç”¨é‡Œç¨‹è®¡å‡å°‘è¯¯å·® use_imu bool æ˜¯å¦ä½¿ç”¨IMUå‡å°‘è¯¯å·® imu_upside_down bool IMUåæ ‡ç³»æ˜¯å¦ç¿»è½¬ imu_topic String IMUè¯é¢˜å queue_size int æ¶ˆæ¯ç¼“å†²åŒºå¤§å° offset String ä½å§¿åç§»æ ¡æ­£ get_height bool zè½´é«˜åº¦è¾ƒæ­£ use_local_transform bool ä½¿ç”¨æœ¬åœ°tf sync bool æ˜¯å¦å°†è¯é¢˜å/points_rawæ˜ å°„ä¸º/sync_drivers/points_raw output_log_data bool æ˜¯å¦è¾“å‡ºlog output_tf_frame_id String tf frameID é»˜è®¤ä¸ºbase_link gnss_reinit_fitness double æ¯”è¾ƒfitness_coreçš„å‚è€ƒï¼Œé»˜è®¤å€¼ä¸º500.0 3.2.4 è®¢é˜…è¯é¢˜å è¯é¢˜å æ¶ˆæ¯ç±»å‹ /config/ndt autoware_config_msgs/ConfigNDT /gnss_pose geometry_msgs/PoseStamped /initialpose geometry_msgs/PoseWithCovarianceStamped /filtered_points sensor_msgs/PointCloud2 /vehicle/odom nav_msgs/Odometry /imu_raw sensor_msgs/Imu /vehicle/twist geometry_msgs/TwistStamped 3.2.5 å‘å¸ƒè¯é¢˜å è¯é¢˜å æ¶ˆæ¯ç±»å‹ /predict_pose geometry_msgs::PoseStamped /predict_pose_imu geometry_msgs::PoseStamped /predict_pose_odom geometry_msgs::PoseStamped /predict_pose_imu_odom geometry_msgs::PoseStamped /ndt_pose geometry_msgs::PoseStamped /localizer_pose geometry_msgs::PoseStamped /estimate_twist geometry_msgs::TwistStamped /estimated_vel_mps std_msgs::Float32 /estimated_vel_kmph std_msgs::Float32 /estimated_vel geometry_msgs::Vector3Stamped /time_ndt_matching std_msgs::Float32 /ndt_stat autoware_msgs::NDTStat /ndt_reliability std_msgs::Float32 3.2.6 ä»£ç æ³¨è§£â‘  æµç¨‹ç®€ä»‹â€‹ ndt_matchingèŠ‚ç‚¹ä¸ndt_mappingèŠ‚ç‚¹ç»“æ„ç›¸ä¼¼ï¼Œä¸åŒä¹‹å¤„åœ¨äºndt_matchingåˆ©ç”¨scan_to_matchingæ–¹æ³•å®ç°å®šä½ã€‚è¯¥æ–¹æ³•å°†å·²çŸ¥çš„é«˜ç²¾åº¦åœ°å›¾mapä½œä¸ºå…¨å±€åœ°å›¾global mapï¼Œåˆ©ç”¨æ¿€å…‰é›·è¾¾è·å–å½“å‰å¸§çš„æ¿€å…‰ç‚¹äº‘æ•°æ®scanï¼Œä¸å›ºå®šä¸åŠ¨çš„å…¨å±€åœ°å›¾global_mapè¿›è¡Œndté…å‡†ï¼Œæ±‚å‡ºæœ€ç»ˆè½¦ä½“ç›¸å¯¹äºå…¨å±€åœ°å›¾çš„ä½å§¿ï¼Œä»è€Œå®ç°ç²¾å‡†å®šä½ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹: â€‹ â‘ ç”±æ¿€å…‰é›·è¾¾è·å–çš„æ¿€å…‰ç‚¹äº‘æ•°æ®é™é‡‡æ ·ä½œä¸º NDT ç®—æ³•çš„è¾“å…¥æºç‚¹äº‘ï¼Œè¿™éƒ¨åˆ†ä¸ ndt mapping ä¸€è‡´â€‹ â‘¡å°†å…¨å±€åœ°å›¾ global map ä½œä¸º NDT ç®—æ³•çš„è¾“å…¥ç›®æ ‡ç‚¹äº‘ï¼›â€‹ â‘¢æ­¤å¤„ GNSS çš„ä¸»è¦ç›®æ ‡æ˜¯å®ç°é‡å®šä½ï¼Œå½“ imu ä¸odom äº§ç”Ÿç´¯è®¡è¯¯å·®å½±å“åˆ°NDT é…å‡†ç®—æ³•çš„æ•ˆæœï¼Œæˆ–è€…æ˜¯ä½¿ç”¨ gnss æ—¶å¹¶æœªå°† gnss ä½å§¿åˆå§‹åŒ–çš„æ—¶å€™ï¼Œæ­¤æ—¶å°†å½“å‰gnss ä½å§¿ä½œä¸ºå‡†ç¡®çš„è½¦è¾†ä½å§¿ä¿¡æ¯ï¼Œå®ƒèƒ½å¤ŸåŠæ—¶çº æ­£ imu ä¸odom çš„ç´¯è®¡è¯¯å·®ï¼›â€‹ â‘£åˆ©ç”¨ imu, odom ç­‰ä¼ æ„Ÿå™¨è·å– NDT æ‰€éœ€çš„åˆå§‹ä½å§¿ä¼°è®¡ï¼›â€‹ â‘¤è¿›è¡Œ NDT é…å‡†;â€‹ â‘¥æ±‚å¾—è½¦è¾†ç›¸å¯¹äº å…¨å±€åœ°å›¾çš„ä½å§¿ current poseã€‚ â€‹ ndt matching èŠ‚ç‚¹çš„main å‡½æ•°(æºç ç•¥)ä¸ ndt mapping èŠ‚ç‚¹å¾ˆç›¸ä¼¼ï¼Œä¸»è¦è¿›è¡Œè¯é¢˜æ¶ˆæ¯çš„å‘å¸ƒï¼Œå‘å¸ƒçš„è¯é¢˜æœ‰/predict pose (é¢„æµ‹çš„ä½å§¿ï¼‰ï¼Œ/predict pose imu(åˆ©ç”¨imu é¢„æµ‹çš„ä½å§¿ï¼‰ï¼Œ/predict_pose_odom ï¼ˆåˆ©ç”¨é‡Œç¨‹è®¡é¢„æµ‹å¾—åˆ°çš„ä½å§¿ï¼‰ï¼Œ/predict_pose_imu_odom (åˆ©ç”¨é‡Œç¨‹è®¡ä¸ imu è”åˆå¾—åˆ°çš„ä½å§¿)ç­‰å‚æ•°ã€‚è®¢é˜…çš„è¯é¢˜æœ‰config/ndt (ndt é…ç½®å‚æ•°ï¼‰ï¼Œgnss_pose(ä½¿ç”¨gnss å¾—åˆ°çš„ä½å§¿)ï¼Œinitial_pos(åˆå§‹ä½å§¿)ï¼Œfiltered_pointsï¼ˆè¿‡æ»¤å¤„ç†åçš„æ¿€å…‰ç‚¹é›†ï¼‰ï¼Œ/vehicle/odomï¼ˆé‡Œç¨‹æ±æ¶ˆæ¯ï¼‰ã€‚ â‘¡ param_callbackå‡½æ•°â€‹ param_callback å›è°ƒå‡½æ•°çš„å‚æ•°ä¸º NDT é…ç½®å‚æ•°æ¶ˆæ¯(autoware_config_msgs::ConfigNDT.msgï¼‰ã€‚å‡½æ•°åˆ¤æ–­ _use_gnss ä¸ NDT é…ç½®å‚æ•° init_pos_gnss æ˜¯å¦ç›¸ç­‰ï¼Œuse_gnss è¡¨ç¤ºä½¿ç”¨ gnss è¿›è¡Œä½å§¿ä¼°è®¡ï¼Œinit_pos_gnss ç”¨æ¥è¡¨ç¤º gnss çš„åˆå§‹ä½ç½®ã€‚å¦‚æœ use_gnssä¸ init_pos_gnss ä¸ç›¸ç­‰ï¼Œåˆ™ init_pos_set=0, è¡¨ç¤ºæœªè¿›è¡Œä½å§¿åˆå§‹åŒ–ã€‚å½“ use_gnss==0, å³ä¸ä½¿ç”¨ gnss, ä»¥åŠ NDT å‚æ•°é…ç½®ä¸­çš„è½¦è¾†åˆå§‹ä½å§¿ä¸ initial_pose ä¸ç›¸ç­‰çš„æ—¶å€™ï¼Œä»¤ init_pos_set=0ã€‚è¯¥ä»£ç ä¸»è¦åˆ¤æ–­ gnss ä½¿ç”¨å‚æ•°ä¸ gnss åˆå§‹ä½å§¿æ˜¯å¦åˆå§‹åŒ–ã€‚ 123456789101112131415static void param_callback(const autoware_config_msgs::ConfigNDT::ConstPtr&amp; input){ if (_use_gnss != input-&gt;init_pos_gnss) { // ä½¿ç”¨gnssæ—¶è¦å¯¹gnssä½ç½®åˆå§‹åŒ–ï¼Œå¦‚æœä¸¤è€…ä¸åŒ¹é…ï¼Œå°†åˆå§‹ä½ç½®init_pos_setç½®ä¸º0 init_pos_set = 0; } else if (_use_gnss == 0 &amp;&amp; (initial_pose.x != input-&gt;x || initial_pose.y != input-&gt;y || initial_pose.z != input-&gt;z || initial_pose.roll != input-&gt;roll || initial_pose.pitch != input-&gt;pitch || initial_pose.yaw != input-&gt;yaw)) { init_pos_set = 0; } _use_gnss = input-&gt;init_pos_gnss; â€‹ è¯¥ä»£ç ä¸»è¦å¯¹ NDT é…å‡†çš„å‚æ•°è¿›è¡Œè®¾ç½®ï¼Œæ ¹æ®æ–¹æ³•ç±»å‹çš„ä¸åŒï¼Œå°† ConfigNDTæ¶ˆæ¯ä¸­çš„å‚æ•°ä½œä¸ºè¾“å…¥åŠ è½½åˆ° NDT é…å‡†ç®—æ³•ä¸­ã€‚å…¶ä¸­åŠ è½½çš„ NDT å‚æ•°æœ‰:æ”¶æ•›æ¡ä»¶ã€æœ€å¤§æ­¥é•¿ã€åˆ†è¾¨ç‡(ç½‘æ ¼åˆ’åˆ†å¤§å°)ä»¥åŠæœ€å¤§è¿­ä»£æ¬¡æ•°ã€‚ 1234567891011121314151617181920if (input-&gt;step_size != step_size){ step_size = input-&gt;step_size; // æŒ‰ç…§æ–¹æ³•ç±»å‹ä¸åŒä½¿ç”¨ndt.setResolution(ndt_res)å‡½æ•°è®¾ç½®NDTç½‘æ ¼å¤§å° if (_method_type == MethodType::PCL_GENERIC) ndt.setStepSize(step_size); //...(ä¸‹ç•¥)}// è®¾ç½®ndtç®—æ³•æ”¶æ•›æ¡ä»¶if (input-&gt;trans_epsilon != trans_eps){ trans_eps = input-&gt;trans_epsilon; //...(ä¸‹ç•¥)}// è®¾ç½®æœ€å¤§è¿­ä»£æ¬¡æ•°if (input-&gt;max_iterations != max_iter){ max_iter = input-&gt;max_iterations; //...(ä¸‹ç•¥)} â€‹ è¯¥ä»£ç å—ä¸»è¦åˆ¤æ–­æ˜¯å¦ä½¿ç”¨ GNSS ã€æ˜¯å¦å·²åˆå§‹åŒ–è½¦è¾†ä½å§¿ï¼Œå½“æœªä½¿ç”¨ GNSS å¹¶ä¸”æœªåˆå§‹åŒ–è½¦è¾†ä½å§¿æ—¶ï¼Œåˆ©ç”¨ NDT é…ç½®æ¶ˆæ¯è¿›è¡Œä½å§¿åˆå§‹åŒ–ã€‚å½“ä½¿ç”¨å±€éƒ¨å˜æ¢çš„æ—¶å€™ï¼Œéœ€è¦è¡¥å¿ä¸€ä¸ªå±€éƒ¨å˜æ¢çŸ©é˜µ local_transform.inverse()ï¼Œä»è€Œæ±‚å¾—è½¦è¾†ç›¸å¯¹äºå…¨å±€åœ°å›¾ map çš„åˆå§‹ä½å§¿ã€‚å±€éƒ¨å˜æ¢çŸ©é˜µ local_transform è¡¨ç¤ºçš„æ˜¯world åæ ‡ç³»ä¸åœ°é¢åæ ‡ç³» map ä¹‹é—´çš„å˜æ¢å…³ç³»ã€‚ 123456789101112131415161718192021222324252627 if (_use_gnss == 0 &amp;&amp; init_pos_set == 0) { // å¦‚æœæœªä½¿ç”¨gnssä¸”æœªåˆå§‹åŒ–è½¦è¾†ä½å§¿ï¼Œåˆ™ç”¨ndtå‚æ•°é…ç½®æ¶ˆæ¯ä¸­çš„ä½å§¿è¿›è¡Œåˆå§‹åŒ– initial_pose.x = input-&gt;x; //...(ä¸‹ç•¥) if (_use_local_transform == true) { // å¦‚æœä½¿ç”¨å±€éƒ¨å˜æ¢ï¼Œåœ¨æ±‚åˆå§‹ä½å§¿æ—¶è¦è¡¥å¿ä¸€ä¸ªå±€éƒ¨å˜æ¢çŸ©é˜µlocal_transform.inverse() tf2::Vector3 v(input-&gt;x, input-&gt;y, input-&gt;z); tf2::Quaternion q; q.setRPY(input-&gt;roll, input-&gt;pitch, input-&gt;yaw); tf2::Transform transform(q, v); initial_pose.x = (local_transform.inverse() * transform).getOrigin().getX(); initial_pose.y = (local_transform.inverse() * transform).getOrigin().getY(); initial_pose.z = (local_transform.inverse() * transform).getOrigin().getZ(); tf2::Matrix3x3 m(q); m.getRPY(initial_pose.roll, initial_pose.pitch, initial_pose.yaw); std::cout &lt;&lt; &quot;initial_pose.x: &quot; &lt;&lt; initial_pose.x &lt;&lt; std::endl; //...(ä¸‹ç•¥) } // è®¾ç½®åˆå§‹ä½å§¿ localizer_pose.x = initial_pose.x; localizer_pose.y = initial_pose.y; //...(ä¸‹ç•¥) }} â‘¢ gnss_callbackå‡½æ•°â€‹ gnss_callbackä¸»è¦å®ç°GNSSé‡å®šä½åŠŸèƒ½ï¼Œç”¨æ¥çº æ­£IMUä¸é‡Œç¨‹è®¡çš„ç§¯åˆ†ç´¯è®¡è¯¯å·®ï¼Œå½“ndté…å‡†ç»“æœè¾ƒå·®ï¼Œä¹Ÿéœ€è¦GNSSé‡å®šä½æ¥æä¾›é…å‡†åˆå€¼ã€‚ 123456789101112131415161718192021222324252627282930static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input){ // å°†GNSSçš„æ—‹è½¬å‚æ•°ä¿å­˜è‡³tfç±»å‹çš„æ—‹è½¬å››å…ƒæ•° tf2::Quaternion gnss_q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z, input-&gt;pose.orientation.w); // å°†ä½ç½®å››å…ƒæ•°è½¬æ¢ä¸ºæ—‹è½¬çŸ©é˜µgnss_m tf2::Matrix3x3 gnss_m(gnss_q); // current_gnss_poseè¡¨ç¤ºå½“å‰GNSSçš„ä½ç½® pose current_gnss_pose; current_gnss_pose.x = input-&gt;pose.position.x; current_gnss_pose.y = input-&gt;pose.position.y; current_gnss_pose.z = input-&gt;pose.position.z; // åˆ©ç”¨gnss_m.getRPYå¾—åˆ°æ—‹è½¬çŸ©é˜µçš„RPYæ—‹è½¬è§’ï¼Œåˆ†åˆ«ä»¥ä¸‰ä¸ªå‚æ•°è¾“å‡º gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw); static pose previous_gnss_pose = current_gnss_pose; //è®°å½•å½“å‰æ¥å—åˆ°GNSSæ¶ˆæ¯çš„æ—¶é—´ ros::Time current_gnss_time = input-&gt;header.stamp; static ros::Time previous_gnss_time = current_gnss_time; //å¦‚æœä½¿ç”¨GNSSä¸”åˆå§‹ä½ç½®ä¸º0æˆ–fitness_score&gt;=500,åˆ™è¿›è¡ŒGNSSé‡å®šä½ï¼Œå¹¶è®¡ç®—å½“å‰ä½ç½®ä¸å…ˆå‰ä½ç½®çš„åå·® //æ³¨æ„ï¼šndtçš„fitness_scoreè¶Šä½è¶Šå¥½ï¼Œä¸€èˆ¬å°äº1 if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= _gnss_reinit_fitness) { previous_pose.x = previous_gnss_pose.x; previous_pose.y = previous_gnss_pose.y; //...(ä¸‹ç•¥) } previous_gnss_pose.x = current_gnss_pose.x; //...(ä¸‹ç•¥)} â‘£ map_callbackå‡½æ•°â€‹ map_callbackå‡½æ•°ä¸»è¦ç”¨äºè½½å…¥æ¿€å…‰é›·è¾¾æ•°æ®ä½œä¸ºåˆå§‹å…¨å±€åœ°å›¾mapï¼Œå¹¶å°†åˆå§‹å…¨å±€åœ°å›¾mapä½œä¸ºndté…å‡†ç®—æ³•çš„ç›®æ ‡ç‚¹äº‘ã€‚å‡½æ•°æŒ‰æ”¶åˆ°çš„ sensor_msgs::PointCloud2 ç±»å‹çš„ç‚¹äº‘æ•°æ®ä¸ºè¾“å…¥å‚æ•°ï¼Œé¦–å…ˆåˆ¤æ–­åœ°å›¾å°ºå¯¸ points_map_num ä¸è¾“å…¥ç‚¹äº‘çš„å®½åº¦æ˜¯å¦ç›¸ç­‰ã€‚åˆå§‹çŠ¶æ€æ—¶ points_map_num é»˜è®¤ä¸º 0ã€‚è½¦è¾†å¤„äºåˆå§‹çŠ¶æ€æ—¶ï¼Œæ¿€å…‰ç‚¹äº‘åœ°å›¾æœªåŠ è½½ï¼Œæ­¤æ—¶æ›´æ–° map åœ°å›¾å¤§å°ä¸ºè¾“å…¥æ¿€å…‰ç‚¹äº‘çš„å¤§å°ã€‚åˆ©ç”¨ pcl::fromROSMsg å‡½æ•°å°†è¾“å…¥ç‚¹äº‘è¿›è¡Œè½¬æ¢ï¼Œå¹¶ä¿å­˜è‡³mapã€‚æœ€åæ ¹æ®æ–¹æ³•ç±»å‹çš„ä¸åŒï¼Œå¯¹ NDT å‚æ•°è¿›è¡Œè®¾ç½®ï¼Œä¸»è¦è®¾ç½®ç½‘æ ¼å¤§å°ã€NDT ç®—æ³•çš„ç›®æ ‡ç‚¹äº‘ã€æœ€å¤§è¿­ä»£æ¬¡æ•°ã€æœ€å¤§è¿­ä»£æ­¥é•¿ä»¥åŠæ”¶æ•›é˜ˆå€¼Epsilonï¼Œæ·»åŠ æœ€å¤§è¿­ä»£æ¬¡æ•°èƒ½å¤Ÿå¢åŠ ç¨‹åºé²æ£’æ€§ï¼Œé¿å…ç¨‹åºåœ¨é”™è¯¯è¿­ä»£æ–¹å‘è¿è¡Œæ—¶é—´è¿‡é•¿ã€‚æœ€åä»£ç åˆ©ç”¨ 4 é˜¶å•ä½çŸ©é˜µä½œä¸ºåˆå§‹å˜æ¢çŸ©é˜µï¼Œæ¥å¯¹ç¬¬ä¸€å¸§ç‚¹äº‘è¿›è¡Œé…å‡†ï¼Œè¾“å‡ºç»“æœä¿å­˜è‡³output_cloudï¼Œè‡³æ­¤åœ°å›¾åŠ è½½æˆåŠŸã€‚ä¸‹é¢ä¸ºè¯¦ç»†ä»£ç æ³¨è§£ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input){ // è‹¥points_map_numä¸ç­‰äºè¾“å…¥ç‚¹äº‘å®½åº¦ï¼Œæ›´æ–°ç‚¹äº‘å‚æ•° if (points_map_num != input-&gt;width) { std::cout &lt;&lt; &quot;Update points_map.&quot; &lt;&lt; std::endl; points_map_num = input-&gt;width; // å°†è¾“å…¥æ¿€å…‰ç‚¹äº‘ç±»å‹ä»sensor_msgs::PointCloud2è½¬æ¢ä¸ºpclç±»å‹ pcl::fromROSMsg(*input, map); if (_use_local_transform == true) { // å¦‚æœå±€éƒ¨å˜æ¢å­˜åœ¨ï¼Œå‘å¤–å¹¿æ’­å±€éƒ¨å˜æ¢ // local_transformè¡¨ç¤ºworldåæ ‡ç³»ä¸mapåæ ‡ç³»ä¹‹é—´çš„å˜æ¢ tf2_ros::Buffer tf_buffer; tf2_ros::TransformListener tf_listener(tf_buffer); geometry_msgs::TransformStamped local_transform_msg; try { local_transform_msg = tf_buffer.lookupTransform(&quot;map&quot;, &quot;world&quot;, ros::Time::now(), ros::Duration(3.0)); } catch (tf2::TransformException&amp; ex) { ROS_ERROR(&quot;%s&quot;, ex.what()); } // å°†mapåæ ‡ç³»è½¬æ¢ä¸ºworldåæ ‡ç³» tf2::fromMsg(local_transform_msg, local_transform); pcl::transformPointCloud(map, map, tf2::transformToEigen(local_transform_msg).matrix().inverse().cast&lt;float&gt;()); } pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map)); // æ ¹æ®æ–¹æ³•ç±»å‹ä¸åŒè®¾ç½®è¦è¿›è¡Œndté…å‡†çš„ç‚¹äº‘ if (_method_type == MethodType::PCL_GENERIC) { pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt; pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); // è®¾ç½®ç½‘æ ¼å¤§å° new_ndt.setResolution(ndt_res); // å°†map_pträ½œä¸ºndtè¾“å…¥ç‚¹äº‘ new_ndt.setInputTarget(map_ptr); // è®¾ç½®æœ€å¤§è¿­ä»£æ¬¡æ•° new_ndt.setMaximumIterations(max_iter); // è®¾ç½®æ­¥é•¿å¤§å° new_ndt.setStepSize(step_size); new_ndt.setTransformationEpsilon(trans_eps); // åˆ©ç”¨å•ä½çŸ©é˜µä½œä¸ºåˆå§‹åæ ‡å˜æ¢çŸ©é˜µæ¥è¿›è¡Œndté…å‡† // æ­¤æ—¶ä¸ºç¬¬ä¸€å¸§ç‚¹äº‘é…å‡† new_ndt.align(*output_cloud, Eigen::Matrix4f::Identity()); pthread_mutex_lock(&amp;mutex); ndt = new_ndt; pthread_mutex_unlock(&amp;mutex); } //...ï¼ˆä¸‹ç•¥ï¼‰ // åœ°å›¾è½½å…¥æˆåŠŸ map_loaded = 1; }} â‘¤ points_callback å‡½æ•°â€‹ è¯¥å›è°ƒå‡½æ•°ä¸»è¦è¿›è¡Œå¤šä¼ æ„Ÿå™¨ä¹‹é—´çš„èåˆå®šä½ã€‚å‡½æ•°é¦–å…ˆèåˆ IMU å’Œodom æ•°æ®å¾—åˆ°è¾ƒä¸ºå‡†ç¡®çš„ä½ç½®ä¼°è®¡ï¼Œç„¶ååˆ©ç”¨ filtered_points å°†ç‚¹äº‘æ•°æ®åŠ å…¥åˆ° NDT çš„ç®—æ³•å†…ï¼Œè®¡ç®—å¾—åˆ°ä¸€ä¸ª NDT çš„é¢„æµ‹ä½å§¿ã€‚æœ€åï¼Œè¯¥ä½å§¿ä¸ IMU å’Œ odom èåˆå¾—åˆ°çš„ä½å§¿è¿›è¡Œæ¯”è¾ƒï¼Œå¾—å‡ºæ›´å‡†ç¡®çš„ä½å§¿ã€‚ â€‹ Points_callback å›è°ƒå‡½æ•°ä»¥æ¥æ”¶åˆ°çš„æ¿€å…‰ç‚¹äº‘æ•°æ®ä¸ºè¾“å…¥å‚æ•°ï¼Œå½“å…¨å±€ç‚¹äº‘åœ°å›¾è½½å…¥æˆåŠŸå¹¶ä¸”è½¦è¾†ä½å§¿åˆå§‹åŒ–æˆåŠŸä¹‹åï¼Œndt_matching å¼€å§‹é…å‡†ã€‚ä»£ç åˆ©ç”¨std:chrono::system_clock::now å‡½æ•°æ¥è·å–å½“å‰ç³»ç»Ÿçš„æ—¶é—´å¹¶å°†å…¶ä½œä¸ºå®šä½åŒ¹é…çš„èµ·å§‹æ—¶é—´ matching_startã€‚ç„¶åè·å–å½“å‰æ¥æ”¶åˆ°çš„æ¿€å…‰ç‚¹äº‘æ—¶é—´æˆ³ä½œä¸ºå½“å‰æ‰«ææ—¶é—´current_scan_timeã€‚åˆ©ç”¨ pcl::fromROSMsg å‡½æ•°å°†è¾“å…¥ç‚¹äº‘è½¬æ¢ä¸º pcl::PointCloud&lt; pcl:PointXYZ &gt;ç±»å‹çš„ç‚¹äº‘æ•°æ®å¹¶å­˜å‚¨äº filtered_scanã€‚æœ€åå°†filtered_scan ä½œä¸º NDT ç®—æ³•çš„è¾“å…¥æºç‚¹äº‘ï¼Œä¸ NDT ç®—æ³•ç›®æ ‡ç‚¹äº‘å…¨å±€åœ°å›¾ map è¿›è¡ŒåŒ¹é…ã€‚ 12345678910111213141516171819202122232425262728293031323334353637static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input){ health_checker_ptr_-&gt;CHECK_RATE(&quot;topic_rate_filtered_points_slow&quot;, 8, 5, 1, &quot;topic filtered_points subscribe rate slow.&quot;); // é»˜è®¤åœ°å›¾è½½å…¥çŠ¶æ€ä¸º0 if (map_loaded == 1 &amp;&amp; init_pos_set == 1) { // è·å–é…å‡†å¼€å§‹æ—¶é—´ matching_start = std::chrono::system_clock::now(); static tf2_ros::TransformBroadcaster br; tf2::Transform transform; tf2::Quaternion predict_q, ndt_q, current_q, localizer_q; pcl::PointXYZ p; // å£°æ˜pcl::PointCloud&lt;pcl::PointXYZ&gt;ç±»å‹çš„ç‚¹äº‘æ•°æ®ç”¨æ¥å‚¨å­˜è¿‡æ»¤åçš„ç‚¹äº‘ pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan; // è·å–å½“å‰æ¥æ”¶ç‚¹äº‘çš„æ‰«ææ—¶é—´ ros::Time current_scan_time = input-&gt;header.stamp; static ros::Time previous_scan_time = current_scan_time; // å°†å½“å‰sensor_msgs::PointCloud2è½¬åŒ–ä¸ºPCLç±»å‹ pcl::fromROSMsg(*input, filtered_scan); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan)); // è·å–ç‚¹äº‘æ•°é‡ int scan_points_num = filtered_scan_ptr-&gt;size(); // å•ä½çŸ©é˜µåˆå§‹åŒ–è½¦èº«åº•ç›˜base_linkå’Œlocalizerå…³äºåŸç‚¹çš„åæ ‡å˜æ¢çŸ©é˜µ Eigen::Matrix4f t(Eigen::Matrix4f::Identity()); // base_link Eigen::Matrix4f t2(Eigen::Matrix4f::Identity()); // localizer // å£°æ˜é…å‡†èµ·æ­¢æ—¶é—´ä¸getFitnessScoreèµ·æ­¢æ—¶é—´ std::chrono::time_point&lt;std::chrono::system_clock&gt; align_start, align_end, getFitnessScore_start, getFitnessScore_end; static double align_time, getFitnessScore_time = 0.0; pthread_mutex_lock(&amp;mutex); // æŒ‰ç…§ä¸åŒæ–¹æ³•ç±»å‹å°†filtered_scan_pträ½œä¸ºndtè¾“å…¥ç‚¹äº‘ if (_method_type == MethodType::PCL_GENERIC) ndt.setInputSource(filtered_scan_ptr); //...(ä¸‹ç•¥) â€‹ è¯¥ä»£ç ä¸»è¦è®¡ç®—å¾—å‡º NDT é…å‡†ç®—æ³•æ‰€éœ€è¦çš„åˆå§‹ä½å§¿ã€‚offset æœ‰ä¸‰ç§æƒ…å†µï¼Œå½“ offset ä¸ºçº¿æ€§å€¼çš„æ—¶å€™ï¼Œåˆ©ç”¨åŒ€é€Ÿè¿åŠ¨æ¨¡å‹è®¡ç®—å‡º offset çš„å¤§å°;å½“ offset ä¸ºäºŒæ¬¡æ¨¡å‹ï¼Œå³åŠ é€Ÿåº¦ä¸ä¸º0çš„æ—¶å€™ã€‚offset çš„xä¸yæ–¹å‘çš„åˆ†é‡åˆ©ç”¨vt+(1/2)at^2æ±‚å‡ºï¼Œyæ–¹å‘çš„åˆ†é‡ä¸åèˆªè§’ä¿æŒåŒ€é€Ÿè¿åŠ¨æ¨¡å‹ï¼›ç¬¬ä¸‰ç§æƒ…å†µæ˜¯ offset ä¸º 0ã€‚ä»£ç åˆ©ç”¨previous_pose (å‰ä¸€å¸§ä½å§¿)+offset(ä¸¤å¸§æ—¶é—´å†…çš„åå·®é‡)å¾—åˆ° predict_pose (å½“å‰é¢„æµ‹çš„è½¦è¾†ä½å§¿)ã€‚ç„¶åä»£ç æ ¹æ® imuã€odom çš„ä½¿ç”¨æƒ…å†µä¼°è®¡ NDT æ‰€éœ€å½“å‰åˆå§‹ä½å§¿ï¼Œè¿™ä¸€æ­¥ä¸ndt mapping ç±»ä¼¼ã€‚æœ€åå¦‚æœä½¿ç”¨ä¼ æ„Ÿå™¨æ¥è·å–ä½å§¿ï¼Œåˆ™å°†ç›¸åº”ä¼ æ„Ÿå™¨ä¼°è®¡å¾—åˆ°çš„å½“å‰ä½å§¿ä½œä¸º predict_pose_for_ndt (ndt é…å‡†æ‰€éœ€çš„åˆå€¼ï¼‰ï¼Œå¦åˆ™å°† predict_pose (å½“å‰é¢„æµ‹çš„è½¦è¾†ä½å§¿ï¼‰ä½œä¸º NDT é…å‡†æ‰€éœ€çš„åˆå€¼ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// è®¡ç®—å‰åä¸¤å¸§æ¿€å…‰æ‰«ææ—¶é—´å·® double diff_time = (current_scan_time - previous_scan_time).toSec(); // _offsetä¸ºçº¿æ€§æ—¶ï¼Œä½ç½®åå·®å’Œèˆªå‘è§’ç­‰äºé€Ÿåº¦ä¹˜å‰åå¸§æ—¶é—´å·® if (_offset == &quot;linear&quot;) { offset_x = current_velocity_x * diff_time; offset_y = current_velocity_y * diff_time; offset_z = current_velocity_z * diff_time; offset_yaw = angular_velocity * diff_time; } // _offsetä¸ºäºŒæ¬¡ç±»å‹ï¼Œåˆ™åˆ©ç”¨vt+at^2è¡¨ç¤ºxã€yï¼Œzã€yawä¸çº¿æ€§ä¸€è‡´ else if (_offset == &quot;quadratic&quot;) { offset_x = (current_velocity_x + current_accel_x * diff_time) * diff_time; offset_y = (current_velocity_y + current_accel_y * diff_time) * diff_time; offset_z = current_velocity_z * diff_time; offset_yaw = angular_velocity * diff_time; } else if (_offset == &quot;zero&quot;) { offset_x = 0.0; offset_y = 0.0; offset_z = 0.0; offset_yaw = 0.0; } // ä¼°è®¡ä½ç½®çš„åæ ‡xyz=å‰ä¸€å¸§+åç§»é‡ã€rpè§’åº¦ä¸å‰ä¸€å¸§è§’åº¦ç›¸ç­‰ï¼Œyawéšè½¦å˜åŒ– predict_pose.x = previous_pose.x + offset_x; predict_pose.y = previous_pose.y + offset_y; predict_pose.z = previous_pose.z + offset_z; predict_pose.roll = previous_pose.roll; predict_pose.pitch = previous_pose.pitch; predict_pose.yaw = previous_pose.yaw + offset_yaw; // æ ¹æ®imuå’Œodomä½¿ç”¨æƒ…å†µï¼Œé‡‡ç”¨ä¸åŒæ–¹æ³•å¯¹ndté…å‡†çš„åˆå§‹ä½ç½®è¿›è¡Œè®¡ç®—ï¼Œä¸mappingä¿æŒä¸€è‡´ if (_use_imu == true &amp;&amp; _use_odom == true) imu_odom_calc(current_scan_time); if (_use_imu == true &amp;&amp; _use_odom == false) imu_calc(current_scan_time); if (_use_imu == false &amp;&amp; _use_odom == true) odom_calc(current_scan_time); // æ ¹æ®ä½¿ç”¨æ–¹æ³•ä¸åŒï¼Œèµ‹äºˆndtä½ç½®é¢„æµ‹åˆå€¼ pose predict_pose_for_ndt; if (_use_imu == true &amp;&amp; _use_odom == true) predict_pose_for_ndt = predict_pose_imu_odom; else if (_use_imu == true &amp;&amp; _use_odom == false) predict_pose_for_ndt = predict_pose_imu; else if (_use_imu == false &amp;&amp; _use_odom == true) predict_pose_for_ndt = predict_pose_odom; else predict_pose_for_ndt = predict_pose; â€‹ è¯¥éƒ¨åˆ†ä»£ç ä¸»è¦æ±‚å‡ºæ¿€å…‰é›·è¾¾åæ ‡ç³»ç›¸å¯¹äºå…¨å±€åœ°å›¾åæ ‡ç³»çš„åˆå§‹å˜æ¢çŸ©é˜µinit_guess, è¯¥çŸ©é˜µçš„è®¡ç®—éœ€è¦è¡¥å¿ä¸€ä¸ªå˜æ¢çŸ©é˜µtf_btol,å³è½¦èº«åº•ç›˜åæ ‡ç³» base_linkåˆ°æ¿€å…‰é›·è¾¾åæ ‡ç³»çš„å˜æ¢çŸ©é˜µï¼Œè¿™ä¸€å˜æ¢çŸ©é˜µç”± main å‡½æ•°å¾—å‡ºã€‚ä»£ç è·å–å½“å‰ç³»ç»Ÿæ—¶é—´æˆ³ä½œä¸º NDT é…å‡†èµ·å§‹æ—¶é—´ï¼Œç„¶ååˆ©ç”¨ ndt.align(output_cloud, init_guess) å‡½æ•°ä»¥åˆå§‹å˜æ¢çŸ©é˜µ init_guess ä¸ºå‚æ•°ï¼Œå¾—åˆ°è¾“å‡ºç‚¹äº‘ output_cloudï¼Œç„¶åè®¡ç®— NDT é…å‡†çš„ç»“æœï¼Œæœ€åè®¡ç®—é…å‡†æ—¶é—´ã€‚t tf_btol.inverseå‡½æ•°å¾—åˆ°è½¦èº«åº•ç›˜ç›¸å¯¹äºå…¨å±€åœ°å›¾åæ ‡ç³»çš„æœ€ç»ˆå˜æ¢çŸ©é˜µt2ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041// å°†predict_pose_for_ndtä½ç½®çš„xyzåæ ‡ä½œä¸ºinit_translationåˆå§‹å¹³ç§»çš„æ„é€ å‡½æ•°å‚æ•°Eigen::Translation3f init_translation(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z);Eigen::AngleAxisf init_rotation_x(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX());Eigen::AngleAxisf init_rotation_y(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());// init_guessè¡¨ç¤ºæ¿€å…‰é›·è¾¾åæ ‡ç³»ç›¸å¯¹äºå…¨å±€åœ°å›¾åæ ‡ç³»çš„åæ ‡å˜æ¢çŸ©é˜µEigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);// æ ¹æ®ä¸åŒæ–¹æ³•è¿›è¡Œndté…å‡†if (_method_type == MethodType::PCL_GENERIC){ // è·å–å½“å‰æ—¶é—´æˆ³ä½œä¸ºé…å‡†å¼€å§‹æ—¶é—´ align_start = std::chrono::system_clock::now(); // åˆ©ç”¨åˆå§‹å˜æ¢çŸ©é˜µinit_guessè¿›è¡Œndté…å‡†ï¼Œå°†ç»“æœå­˜åˆ°output_cloud ndt.align(*output_cloud, init_guess); // è·å–é…å‡†ç»“æŸæ—¶é—´ align_end = std::chrono::system_clock::now(); // æ˜¯å¦æ”¶æ•› has_converged = ndt.hasConverged(); // è·å–ndté…å‡†æœ€ç»ˆå˜æ¢çŸ©é˜µ t = ndt.getFinalTransformation(); // å¾—åˆ°è¿­ä»£æ¬¡æ•° iteration = ndt.getFinalNumIteration(); getFitnessScore_start = std::chrono::system_clock::now(); fitness_score = ndt.getFitnessScore(); getFitnessScore_end = std::chrono::system_clock::now(); trans_probability = ndt.getTransformationProbability();}//...(ä¸‹ç•¥)// è®¡ç®—é…å‡†æ—¶é—´align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;// è®¡ç®—æ­¤æ—¶è½¦èº«åº•ç›˜ç›¸å¯¹äºå…¨å±€åœ°å›¾åæ ‡ç³»çš„æœ€ç»ˆå˜æ¢çŸ©é˜µt2 = t * tf_btol.inverse();getFitnessScore_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() / 1000.0;pthread_mutex_unlock(&amp;mutex); â€‹ è¯¥ä»£ç ä¸»è¦è®¡ç®—å½“å‰æ¿€å…‰é›·è¾¾ä¸è½¦èº«åº•ç›˜ç›¸å¯¹äºå…¨å±€åœ°å›¾åæ ‡ç³»çš„ä½å§¿ã€‚æ¿€å…‰é›·è¾¾ localizer ç›¸å¯¹äºå…¨å±€åœ°å›¾ map çš„æ—‹è½¬çŸ©é˜µmat_lå’Œä½ç½®åæ ‡ localizer_pose.x, localizer_pose.y, localizer_pose.z ç”± NDT é…å‡†å¾—åˆ°çš„å˜æ¢çŸ©é˜µ _t_ æ±‚å¾—ã€‚ä»£ç åˆ©ç”¨mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1ï¼‰ å‡½æ•°æ±‚å‡ºæ¿€å…‰é›·è¾¾çš„æ—‹è½¬æ¬§æ‹‰è§’rpyã€‚åŒç†ï¼Œåˆ©ç”¨ _t2_ (è½¦èº«åº•ç›˜ç›¸å¯¹äº map çš„å˜æ¢çŸ©é˜µï¼‰æ±‚å‡ºndt_pose(ndt ç®—æ³•å¾—åˆ°çš„è½¦ä½“ç›¸å¯¹äº map çš„ä½å§¿)ã€‚ç„¶åä»£ç å°† NDT é…å‡†ç®—æ³•å¾—åˆ°çš„è½¦è¾†å®šä½ ndt_pose ä¸ ndt ç®—æ³•æä¾›çš„åˆå€¼ predict_pose_for_ndt è¿›è¡Œæ¯”è¾ƒï¼Œæ±‚å‡ºä¸¤è€…ä¹‹é—´çš„è¯¯å·® predict_pose_errorã€‚å½“è¯¯å·®å°äºé˜ˆå€¼ PREDICT_POSE_THRESHOLDæ—¶ï¼Œä½¿ç”¨ndt_pose ä½œä¸ºå½“å‰ä½å§¿ä¼°è®¡ current_poseï¼Œå¦åˆ™ä½¿ç”¨ predict_pose_for_ndtä½œä¸º current_poseã€‚ 123456789101112131415161718192021222324252627282930// localizerçš„æ—‹è½¬çŸ©é˜µtf2::Matrix3x3 mat_l;// å°†ndtæœ€ç»ˆå˜æ¢çš„çŸ©é˜µèµ‹äºˆmat_lmat_l.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)), static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)), static_cast&lt;double&gt;(t(2, 0)), static_cast&lt;double&gt;(t(2, 1)), static_cast&lt;double&gt;(t(2, 2)));// æ›´æ–°localizer_poseçš„ä½ç½®å‘é‡localizer_pose.x = t(0, 3);localizer_pose.y = t(1, 3);localizer_pose.z = t(2, 3);// æœ€ç»ˆå˜æ¢çš„æ—‹è½¬rpyè§’åº¦å€¼èµ‹äºˆlocalizer_poseçš„rpyè§’åº¦å€¼mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);// ç›¸å¯¹äºbase_linkçš„æ—‹è½¬çŸ©é˜µmat_bç”±t2å˜æ¢çŸ©é˜µèµ‹å€¼tf2::Matrix3x3 mat_b; // base_linkmat_b.setValue(static_cast&lt;double&gt;(t2(0, 0)), static_cast&lt;double&gt;(t2(0, 1)), static_cast&lt;double&gt;(t2(0, 2)), static_cast&lt;double&gt;(t2(1, 0)), static_cast&lt;double&gt;(t2(1, 1)), static_cast&lt;double&gt;(t2(1, 2)), static_cast&lt;double&gt;(t2(2, 0)), static_cast&lt;double&gt;(t2(2, 1)), static_cast&lt;double&gt;(t2(2, 2)));// ndt_poseçš„åæ ‡ç”±è½¦èº«åº•ç›˜ç›¸å¯¹äºmapçš„å¹³ç§»å‘é‡æ¥èµ‹å€¼ï¼Œè®¡ç®—è½¦è¾†åœ¨å…¨å±€åœ°å›¾åæ ‡ç³»ä¸‹çš„ä½ç½®ndt_pose.x = t2(0, 3);ndt_pose.y = t2(1, 3);ndt_pose.z = t2(2, 3);mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);// è®¡ç®—ndt_poseå’Œpredict_poseé—´çš„è¯¯å·®predict_pose_error = sqrt((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) + (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) + (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));//...(ä¸‹ç•¥) â€‹ è¯¥éƒ¨åˆ†ä»£ç ä¸»è¦å‘å¸ƒ base link åæ ‡ç³»åˆ°å…¨å±€åœ°å›¾åæ ‡ç³» map ä¹‹é—´çš„å˜æ¢å…³ç³»ï¼Œä¸»è¦é€šè¿‡ sendTransform å‡½æ•°è¿›è¡Œå˜æ¢æ¶ˆæ¯çš„å¹¿æ’­ï¼Œå…¶ä¸­ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸º base linkåˆ° map çš„åæ ‡å˜æ¢ transformï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºå‘å¸ƒæ—¶é—´ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ä¸ºçˆ¶åæ ‡ç³» map,æœ€åä¸€ä¸ªå‚æ•°ä¸ºå­åæ ‡ç³» base_linkã€‚ç„¶åè®¡ç®—å¹¶å‘é€ndt_matching åŒ¹é…å®šä½çš„è€—æ—¶time_ndt_matching.dataï¼Œæœ€åå‘å¸ƒ NDT çš„çŠ¶æ€å‚æ•°ä¿¡æ¯ï¼Œcurrent_scan_time, time_ndt_matching.data, iteration, fitness_score, current_velocity, current _accel. 123456789101112131415161718192021222324252627282930313233343536373839//...(ä¸Šç•¥)// æ³¨ï¼šcurrent_pose ç»ç”± vel_pose_mux å‘å¸ƒ// å‘å¸ƒè½¦è¾†é¢„æµ‹ä½å§¿predict_pose_pub.publish(predict_pose_msg);health_checker_ptr_-&gt;CHECK_RATE(&quot;topic_rate_ndt_pose_slow&quot;, 8, 5, 1, &quot;topic ndt_pose publish rate slow.&quot;);// å‘å¸ƒndtä½å§¿ndt_pose_pub.publish(ndt_pose_msg);// å‘å¸ƒæ¿€å…‰é›·è¾¾å½“å‰é¢„æµ‹ä½å§¿localizer_pose_pub.publish(localizer_pose_msg);// å‘å¸ƒ TF &quot;base_link&quot; -&gt; &quot;map&quot;transform.setOrigin(tf2::Vector3(current_pose.x, current_pose.y, current_pose.z));transform.setRotation(current_q);if (_use_local_transform == true){ transform = local_transform * transform;}tf2::Stamped&lt;tf2::Transform&gt; tf(transform, current_scan_time, &quot;map&quot;);geometry_msgs::TransformStamped tf_msg = tf2::toMsg(tf);tf_msg.child_frame_id = _output_tf_frame_id;br.sendTransform(tf_msg);// è®°å½•åŒ¹é…ç»“æŸæ—¶é—´matching_end = std::chrono::system_clock::now();// è®°å½•åŒ¹é…è€—æ—¶ï¼Œå­˜å…¥time_ndt_matching.dataå¹¶å‘å¸ƒexe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;time_ndt_matching.data = exe_time;health_checker_ptr_-&gt;CHECK_MAX_VALUE(&quot;time_ndt_matching&quot;, time_ndt_matching.data, 50, 70, 100, &quot;value time_ndt_matching is too high.&quot;);// å‘å¸ƒé…å‡†æ—¶é—´ä¿¡æ¯time_ndt_matching_pub.publish(time_ndt_matching);// è®¾ç½®é¢„è®¡é€Ÿåº¦ä¿¡æ¯/estimate_twistå¹¶å‘å¸ƒestimate_twist_msg.header.stamp = current_scan_time;//...(ä¸‹ç•¥)estimated_vel_pub.publish(estimate_vel_msg);// è®¾ç½®ndtçŠ¶æ€ä¿¡æ¯/ndt_statå¹¶å‘å¸ƒndt_stat_msg.header.stamp = current_scan_time;//...(ä¸‹ç•¥)ndt_reliability_pub.publish(ndt_reliability); â€‹ æœ€åä¸€éƒ¨åˆ†ä»£ç æ›´æ–°å½“å‰ä½å§¿ current_pose ä¸ºä¸Šä¸€å¸§çš„ä½å§¿ previous_poseï¼Œé€Ÿåº¦åšåŒæ ·å¤„ç†ï¼Œä¸ºä¸‹æ¬¡çš„ndt_matching åŒ¹é…å®šä½åšé“ºå«ã€‚ndt_matching èŠ‚ç‚¹çš„odom_callback ä¸ imu_callback è¿™ä¸¤ä¸ªå›è°ƒå‡½æ•°ä¸ ndt_mappingèŠ‚ç‚¹é‡Œçš„åŒåå›è°ƒå‡½æ•°å†…å®¹æ˜¯ç›¸åŒçš„ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚ 12345678910111213141516171819 // ç›¸é‚»ä¸¤å¸§çš„ä½å§¿åå·®å½’é›¶ offset_imu_x = 0.0; //...(ä¸‹ç•¥) offset_odom_x = 0.0; //...(ä¸‹ç•¥) offset_imu_odom_x = 0.0; //...(ä¸‹ç•¥) // æ›´æ–°å½“å‰ä½å§¿ä¸ºä¸Šä¸€å¸§ä½å§¿ previous_pose.x = current_pose.x; //...(ä¸‹ç•¥) // æ›´æ–°å½“å‰æ‰«ææ—¶é—´ä¸ºä¸Šä¸€å¸§æ‰«ææ—¶é—´ previous_scan_time = current_scan_time; // æ›´æ–°é€Ÿåº¦ previous_previous_velocity = previous_velocity; //...(ä¸‹ç•¥) }} â‘¥ thread_funcå‡½æ•°â€‹ thread_funcå‡½æ•°ä¸»è¦æ˜¯é¢å¤–å¼€å¯ä¸€ä¸ªçº¿ç¨‹æ£€æµ‹å¹¶æ›´æ–°åœ°å›¾ã€‚ 12345678910111213141516void* thread_func(void* args){ // å¼€å¯ä¸€ä¸ªçº¿ç¨‹æ£€æµ‹å¹¶æ›´æ–°åœ°å›¾ ros::NodeHandle nh_map; ros::CallbackQueue map_callback_queue; nh_map.setCallbackQueue(&amp;map_callback_queue); ros::Subscriber map_sub = nh_map.subscribe(&quot;points_map&quot;, 10, map_callback); ros::Rate ros_rate(10); while (nh_map.ok()) { map_callback_queue.callAvailable(ros::WallDuration()); ros_rate.sleep(); } return nullptr;} 3.3 å‚è€ƒæ–‡çŒ® [1] Biber P, StraÃŸer W. The normal distributions transform: A new approach to laser scan matching[C] IROS 2003 . IEEE, 2003, 3: 2743-2748. [2] Merten H. The three-dimensional normal-distributions transform[J]. threshold, 2008, 10: 3. [3] åŒæ„š. PCL(Point Cloud Library)å­¦ä¹ æŒ‡å—&amp;èµ„æ–™æ¨èï¼ˆ2023ç‰ˆï¼‰[OB/OL]. [2023-02-05].https://zhuanlan.zhihu.com/p/268524083. [4] Badue C, Guidolini R, Carneiro R V, et al. Self-driving cars: A survey [J]. arXiv: Robotics, 2019. [5] é«˜ç¿”,å¼ æ¶›ç­‰. è§†è§‰ SLAM åå››è®²ï¼šä»ç†è®ºåˆ°å®è·µ[M]ï¼ŒåŒ—äº¬ï¼šç”µå­å·¥ä¸šå‡ºç‰ˆç¤¾ï¼Œ2017. [6] Adam Shan. æ— äººé©¾é©¶æ±½è½¦ç³»ç»Ÿå…¥é—¨(åä¸‰ï¼‰ä¸€æ­£æ€åˆ†å¸ƒå˜æ¢ (NDT) é…å‡†ä¸æ— äººè½¦å®šä½[DB/OL]. [2020-04-11]. https://blog.csdn.net/AdamShan/article/details/79230612. [7] Martin M. The Three-dimensional normal-distributions transform - An efficient representation for registration, surface analysis, and loop detection[D]. Orebro: Orebro University, 2009. [8] ç”°å¤§æ–°,æ®µç»­åº­ç­‰. Autowareä¸è‡ªåŠ¨é©¾é©¶æŠ€æœ¯ï¼ŒåŒ—äº¬ï¼šç§‘å­¦å‡ºç‰ˆç¤¾ï¼Œ2020. å››ã€Autoware å†³ç­–è§„åˆ’æ¨¡å—è§£æâ€‹ Autowareçš„å†³ç­–è§„åˆ’æ¨¡å—ä¸»è¦æ—¶åŸºäºæ„ŸçŸ¥çš„è¾“å‡ºç»“æœï¼Œè¿›è¡Œå…¨å±€è·¯å¾„è§„åˆ’å’Œå±€éƒ¨è·¯å¾„è§„åˆ’ã€‚å…¨å±€è·¯å¾„è§„åˆ’åœ¨è½¦è¾†å¯åŠ¨æˆ–é‡å¯çš„æ—¶å€™è¢«ç¡®å®šï¼Œå±€éƒ¨è·¯å¾„æ ¹æ®è½¦è¾†çš„çŠ¶æ€å®æ—¶æ›´æ–°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè½¦è¾†åœ¨éšœç¢ç‰©å‰æˆ–åœ¨åœæ­¢çº¿å‰ï¼Œè½¦è¾†çŠ¶æ€å˜ä¸ºâ€œstopâ€ï¼Œé‚£ä¹ˆè½¦è¾†çš„é€Ÿåº¦å°±è¢«è§„åˆ’ä¸º0ã€‚å¦‚æœè½¦è¾†é‡åˆ°ä¸€ä¸ªéšœç¢ç‰©ä¸”çŠ¶æ€ä¸ºâ€œavoidâ€ï¼Œé‚£ä¹ˆå±€éƒ¨è·Ÿè¸ªè·¯å¾„å°±ä¼šè¢«é‡æ–°è§„åˆ’ç»•è¿‡éšœç¢ç‰©ï¼ŒåŸºç¡€èŠ‚ç‚¹åŠä»–ä»¬ä¹‹é—´çš„å…³ç³»ï¼ˆè¯é¢˜ä¹‹é—´çš„è®¢é˜…/å‘å¸ƒï¼‰å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ â€‹ æœ¬èŠ‚å¯¹Autowareå†³ç­–è§„åˆ’æ¨¡å—å†…çš„åŸºç¡€ROSèŠ‚ç‚¹ï¼ˆwaypoint_loader, waypoint_replanner, lane_rule, lane_select, astar_avoid,velocity_set, pure_pursuitç­‰èŠ‚ç‚¹ï¼‰åšç®€ç•¥åˆ†æã€‚ 4.1 èŠ‚ç‚¹waypoint_loaderâ€‹ èŠ‚ç‚¹waypoint_loaderçš„ä¸»è¦ä½œç”¨ï¼šä»æœ¬åœ°æ–‡ä»¶åŠ è½½é‡‡é›†çš„è½¨è¿¹ç‚¹ã€‚ 4.1.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch waypoint_maker waypoint_loader.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹computing é€‰é¡¹å¡ -&gt; Motion Planning -&gt;waypoint_maker-&gt;waypoint_loaderï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 4.1.2 ç¨‹åºè·¯å¾„12//æºä»£ç è·¯å¾„src/autoware/core_planning/waypoint_maker/nodes/waypoint_loader 4.1.3 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ multi_lane_csv string è·¯æ ‡ç‚¹æ–‡ä»¶ 4.1.4 ä¸»è¦ç»“æ„ä½“â€‹ autoware_msg::Laneç»“æ„ä½“ 12345678910111213autoware_msgs::Lane{ Header header int32 increment int32 lane_id Waypoint[] waypoints uint32 lane_index float32 cost float32 closest_object_distance float32 closest_object_velocity bool is_blocked} 123456789std_msgs::Header{ //åºåˆ—å· uint32 seq //æ—¶é—´æˆ³ time stamp //è¡¨ç¤ºæ•°æ®æ¥æºäºå“ªä¸€ä¸ªframe string frame_id} 123456789101112131415161718192021222324252627282930313233autoware_msgs::Waypoint{ //å…¨å±€id int32 gid //å±€éƒ¨id int32 lid //ä½å§¿ä¿¡æ¯ geometry_msgs/PoseStamped pose //é€Ÿåº¦ï¼Œè§’é€Ÿåº¦ç­‰ä¿¡æ¯ geometry_msgs/TwistStamped twist //é“è·¯ä¿¡æ¯ DTLane dtlane int32 change_flag //è·¯ç‚¹ä¿¡æ¯ WaypointState wpstate uint32 lane_id uint32 left_lane_id uint32 right_lane_id uint32 stop_line_id float32 cost float32 time_cost # Lane Direction # FORWARD = 0 # FORWARD_LEFT = 1 # FORWARD_RIGHT = 2 # BACKWARD = 3 # BACKWARD_LEFT = 4 # BACKWARD_RIGHT = 5 # STANDSTILL = 6 uint32 direction} 1234567891011121314151617181920212223geometry_msgs/PoseStamped{ Header header Pose pose}geometry_msgs/Pose{ Point position Quaternion orientation}geometry_msgs/Point{ float64 x float64 y float64 z}geometry_msgs/Quaternion{ float64 x float64 y float64 z float64 w} 12345678910111213141516geometry_msgs/TwistStamped{ Header header Twist twist}geometry_msgs/Twist{ Vector3 linear Vector3 angular}geometry_msgs/Vector3{ float64 x float64 y float64 z} 4.1.5 ä»£ç æ³¨è§£â‘  mainå‡½æ•°â€‹ mainå‡½æ•°åœ¨waypoint_loader_node.cppä¸­ï¼ŒèŠ‚ç‚¹çš„åŠŸèƒ½ä¸»è¦é€šè¿‡WaypointLoaderNodeå¯¹è±¡çš„runå‡½æ•°å®ç°ã€‚ 1234567int main(int argc, char** argv){ ros::init(argc, argv, &quot;waypoint_loader&quot;); waypoint_maker::WaypointLoaderNode wln; wln.run(); return 0;} â‘¡ runå‡½æ•°â€‹ è¯»å–å­˜å‚¨çš„è½¨è¿¹ç‚¹æ–‡ä»¶æ•°æ®ï¼Œå¹¶å‘å¸ƒè‡³è¯é¢˜â€œ/based/lane_waypoints_rawâ€ 12345678910void WaypointLoaderNode::run(){ multi_file_path_.clear(); parseColumns(multi_lane_csv_, &amp;multi_file_path_); autoware_msgs::LaneArray lane_array; createLaneArray(multi_file_path_, &amp;lane_array); lane_pub_.publish(lane_array); output_lane_array_ = lane_array; ros::spin();} â‘¢ parseColumnså‡½æ•°â€‹ parseColumnså‡½æ•°ä»¥â€ï¼Œâ€œ ä½œä¸ºåˆ†éš”ç¬¦å·å°†å­—ç¬¦ä¸²lineåˆ†æˆè‹¥å¹²æ®µï¼Œå¹¶å°†å…¶ä¸­çš„ç©ºæ ¼å…¨éƒ¨å»é™¤ï¼Œä¾æ¬¡å‚¨å­˜è‡³å­—ç¬¦ä¸²å‘é‡columnsä¸­ 123456789101112131415161718192021222324void parseColumns(const std::string&amp; line, std::vector&lt;std::string&gt;* columns){ std::istringstream ss(line); std::string column; //ä»¥â€ï¼Œâ€œä¸ºåˆ†éš”ç¬¦æˆªå–å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸€æ®µ while (std::getline(ss, column, ',')) { //å°†æ¯æ®µå­—ç¬¦ä¸²ä¸­çš„ç©ºæ ¼åˆ é™¤ while (1) { //è¿”å›åŒºé—´[begin()ï¼Œend()ï¼‰ä¸­ç¬¬ä¸€ä¸ªå€¼ç­‰äº&quot; &quot;çš„å…ƒç´ ä½ç½®ï¼›è‹¥æœªæ‰¾åˆ°ï¼Œè¿”å›endã€‚è¿”å›çš„æ˜¯è¿­ä»£å™¨æˆ–æŒ‡é’ˆï¼Œå³ä½ç½®ä¿¡æ¯ auto res = std::find(column.begin(), column.end(), ' '); if (res == column.end()) { break; } column.erase(res); } if (!column.empty()) { columns-&gt;emplace_back(column); } }} â‘£ createLaneArrayå‡½æ•°â€‹ å°†pathsä¸­å„ä¸ªæœ¬åœ°è·¯å¾„å¯¹åº”æ–‡ä»¶ä¸­åŒ…å«çš„ä¿¡æ¯åˆ†åˆ«å¡«å…¥lane ä¸­ï¼Œå†å°†laneä¾æ¬¡å¡«å…¥lane_array 123456789101112131415161718192021222324252627282930void WaypointLoaderNode::createLaneWaypoint(const std::string&amp; file_path, autoware_msgs::Lane* lane){ //æ£€æŸ¥æ–‡ä»¶file_pathä¸­æ•°æ®æ˜¯å¦åˆè§„ if (!verifyFileConsistency(file_path.c_str())) { ROS_ERROR(&quot;lane data is something wrong...&quot;); return; } ROS_INFO(&quot;lane data is valid. publishing...&quot;); //åˆ¤æ–­æ–‡ä»¶æ•°æ®å­˜å‚¨æ ¼å¼ FileFormat format = checkFileFormat(file_path.c_str()); std::vector&lt;autoware_msgs::Waypoint&gt; wps; if (format == FileFormat::ver1) { loadWaypointsForVer1(file_path.c_str(), &amp;wps); } else if (format == FileFormat::ver2) { loadWaypointsForVer2(file_path.c_str(), &amp;wps); } else { //è¯»å–æ–‡ä»¶å†…å®¹å­˜å…¥waypointsä¸­ loadWaypointsForVer3(file_path.c_str(), &amp;wps); } lane-&gt;header.frame_id = &quot;/map&quot;; lane-&gt;header.stamp = ros::Time(0); lane-&gt;waypoints = wps;} â‘¤ verifyFileConsistencyå‡½æ•°â€‹ verifyFileConsistencyå‡½æ•°çš„ä½œç”¨æ—¶â€œéªŒè¯æ–‡ä»¶ä¸€è‡´æ€§â€ã€‚é¦–å…ˆifstreamä»¥è¾“å…¥çš„æ–¹å¼æ‰“å¼€filenameï¼Œå¦‚æœæ‰“å¼€å¤±è´¥åˆ™ç›´æ¥è¿”å›å¤±è´¥ï¼›å¦‚æœæˆåŠŸåˆ™æ‰§è¡ŒcheckFileFormatå‡½æ•°ï¼Œæ–‡ä»¶æ ¼å¼ä»¥ä¸‹å›¾ä¸ºä¾‹ 1234567891011121314151617181920212223242526272829303132333435363738bool WaypointLoaderNode::verifyFileConsistency(const char* filename){ ROS_INFO(&quot;verify...&quot;); std::ifstream ifs(filename); if (!ifs) { return false; } // æ£€æŸ¥è¯¥æ–‡ä»¶å†…æ•°æ®çš„å­˜å‚¨æ ¼å¼ FileFormat format = checkFileFormat(filename); ROS_INFO(&quot;format: %d&quot;, static_cast&lt;int&gt;(format)); if (format == FileFormat::unknown) { ROS_ERROR(&quot;unknown file format&quot;); return false; } std::string line; //åˆ æ‰ç¬¬ä¸€è¡Œ std::getline(ifs, line); size_t ncol = format == FileFormat::ver1 ? 4 // x,y,z,velocity : format == FileFormat::ver2 ? 5 // x,y,z,yaw,velocity : countColumns(line); //ä»ç¬¬äºŒè¡Œå¼€å§‹ï¼Œæ£€éªŒæ¯ä¸€è¡Œåˆ—æ•°æ˜¯å¦è·Ÿç¬¬ä¸€è¡Œåˆ—æ•°ä¸€è‡´ while (std::getline(ifs, line)) { if (countColumns(line) != ncol) { return false; } } return true;} â‘¥ checkFileFormatå‡½æ•°â€‹ ä¸»è¦ä½œç”¨ä¸ºåˆ¤æ–­æ–‡ä»¶æ ¼å¼ 12345678910111213141516171819202122232425262728293031323334FileFormat WaypointLoaderNode::checkFileFormat(const char* filename){ std::ifstream ifs(filename); if (!ifs) { return FileFormat::unknown; } // è¯»å–ç¬¬ä¸€è¡Œ std::string line; std::getline(ifs, line); // åˆ†æç¬¬ä¸€è¡Œ std::vector&lt;std::string&gt; parsed_columns; parseColumns(line, &amp;parsed_columns); // æ£€æŸ¥ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦ç”±æ•°å­—ç»„æˆ // Note: æµ®ç‚¹å‹æ•°å­—å› ä¸ºåŒ…å«å°æ•°ç‚¹ï¼Œæ‰€ä»¥ä¼šè¿”å›False if (!std::any_of(parsed_columns.at(0).cbegin(), parsed_columns.at(0).cend(), isdigit)) { return FileFormat::ver3; } // å¦‚æœå…ƒç´ åªç”±æ•°å­—ç»„æˆï¼Œåˆ™ä»¥â€œï¼Œâ€ä½œä¸ºåˆ†éš”ç¬¦ï¼Œè®¡ç®—æ­¤è¡Œæœ‰å‡ ä¸ªå…ƒç´ ç»„æˆ int num_of_columns = countColumns(line); ROS_INFO(&quot;columns size: %d&quot;, num_of_columns); return (num_of_columns == 3 ? FileFormat::ver1 // &quot;x y z (velocity)&quot; : num_of_columns == 4 ? FileFormat::ver2 // &quot;x y z yaw (velocity) : FileFormat::unknown);} â‘¦loadWaypointsForVer3å‡½æ•°â€‹ åŠ è½½æ–‡ä»¶å†…å®¹å¹¶è§£æ 1234567891011121314151617181920212223void WaypointLoaderNode::loadWaypointsForVer3(const char* filename, std::vector&lt;autoware_msgs::Waypoint&gt;* wps){ std::ifstream ifs(filename); if (!ifs) { return; } std::string line; std::getline(ifs, line); // è¯»å–ç¬¬ä¸€è¡Œ std::vector&lt;std::string&gt; contents; parseColumns(line, &amp;contents); // ä»ç¬¬äºŒè¡Œå¼€å§‹è§£æ while (std::getline(ifs, line)) { autoware_msgs::Waypoint wp; // è§£æè¯¥è¡Œï¼Œæ„é€ waypointç»“æ„ä½“ parseWaypointForVer3(line, contents, &amp;wp); wps-&gt;emplace_back(wp); }} â‘§parseWaypointForVer3å‡½æ•°â€‹ è§£æè¾“å…¥å­—ç¬¦ä¸²ï¼Œæ„é€ waypointç»“æ„ä½“ 12345678910111213141516171819202122void WaypointLoaderNode::parseWaypointForVer3(const std::string&amp; line, const std::vector&lt;std::string&gt;&amp; contents, autoware_msgs::Waypoint* wp){ std::vector&lt;std::string&gt; columns; parseColumns(line, &amp;columns); std::unordered_map&lt;std::string, std::string&gt; map; for (size_t i = 0; i &lt; contents.size(); i++) { map[contents.at(i)] = columns.at(i); } wp-&gt;pose.pose.position.x = std::stod(map[&quot;x&quot;]); wp-&gt;pose.pose.position.y = std::stod(map[&quot;y&quot;]); wp-&gt;pose.pose.position.z = std::stod(map[&quot;z&quot;]); wp-&gt;pose.pose.orientation = tf::createQuaternionMsgFromYaw(std::stod(map[&quot;yaw&quot;])); wp-&gt;twist.twist.linear.x = kmph2mps(std::stod(map[&quot;velocity&quot;])); wp-&gt;change_flag = std::stoi(map[&quot;change_flag&quot;]); wp-&gt;wpstate.steering_state = (map.find(&quot;steering_flag&quot;) != map.end()) ? std::stoi(map[&quot;steering_flag&quot;]) : 0; wp-&gt;wpstate.accel_state = (map.find(&quot;accel_flag&quot;) != map.end()) ? std::stoi(map[&quot;accel_flag&quot;]) : 0; wp-&gt;wpstate.stop_state = (map.find(&quot;stop_flag&quot;) != map.end()) ? std::stoi(map[&quot;stop_flag&quot;]) : 0; wp-&gt;wpstate.event_state = (map.find(&quot;event_flag&quot;) != map.end()) ? std::stoi(map[&quot;event_flag&quot;]) : 0;} 4.2 èŠ‚ç‚¹waypoint_replannerâ€‹ èŠ‚ç‚¹waypoint_replannerçš„ä¸»è¦ä½œç”¨ï¼šåœ¨åŠ è½½çš„è½¨è¿¹ç‚¹åŸºç¡€ä¸Šé‡æ–°å¯¹ä»–ä»¬çš„é€Ÿåº¦è¿›è¡Œè®¾ç½®ã€‚ 4.2.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch waypoint_maker waypoint_loader.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹computing é€‰é¡¹å¡ -&gt; Motion Planning -&gt;waypoint_maker-&gt;waypoint_loaderï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 4.2.2 ç¨‹åºè·¯å¾„1src/autoware/core_planning/waypoint_maker/nodes/waypoint_replanner 4.2.3 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ replanning_mode bool é‡è§„åˆ’æ¨¡å¼ velocity_max double æœ€å¤§é€Ÿåº¦ï¼ˆkm/h) velocity_min double æœ€å°é€Ÿåº¦ï¼ˆkm/h) accel_limit double åŠ é€Ÿé™åˆ¶ decel_limit double å‡é€Ÿé™åˆ¶ resample_mode bool é‡é‡‡æ ·æ¨¡å¼ resample_interval bool é‡é‡‡æ ·é—´éš” replan_curve_mode bool é‡è§„åˆ’æ›²çº¿æ¨¡å¼ replan_endpoint_mode bool é‡è§„åˆ’ç»“æŸç‚¹æ¨¡å¼ 4.2.4 ä»£ç æ³¨è§£â‘  mainå‡½æ•°â€‹ mainå‡½æ•°åœ¨waypoint_replanner_node.cppä¸­ã€‚ 12345678int main(int argc, char** argv){ ros::init(argc, argv, &quot;waypoint_replanner&quot;); waypoint_maker::WaypointReplannerNode wr; ros::spin(); return 0;} â€‹ åœ¨mainå‡½æ•°ä¸­åªåšäº†ä¸€ä»¶äº‹ï¼Œæ–°å»ºWaypointReplannerNodeå¯¹è±¡wrï¼Œ å› æ­¤è½¬åˆ°WaypointReplannerNodeç±»çš„æ„é€ å‡½æ•°ï¼Œ æ„é€ å‡½æ•°å†…å®ç°äº†è¯é¢˜çš„è®¢é˜…å’Œå‘å¸ƒã€‚å…¶ä¸­è®¢é˜…çš„â€œ/based/waypoints_rawâ€å°±æ˜¯å‰é¢waypoint_loaderèŠ‚ç‚¹æ‰€å‘å¸ƒçš„è¯é¢˜ã€‚ 1234567891011121314151617WaypointReplannerNode::WaypointReplannerNode() : pnh_(&quot;~&quot;), is_first_publish_(true){ WaypointReplannerConfig temp_config; //...(ä¸‹ç•¥) if (use_decision_maker_) { lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(&quot;/based/lane_waypoints_array&quot;, 10, true); } else { lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(&quot;/lane_waypoints_array&quot;, 10, true); } lane_sub_ = nh_.subscribe(&quot;/based/lane_waypoints_raw&quot;, 1, &amp;WaypointReplannerNode::laneCallback, this); config_sub_ = nh_.subscribe(&quot;/config/waypoint_replanner&quot;, 1, &amp;WaypointReplannerNode::configCallback, this);} â‘¡ configCallbackå‡½æ•°â€‹ configCallbackå‡½æ•°ä¸ºè¯é¢˜â€œ/config/waypoint_replannerâ€çš„å›è°ƒå‡½æ•°ï¼Œä¸»è¦è¿›è¡Œä¸€äº›æˆå‘˜å˜é‡çš„åˆå§‹åŒ–ã€‚ 12345678910111213void WaypointReplannerNode::configCallback(const autoware_config_msgs::ConfigWaypointReplanner::ConstPtr&amp; conf){ //é‡è§„åˆ’æ¨¡å¼ replanning_mode_ = conf-&gt;replanning_mode; //å®æ—¶è°ƒæ•´æ¨¡å¼ realtime_tuning_mode_ = conf-&gt;realtime_tuning_mode; use_decision_maker_ = conf-&gt;use_decision_maker; replanner_.initParameter(conf); if (!lane_array_.lanes.empty() &amp;&amp; (is_first_publish_ || realtime_tuning_mode_)) { publishLaneArray(); }} â‘¢ laneCallbackå‡½æ•°â€‹ laneCallbackå‡½æ•°ä¸ºè¯é¢˜â€œ/based/lane_waypoints_rawâ€çš„å›è°ƒå‡½æ•°ï¼Œåœ¨åŠ è½½çš„è½¨è¿¹ç‚¹åŸºç¡€ä¸Šé‡æ–°è§„åˆ’å¹¶å‘å¸ƒè¯é¢˜â€œlane_waypoints_arrayâ€ã€‚ 12345void WaypointReplannerNode::laneCallback(const autoware_msgs::LaneArray::ConstPtr&amp; lane_array){ lane_array_ = *lane_array; publishLaneArray();} â‘£ publishLaneArrayå‡½æ•°â€‹ å¦‚æœreplanning_mode ä¸ºtrueï¼Œåˆ™è°ƒç”¨replanå‡½æ•°é‡æ–°è§„åˆ’ã€‚ 12345678910111213void WaypointReplannerNode::publishLaneArray(){ autoware_msgs::LaneArray array(lane_array_); if (replanning_mode_) { //é‡è§„åˆ’è·¯å¾„ replan(array); } //å‘å¸ƒé‡æ–°è§„åˆ’è¿‡çš„è·¯å¾„é›†åˆ lane_pub_.publish(array); is_first_publish_ = false;} â‘¤ replanå‡½æ•°â€‹ replanå‡½æ•°å†…éå†lane_array.lanesã€‚å¯¹æ¯ä¸€æ¡Laneï¼Œreplanner_éƒ½è°ƒreplanLaneWaypointVelå‡½æ•°ã€‚ 12345678void WaypointReplannerNode::replan(autoware_msgs::LaneArray&amp; lane_array){ for (auto &amp;el : lane_array.lanes) { //é‡è§„åˆ’è·¯æ ‡ç‚¹é€Ÿåº¦ replanner_.replanLaneWaypointVel(el); }} â‘¥ replanLaneWaypointVelå‡½æ•°â€‹ lanLaneWaypointVelå‡½æ•°ç”¨äºé‡è§„è½¨è¿¹ç‚¹çš„é€Ÿåº¦ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041void replanLaneWaypointVel(autoware_msgs::Lane&amp; lane){ //...(ä¸Šç•¥) unsigned long last = lane.waypoints.size() - 1; limitVelocityByRange(0, last, config_.velocity_max, lane); if (config_.resample_mode) { //é‡é‡‡æ ·è·¯æ ‡ç‚¹ resampleLaneWaypoint(config_.resample_interval, lane, dir); last = lane.waypoints.size() - 1; } // æ ¹æ®æ¯ä¸ªèˆªè·¯ç‚¹çš„æ›²ç‡è®¾ç½®é€Ÿåº¦ if (config_.replan_curve_mode) { std::vector&lt;double&gt; curve_radius; createRadiusList(lane, curve_radius); setVelocityByRange(0, last, config_.velocity_max, lane); for (unsigned long i = 0; i &lt; curve_radius.size(); i++) { lane.waypoints[i].twist.twist.linear.x = std::fmin(lane.waypoints[i].twist.twist.linear.x, std::sqrt(config_.lateral_accel_limit * std::fmax(curve_radius[i], config_.radius_min))); } limitVelocityByRange(0, last, config_.velocity_max, lane); } // è®¾ç½®è½¦é“æœ«ç«¯çš„é€Ÿåº¦ if (config_.replan_endpoint_mode) { // å°†æœ€åä¸€ä¸ªèˆªç‚¹çš„é€Ÿåº¦ç½®0 setVelocityByRange(last - 1, last, 0.0, lane); // ä¸ºé™¤æœ€åä¸€ä¸ªèˆªç‚¹ä¹‹å¤–çš„å…¶ä»–èˆªç‚¹è®¾ç½®æœ€å°é€Ÿåº¦ raiseVelocityByRange(0, last - 1, config_.velocity_min, lane); // å†æ¬¡å¹³æ»‘é€Ÿåº¦ limitVelocityByRange(0, last, config_.velocity_max, lane); } if (dir == LaneDirection::Backward) { changeVelSign(lane, false); }} â‘¦ limitVelocityByRangeå‡½æ•°â€‹ ä»£ç ç•¥ï¼Œé€šè¿‡åŠ é€Ÿåº¦ä¸é€Ÿåº¦ä¹‹é—´çš„å…³ç³»è¿›ä¸€æ­¥å¯¹é€Ÿåº¦è¿›è¡Œä¿®æ­£ã€‚ â€‹ å…¶ä¸­ï¼Œaä¸ºæœ€å¤§åŠ é€Ÿåº¦ï¼Œxä¸ºè·ç¦»ï¼ˆæ ¹æ®å‰åä¸¤ä¸ªè½¨è¿¹ç‚¹çš„ä½ç½®ç®—å¾—ï¼‰ã€‚ç”±æ­¤å¯ä»¥è®¡ç®—å¤„åœ¨æœ€å¤§åŠ é€Ÿåº¦çš„é™åˆ¶æ¡ä»¶ä¸‹ï¼Œä¸‹ä¸€è½¨è¿¹ç‚¹çš„é€Ÿåº¦æœ€å¤§/æœ€å°å€¼ã€‚æ®æ­¤è¿›è¡Œä¿®æ­£ã€‚ â‘§ resampleLaneWaypointå‡½æ•°â€‹ é‡é‡‡æ ·è½¨è¿¹ç‚¹ 123456789101112131415161718192021222324252627282930void resampleLaneWaypoint(const double resample_interval, autoware_msgs::Lane&amp; lane, LaneDirection dir){ if (lane.waypoints.size() &lt; 2) { return; } autoware_msgs::Lane original_lane(lane); ... for (unsigned long i = 1; i &lt; original_lane.waypoints.size(); i++) { //é‡‡æ ·ä¸‰ä¸ªè½¨è¿¹ç‚¹ //[0] = previous point, [1] = target point, [2] = next point CbufGPoint curve_point = getCrvPointsOnResample(lane, original_lane, i); const std::vector&lt;double&gt; curve_param = calcCurveParam(curve_point); lane.waypoints.back().twist.twist = original_lane.waypoints[i - 1].twist.twist; lane.waypoints.back().wpstate = original_lane.waypoints[i - 1].wpstate; lane.waypoints.back().change_flag = original_lane.waypoints[i - 1].change_flag; // å¦‚æœç›´è¡Œ if (curve_param.empty()) { resampleOnStraight(curve_point, lane, dir); } // å¦‚æœè½¬å¼¯ else { resampleOnCurve(curve_point[1], curve_param, lane, dir); } } ...} â‘¨getCrvPointsOnResampleå‡½æ•°â€‹ åœ¨laneå’Œoriginal_laneä¸Šé€‰æ‹©ä¸‰ä¸ªç‚¹ä½œä¸ºåœ†å¼§ä¸Šçš„ç‚¹ 1234567891011121314151617const CbufGPoint getCrvPointsOnResample( const autoware_msgs::Lane&amp; lane, const autoware_msgs::Lane&amp; original_lane, unsigned long original_index) const{ unsigned long id = original_index; CbufGPoint curve_point(3); const unsigned int n = (config_.lookup_crv_width - 1) / 2; const autoware_msgs::Waypoint cp[3] = { (lane.waypoints.size() &lt; n) ? lane.waypoints.front() : lane.waypoints[lane.waypoints.size() - n], original_lane.waypoints[id], (id &lt; original_lane.waypoints.size() - n) ? original_lane.waypoints[id + n] : original_lane.waypoints.back() }; for (int i = 0; i &lt; 3; i++) { curve_point.push_back(cp[i].pose.pose.position); } return curve_point;} â‘©calcCurveParamå‡½æ•°â€‹ è®¡ç®—åœ†çš„ä¸‰ä¸ªå‚æ•°[center_x , center_y, radius]ï¼Œé¦–å…ˆæ ¹æ®è½¨è¿¹ç‚¹p0, p1, p2ï¼Œè®¡ç®—ä¸‹é¢å„å¼ï¼š ç”±ä¸Šé¢å„å¼ï¼Œè¿›ä¸€æ­¥è®¡ç®—å¾—åˆ°æ›²çº¿çš„ä¸­å¿ƒç‚¹å’Œæ›²ç‡ â€æ ¹æ®åœ†ä¸Šä¸‰ç‚¹æ±‚åœ†å¿ƒå’ŒåŠå¾„â€è¿™ä¸€é—®é¢˜æœ‰å¤šç§è§£æ³•ï¼Œä¸»æµçš„æœ‰ä¸¤ç§ï¼šï¼ˆ1ï¼‰åˆ†åˆ«é€šè¿‡å…¶ä¸­ä¸¤ç‚¹çš„ä¸­å‚çº¿äº¤ç‚¹æ±‚åœ†å¿ƒï¼›ï¼ˆ2ï¼‰é€šè¿‡ä¸‰ä¸ªç‚¹åˆ°åœ†å¿ƒè·ç¦»ç›¸ç­‰è”ç«‹æ–¹ç¨‹æ±‚è§£ã€‚ 12345678910111213141516171819202122const std::vector&lt;double&gt; WaypointReplanner::calcCurveParam(CbufGPoint p) const{ for (int i = 0; i &lt; 3; i++, p.push_back(p.front())) // if exception occured, change points order { //æ ¹æ®å‘é‡å‰ä¹˜çš„æ¨¡çš„å€¼åˆ¤æ–­æ˜¯å¦åœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œå¦‚è¿‡æ¨¡å€¼å°äº1e-8åˆ™è¿‘ä¼¼è®¤ä¸ºä¸‰ç‚¹åœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œåœ†çš„å‚æ•°ä¸ºç©º const double d = 2 * ((p[0].y - p[2].y) * (p[0].x - p[1].x) - (p[0].y - p[1].y) * (p[0].x - p[2].x)); if (fabs(d) &lt; 1e-8) { continue; } const std::vector&lt;double&gt; x2 = { p[0].x * p[0].x, p[1].x * p[1].x, p[2].x * p[2].x }; const std::vector&lt;double&gt; y2 = { p[0].y * p[0].y, p[1].y * p[1].y, p[2].y * p[2].y }; const double a = y2[0] - y2[1] + x2[0] - x2[1]; const double b = y2[0] - y2[2] + x2[0] - x2[2]; std::vector&lt;double&gt; param(3); const double cx = param[0] = ((p[0].y - p[2].y) * a - (p[0].y - p[1].y) * b) / d; const double cy = param[1] = ((p[0].x - p[2].x) * a - (p[0].x - p[1].x) * b) / -d; param[2] = sqrt((cx - p[0].x) * (cx - p[0].x) + (cy - p[0].y) * (cy - p[0].y)); return param; } return std::vector&lt;double&gt;(); // error} 4.3 èŠ‚ç‚¹lane_naviâ€‹ èŠ‚ç‚¹lane_naviçš„ä¸»è¦ä½œç”¨ï¼šæ ¹æ®è·¯ç”±è¯·æ±‚åœ¨çŸ¢é‡åœ°å›¾ä¸­å¯»æ‰¾é€šå¾€ç›®çš„åœ°çš„å„æ¡å¯è¡Œè·¯å¾„ï¼Œå¹¶å‘å¸ƒè‡³è¯é¢˜â€œ/lane_waypoints_arrayâ€ã€‚ 4.3.1 ç¨‹åºè·¯å¾„1src/autoware/core_planning/lane_planner/nodes/lane_navi ä»£ç ç•¥ã€‚ 4.4 èŠ‚ç‚¹lane_ruleâ€‹ èŠ‚ç‚¹lane_ruleçš„ä¸»è¦ä½œç”¨ï¼šå¯¹è¯é¢˜â€œ/lane_waypoints_arrayâ€ä¸Šè½¨è¿¹ç‚¹çš„é€Ÿåº¦æ–¹é¢è¿›ä¸€æ­¥ä¿®æ­£ï¼Œä¸ºçº¢ç¯æ—¶åœ¨åœè½¦çº¿å†…å‡é€Ÿåœè½¦ç­‰åœºæ™¯æä¾›æ”¯æŒï¼Œå‘å¸ƒè¯é¢˜â€œ/traffic_waypoints_arrayâ€ã€‚ 4.4.1 ç¨‹åºè·¯å¾„1src/autoware/core_planning/lane_planner/nodes/lane_rule ä»£ç ç•¥ã€‚ 4.5 èŠ‚ç‚¹lane_selectâ€‹ èŠ‚ç‚¹lane_selectçš„ä¸»è¦ä½œç”¨ï¼šåˆ¤æ–­å½“å‰è½¦é“ï¼ŒåŒæ—¶è§„åˆ’ä»å½“å‰è½¦é“åˆ‡æ¢è‡³å…¶ä»–è½¦é“çš„è½¨è¿¹ï¼Œæ¥ç€æ ¹æ®è¯é¢˜â€œstateâ€ä¸­çš„é©¾é©¶çŠ¶æ€ï¼ˆæ˜¯å¦éœ€è¦æ¢é“ï¼‰å‘å¸ƒå½“å‰è½¦é“æ•°æ®/æ¢åˆ°è½¨è¿¹æ•°æ®è‡³è¯é¢˜â€œbase_waypointsâ€ä¾›å…¶ä»–èŠ‚ç‚¹ç»§ç»­è§„åˆ’ã€‚ 4.5.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch lane_planner lane_select.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹computing é€‰é¡¹å¡ -&gt; mission_planning -&gt;lane_planner-&gt;lane_selectï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 4.5.2 ç¨‹åºè·¯å¾„1src/autoware/core_planning/lane_planner/nodes/lane_select 4.5.3 ä»£ç æ³¨è§£â‘  mainå‡½æ•°â€‹ mainå‡½æ•°åœ¨lane_select_node.cppä¸­ã€‚èŠ‚ç‚¹lane_selectå¯åŠ¨æ—¶æ–°å»ºLaneSelectNodeå¯¹è±¡ï¼Œå…¶æ„é€ å‡½æ•°ä¸­é¦–å…ˆå¯¹ä¸€äº›æˆå‘˜å˜é‡è¿›è¡Œèµ‹å€¼ï¼Œæ¥ç€è°ƒç”¨initForROSå‡½æ•°è®¾ç½®è®¢é˜…è€…/å‘å¸ƒè€…ï¼Œè®¾ç½®å‚æ•°ã€‚ 12345678int main(int argc, char **argv){ ros::init(argc, argv, &quot;lane_select&quot;); lane_planner::LaneSelectNode lsn; lsn.run(); return 0;} â‘¡ initForRoså‡½æ•°â€‹ è¯¥å‡½æ•°è®¾ç½®å‚æ•°ï¼Œè®¾ç½®è®¢é˜…è€…å’Œå‘å¸ƒè€… 123456789101112131415161718void LaneSelectNode::initForROS(){ // setup subscriber sub1_ = nh_.subscribe(&quot;traffic_waypoints_array&quot;, 1, &amp;LaneSelectNode::callbackFromLaneArray, this); sub2_.subscribe(nh_, &quot;current_pose&quot;, 1); sub3_.subscribe(nh_, &quot;current_velocity&quot;, 1); ... // setup publisher pub1_ = nh_.advertise&lt;autoware_msgs::Lane&gt;(&quot;base_waypoints&quot;, 1, true); pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;closest_waypoint&quot;, 1); ... // get from rosparam ... // Kick off a timer to publish base_waypoints, closest_waypoint, change_flag, current_lane_id, and vehicle_location timer_ = nh_.createTimer(ros::Duration(1.0/update_rate_), &amp;LaneSelectNode::processing, this);} â‘¢ callbackFromLaneArrayå‡½æ•°â€‹ ä¸»è¦åŠŸèƒ½æ„å»ºtuple_vec_æˆå‘˜å˜é‡ï¼Œä½¿ç”¨tuple_vec_ æ¥å­˜å‚¨laneArrayç›¸å…³å˜é‡ã€‚ tuple_vec_ æ•°æ®ç±»å‹ä¸ºstd::vector&lt;std::tuple&lt;autoware_msgs::Lane, int32_t, ChangeFlag&gt;&gt; tupleå…ƒç´ çš„å®šä¹‰ä¾æ¬¡ä¸ºï¼šlane, closest_waypoint on the lane to ego-vehicle, lane change flag 123456789101112131415161718void LaneSelectNode::callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr &amp;msg){ tuple_vec_.clear(); tuple_vec_.shrink_to_fit(); tuple_vec_.reserve(msg-&gt;lanes.size()); for (const auto &amp;el : msg-&gt;lanes) { auto t = std::make_tuple(el, -1, ChangeFlag::unknown); tuple_vec_.push_back(t); } lane_array_id_ = msg-&gt;id; current_lane_idx_ = -1; right_lane_idx_ = -1; left_lane_idx_ = -1; is_new_lane_array_ = true; is_lane_array_subscribed_ = true;} â‘£ processingå‡½æ•°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void LaneSelectNode::processing(const ros::TimerEvent&amp; e){ //æ£€æŸ¥ç›¸å…³è¯é¢˜æ˜¯å¦è®¢é˜…æˆåŠŸ if (!isAllTopicsSubscribed()) return; // æ›´æ–°æ¯æ¡laneè·ç¦»è‡ªè½¦æœ€è¿‘è·¯æ ‡ç‚¹,æ›´æ–°tuple_vec_ä¸­closest_waypointå…ƒç´ çš„å€¼ if (!updateClosestWaypointNumberForEachLane()) { publishClosestWaypoint(-1); publishVehicleLocation(-1, lane_array_id_); resetLaneIdx(); return; } if (current_lane_idx_ == -1) { // å¯»æ‰¾è·ç¦»è‡ªè½¦æœ€è¿‘çš„è½¦é“ï¼Œæ›´æ–°current_lane_idx_ findCurrentLane(); } //å¯»æ‰¾ç›¸é‚»è½¦é“æ›´æ–°left_lane_idx_, right_lane_idx_ findNeighborLanes(); if (current_state_ == &quot;LANE_CHANGE&quot;) { try { //æ ¹æ®current_lane_idx_ç¡®å®štuple_vec_ä¸­çš„å…ƒç»„ï¼Œå¹¶æ ¹æ®è¯¥å…ƒç»„ä¸­change_flagå€¼æ›´æ–°current_lane_idx_ //ç„¶åè°ƒç”¨findNeighborLanesæ›´æ–°left_lane_idx_, right_lane_idx_ changeLane(); //æ›´æ–°change laneä¸­æœ€è¿‘è·¯æ ‡ç‚¹åŠchange flag std::get&lt;1&gt;(lane_for_change_) = getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist, std::get&lt;1&gt;(lane_for_change_), distance_threshold_, search_closest_waypoint_minimum_dt_); std::get&lt;2&gt;(lane_for_change_) = static_cast&lt;ChangeFlag&gt;( std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag); //å‘å¸ƒchange lane ç›¸å…³ä¿¡æ¯ publishLane(std::get&lt;0&gt;(lane_for_change_)); publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_)); publishChangeFlag(std::get&lt;2&gt;(lane_for_change_)); publishVehicleLocation(std::get&lt;1&gt;(lane_for_change_), lane_array_id_); } catch (std::out_of_range) { ROS_WARN_THROTTLE(2, &quot;Failed to get closest waypoint num&quot;); } } else { //æ›´æ–°tuple_vec_ä¸­æ¯ä¸ªå…ƒç»„å†…çš„change flagæ•°æ® updateChangeFlag(); //æ›´æ–°lane_for_change_ createLaneForChange(); if (is_new_lane_array_ || prev_lane_idx_ != current_lane_idx_) { publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_))); prev_lane_idx_ = current_lane_idx_; is_new_lane_array_ = false; } //æ ¹æ®å…ƒç»„tuple_vec_.at(current_lane_idx_)ä¸­çš„ä¿¡æ¯å‘å¸ƒæ¶ˆæ¯åˆ°å„ä¸ªè¯é¢˜ publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_))); publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_))); publishVehicleLocation(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)), lane_array_id_); } publishVisualizer(); resetSubscriptionFlag();} 4.6 èŠ‚ç‚¹ astar_avoidâ€‹ èŠ‚ç‚¹astar_avoidçš„ä¸»è¦ä½œç”¨ï¼šåŸºäºå‡ ç‚¹â€œlane_selectâ€å‘å¸ƒåœ¨è¯é¢˜â€œbase_waypointsâ€ä¸Šçš„è½¨è¿¹ï¼Œ åˆ©ç”¨A*ç®—æ³•è§„åˆ’å£éšœè½¨è¿¹å¹¶å‘å¸ƒè‡³è¯é¢˜â€œsafety_waypointsâ€ã€‚ 4.6.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch waypoint_planner astar_avoid.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹computing é€‰é¡¹å¡ -&gt; motion_planner -&gt;waypoint_planner-&gt;astar_avoidï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 4.6.2 ç¨‹åºè·¯å¾„1src/autoware/core_planning/waypoint_planner/src/astar_avoid 4.6.3 å‚æ•°è¯¦æƒ… å‚æ•°å(astar_avoid) ç±»å‹ è¯´æ˜ enable_avoidance bool å¯ç”¨é¿éšœåŠŸèƒ½ avoid_waypoints_velocity double é¿éšœæ—¶æœ€å¤§é€Ÿåº¦ï¼ˆkm/h) avoid_start_velocity double å¼€å§‹é¿éšœé€Ÿåº¦é˜ˆå€¼ï¼ˆkm/h) replan_interval double é‡è§„åˆ’æ—¶é—´é—´éš”ï¼ˆs) search_waypoints_delta int è·¯æ ‡ç‚¹ä¸‹æ ‡æœç´¢å¢é‡ å‚æ•°å(astar_search) ç±»å‹ è¯´æ˜ robot_length double æœºå™¨äººé•¿åº¦ robot_width double æœºå™¨äººå®½åº¦ robot_base2back double è´¨å¿ƒåˆ°è½¦å°¾è·ç¦» minimum_turning_radius double æœ€å°è½¬å¼¯åŠå¾„ theta_size int å†³å®šæœºå™¨äººç§»åŠ¨æ—¶èˆªå‘è§’å˜åŒ–æ­¥é•¿,ç§»åŠ¨ä¸€æ­¥èˆªå‘è§’å˜åŒ–360/theta_size åº¦ angle_goal_range double è·ç¦»ç›®æ ‡ç‚¹è§’åº¦èŒƒå›´ lateral_goal_range double è·ç¦»ç›®æ ‡ç‚¹æ¨ªå‘è·ç¦»èŒƒå›´ longitudinal_goal_range double è·ç¦»ç›®æ ‡ç‚¹çºµå‘è·ç¦»èŒƒå›´ obstacle_threshold double éšœç¢ç‰©é˜ˆå€¼ 4.6.4 ç®—æ³•ä»‹ç»-A*æœç´¢ç®—æ³•â€‹ planAvoidWaypointså‡½æ•°å†…è°ƒç”¨A æœç´¢ç®—æ³•ï¼Œä¸‹é¢ç®€å•ä»‹ç»ä¸‹Aæœç´¢ç®—æ³•ã€‚ â€‹ A*æœç´¢ç®—æ³•æ—¶ä¸€ä¸ªè¢«å¹¿æ³›åº”ç”¨äºè·¯å¾„ä¼˜åŒ–é¢†åŸŸçš„ç®—æ³•ï¼Œå®ƒçš„å¯»è·¯èƒ½åŠ›åŸºäºå¯å‘å¼çš„ä»£ä»·å‡½æ•°ã€‚ â‘  æ …æ ¼åŒ–åœ°å›¾â€‹ A*ç®—æ³•ç¬¬ä¸€æ­¥æ—¶æ …æ ¼åŒ–åœ°å›¾ï¼Œå…·ä½“æ¥è¯´æ˜¯å°†è¿ç»­çš„åœ°å›¾ç¦»æ•£åŒ–ï¼Œç”¨ä¸€ä¸ªå¤§å‹çš„äºŒä½åˆ—è¡¨å­˜å‚¨åœ°å›¾æ•°æ®ã€‚ â‘¡ è¯„ä¼°å‡½æ•°â€‹ A*ç®—æ³•çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªè¯„ä¼°å‡½æ•°ï¼š â€‹ å…¶ä¸­ï¼ŒG(n)ä¸ºä»£ä»·å‡½æ•°ï¼Œåœ¨è¯¥ç¯å¢ƒä¸­Gçš„å€¼ä»£è¡¨ä»èµ·ç‚¹ç§»åŠ¨åˆ°è¯¥æ–¹æ ¼nçš„è·ç¦»ä»£ä»·ã€‚H(n)ä¸ºå¯å‘å¼ä»£ä»·å‡½æ•°ï¼Œåœ¨è¯¥ç¯å¢ƒä¸­Hçš„å€¼ä»£è¡¨è¯¥æ–¹æ ¼nåˆ°ç»ˆç‚¹çš„è·ç¦»ä»£ä»·ã€‚ â‘¢ æœç´¢æ­¥éª¤â€‹ A*æ¶‰åŠä¸¤ä¸ªé‡è¦çš„åˆ—è¡¨ï¼ŒopenListï¼ˆå¼€æ”¾åˆ—è¡¨ï¼Œå­˜å‚¨å€™é€‰èŠ‚ç‚¹ï¼‰å’ŒcloseList(å…³é—­åˆ—è¡¨ï¼Œå­˜å‚¨å·²ç»èµ°è¿‡çš„èŠ‚ç‚¹ï¼‰ã€‚ç®—æ³•å…ˆæŠŠèµ·ç‚¹æ”¾å…¥openListä¸­ï¼Œç„¶åé‡å¤ä¸‹é¢çš„æ­¥éª¤ã€‚ â€‹ éå†openlistï¼Œæ‰¾åˆ°Få€¼æœ€å°çš„èŠ‚ç‚¹å½“åšå½“å‰æœç´¢çš„èµ·ç‚¹ï¼Œç”¨Pè¡¨ç¤ºï¼› â€‹ å°†Pæ”¾å…¥closelistä¸­ï¼Œ ä½œä¸ºå·²ç»èµ°è¿‡çš„èŠ‚ç‚¹ã€‚ â€‹ æ¢ç´¢På‘¨å›´ç›¸é‚»èŠ‚ç‚¹ï¼Œè®¡ç®—ä»–ä»¬çš„Hå€¼ã€Gå€¼å’ŒFå€¼ï¼Œå¹¶æŠŠPè®¾ç½®ä¸ºè¿™äº›èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå°†è¿™äº›èŠ‚ç‚¹å½“åšæ¢ç´¢èŠ‚ç‚¹æ”¾åˆ°Qä¸­ã€‚ â€‹ å¦‚æœQä¸­çš„èŠ‚ç‚¹ä¸åœ¨openlistæˆ–closelistä¸­ï¼Œåˆ™å°†å…¶åŠ å…¥åˆ°openlistä¸­ï¼›Qä¸­èŠ‚ç‚¹å·²ç»å­˜åœ¨äºopenlistä¸­çš„ï¼Œæ¯”è¾ƒè¿™äº›èŠ‚ç‚¹çš„Få€¼å’Œä»–ä»¬åœ¨openlistä¸­çš„Få€¼å“ªä¸ªæ›´å°ï¼ˆFè¶Šå°è¯´æ˜è·¯å¾„æ›´ä¼˜ï¼‰ï¼Œå¦‚æœopenlistä¸­çš„Få€¼æ›´å°æˆ–è€…äºŒè€…ç›¸ç­‰ï¼Œä¸åšä»»ä½•æ”¹å˜ï¼Œå¦åˆ™ç”¨Qä¸­çš„èŠ‚ç‚¹æ›¿æ¢openlistä¸­çš„èŠ‚ç‚¹ï¼› Qä¸­èŠ‚ç‚¹å·²ç»å­˜åœ¨äºcloselistä¸­çš„ï¼Œæ¯”è¾ƒè¿™äº›èŠ‚ç‚¹çš„Få€¼å’Œä»–ä»¬åœ¨closelistä¸­çš„Få€¼å“ªä¸ªæ›´å°ï¼Œå¦‚æœcloselistä¸­çš„Få€¼æ›´å°æˆ–è€…ç›¸ç­‰ï¼Œä¸åšä»»ä½•æ”¹å˜ï¼Œå¦åˆ™å°†å…¶åŠ å…¥åˆ°openlistã€‚ â€‹ å¦‚æœç»ˆç‚¹åœ¨openlistä¸­ï¼Œåˆ™é€€å‡ºæœç´¢ï¼Œæœ€ä¼˜è·¯å¾„å¯ä»¥ä»ç»ˆç‚¹å¼€å§‹ï¼Œæ²¿ç€çˆ¶èŠ‚ç‚¹é€†å‘æº¯æºç›´è‡³èµ·ç‚¹è€Œè·å¾—ï¼›å¦‚æœopenlistæ˜¯ç©ºçš„ï¼Œåˆ™é€€å‡ºï¼Œæ„å‘³ç€èµ·ç‚¹åˆ°ç»ˆç‚¹æ²¡æœ‰ä»»ä½•ä¸€æ¡å¯è¡Œé©¶è·¯å¾„ã€‚ 4.6.5 ä»£ç æ³¨è§£â‘  mainå‡½æ•°â€‹ mainå‡½æ•°åœ¨astar_avoid_node.cppä¸­ï¼ŒèŠ‚ç‚¹çš„ä¸»è¦åŠŸèƒ½é€šè¿‡AstarAvoidå¯¹è±¡çš„runå‡½æ•°å®ç°ã€‚ 12345678int main(int argc, char** argv){ ros::init(argc, argv, &quot;astar_avoid&quot;); AstarAvoid node; node.run(); return 0;} â‘¡ AstarAvoidæ„é€ å‡½æ•°â€‹ æ„é€ å‡½æ•°ä¸»è¦åŠŸèƒ½ä¸ºè®¾ç½®å˜é‡ï¼Œå‘å¸ƒè€…ï¼Œè®¢é˜…è€…ã€‚ 123456789101112131415161718AstarAvoid::AstarAvoid() : nh_() , private_nh_(&quot;~&quot;){ //...(ä¸‹ç•¥) //è®¾ç½®å˜é‡ private_nh_.param&lt;int&gt;(&quot;closest_search_size&quot;, closest_search_size_, 30); //...(ä¸‹ç•¥) //è®¾ç½®å‘å¸ƒè€… safety_waypoints_pub_ = nh_.advertise&lt;autoware_msgs::Lane&gt;(&quot;safety_waypoints&quot;, 1, true); //...(ä¸‹ç•¥) //è®¾ç½®è®¢é˜…è€… base_waypoints_sub_ = nh_.subscribe(&quot;base_waypoints&quot;, 1, &amp;AstarAvoid::baseWaypointsCallback, this); //...(ä¸‹ç•¥) } â‘¢ runå‡½æ•°â€‹ runå‡½æ•°æ˜¯astar_avoidçš„åŠŸèƒ½ä¸»ä½“ã€‚runå‡½æ•°å®é™…ä¸Šæ˜¯ä¸€ä¸ªæœ‰é™çŠ¶æ€æœºï¼Œæ ¹æ®æ¡ä»¶åˆ‡æ¢state_ ï¼Œåœ¨ç‰¹å®šçŠ¶æ€æ›´æ–°avoid_waypoints_ã€‚ â€‹ å‡½æ•°å†…AstarAvoid::STATEçš„å®šä¹‰å¦‚ä¸‹ï¼š 12345678typedef enum STATE { INITIALIZING = -1, RELAYING = 0, STOPPING = 1, PLANNING = 2, AVOIDING = 3 } State; â€‹ runå‡½æ•°ä»£ç åŠçŠ¶æ€è½¬ç§»å…³ç³»å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111void AstarAvoid::run(){ state_ = AstarAvoid::STATE::INITIALIZING; while (ros::ok()) { ros::spinOnce(); // æ£€æŸ¥å„å›è°ƒå‡½æ•°æ˜¯å¦æ­£ç¡®æ¥æ”¶åˆ°å¯¹åº”è¯é¢˜çš„æ¶ˆæ¯ if (checkInitialized()) { break; } ros::Duration(1.0).sleep(); } //ä¸»å¾ªç¯ int end_of_avoid_index = -1; ros::WallTime start_plan_time = ros::WallTime::now(); ros::WallTime start_avoid_time = ros::WallTime::now(); // é‡ç½®éšœç¢ç‰©åæ ‡ obstacle_waypoint_index_ = -1; // å¯åŠ¨æ—¶è®¾ç½®ä¸ºä¸­ç»§æ¨¡å¼ state_ = AstarAvoid::STATE::RELAYING; // å¯åŠ¨å®šæ—¶å™¨å‘å¸ƒè¯é¢˜ timer_ = nh_.createTimer(ros::Duration(1.0/update_rate_), &amp;AstarAvoid::publishWaypoints, this); while (ros::ok()) { ros::spinOnce(); // åˆ¤æ–­æ˜¯å¦å¼€å¯é¿éšœæ¨¡å¼ if (!enable_avoidance_) { rate_-&gt;sleep(); continue; } bool found_obstacle = (obstacle_waypoint_index_ &gt;= 0); //avoid_star_velocity_(km/h)æ˜¯å¼€å§‹é¿è®©æ—¶è‡ªè½¦è½¦é€Ÿé˜ˆå€¼ bool avoid_velocity = (current_velocity_.twist.linear.x &lt; avoid_start_velocity_ / 3.6); // æ›´æ–°çŠ¶æ€state_ if (state_ == AstarAvoid::STATE::RELAYING) { avoid_waypoints_ = base_waypoints_; //å‘ç°éšœç¢ç‰©ï¼Œä»ä¸­ç»§æ¨¡å¼è½¬ä¸ºåœè½¦æ¨¡å¼ if (found_obstacle) { ROS_INFO(&quot;RELAYING -&gt; STOPPING, Decelerate for stopping&quot;); state_ = AstarAvoid::STATE::STOPPING; } } else if (state_ == AstarAvoid::STATE::STOPPING) { //æ£€æŸ¥é‡è§„åˆ’æ—¶é—´é—´éš”æ¡ä»¶ bool replan = ((ros::WallTime::now() - start_plan_time).toSec() &gt; replan_interval_); //éšœç¢ç‰©æ¶ˆå¤±ï¼Œé‡æ–°å›åˆ°ä¸­ç»§æ¨¡å¼ if (!found_obstacle) { ROS_INFO(&quot;STOPPING -&gt; RELAYING, Obstacle disappers&quot;); state_ = AstarAvoid::STATE::RELAYING; } //éšœç¢ç‰©ä»ç„¶å­˜åœ¨ï¼Œä¸”æ»¡è¶³é‡è§„åˆ’æ—¶é—´é—´éš”å’Œé€Ÿåº¦è¦æ±‚ï¼Œä»åœè½¦æ¨¡å¼è½¬ä¸ºè§„åˆ’æ¨¡å¼ else if (replan &amp;&amp; avoid_velocity) { ROS_INFO(&quot;STOPPING -&gt; PLANNING, Start A* planning&quot;); state_ = AstarAvoid::STATE::PLANNING; } } else if (state_ == AstarAvoid::STATE::PLANNING) { start_plan_time = ros::WallTime::now(); //ç¡®å®šè§„é¿è·¯çº¿å¹¶ç›¸åº”æ·»åŠ åˆ°avoid_waypoints_, //åŒæ—¶æ›´æ–°ä¼ å…¥å‡½æ•°çš„end_of_avoid_index //é¿éšœè·¯çº¿è§„åˆ’æˆåŠŸåˆ™ä»è§„åˆ’æ¨¡å¼è½¬ä¸ºé¿éšœæ¨¡å¼ï¼Œå¦åˆ™åˆ‡æ¢ä¸ºåœè½¦æ¨¡å¼ if (planAvoidWaypoints(end_of_avoid_index)) { ROS_INFO(&quot;PLANNING -&gt; AVOIDING, Found path&quot;); state_ = AstarAvoid::STATE::AVOIDING; start_avoid_time = ros::WallTime::now(); closest_waypoint_index_ = -1; } else { ROS_INFO(&quot;PLANNING -&gt; STOPPING, Cannot find path&quot;); state_ = AstarAvoid::STATE::STOPPING; } } else if (state_ == AstarAvoid::STATE::AVOIDING) { updateClosestWaypoint(avoid_waypoints_, current_pose_global_.pose, closest_search_size_); //å¦‚æœè‡ªè½¦ä½ç½®è¶…è¿‡é¿éšœè·¯çº¿ç»ˆç‚¹ï¼Œåˆ™ä»é¿éšœæ¨¡å¼è½¬ä¸ºä¸­ç»§æ¨¡å¼ if (closest_waypoint_index_ &gt; end_of_avoid_index) { ROS_INFO(&quot;AVOIDING -&gt; RELAYING, Reached goal&quot;); state_ = AstarAvoid::STATE::RELAYING; closest_waypoint_index_ = -1; } else if (found_obstacle &amp;&amp; avoid_velocity) { bool replan = ((ros::WallTime::now() - start_avoid_time).toSec() &gt; replan_interval_); if (replan) { ROS_INFO(&quot;AVOIDING -&gt; STOPPING, Abort avoiding&quot;); state_ = AstarAvoid::STATE::STOPPING; } } } rate_-&gt;sleep(); }} â‘£ planAvoidWaypointså‡½æ•°â€‹ é€æ­¥æ›´æ–°ç›®æ ‡ä½å§¿ï¼Œå¹¶æ‰§è¡Œä»å½“å‰ä½å§¿åˆ°ç›®æ ‡ä½å§¿çš„åŸºäºA*ç®—æ³•çš„å¢é‡æœç´¢ï¼Œç¡®å®šé¿éšœè·¯çº¿å¹¶ç›¸åº”æ·»åŠ è¿›avoid_waypoints_ã€‚å¦å¤–ï¼Œæ›´æ–°ä¼ å…¥å‡½æ•°çš„end_of_avoid_indexã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061bool AstarAvoid::planAvoidWaypoints(int&amp; end_of_avoid_index){ bool found_path = false; //è·å¾—avoid_waypoints_ä¸­çš„â€œè·ç¦»æœ€è¿‘è½¨è¿¹ç‚¹â€çš„ä¸‹æ ‡ updateClosestWaypoint(avoid_waypoints_, current_pose_global_.pose, closest_search_size_); if (closest_waypoint_index_ == -1) { return false; } // é€æ­¥æ›´æ–°ç›®æ ‡ä½å§¿å¹¶æ‰§è¡ŒA*æœç´¢ // search_waypoints_sizeç”¨äºè·³è¿‡è½¨è¿¹ç‚¹ä»¥è¿›è¡Œå¢é‡æœç´¢ for (int i = search_waypoints_delta_; i &lt; static_cast&lt;int&gt;(search_waypoints_size_); i += search_waypoints_delta_) { // æ›´æ–°ç›®æ ‡ä¸‹æ ‡goal_waypoint_index int goal_waypoint_index = closest_waypoint_index_ + obstacle_waypoint_index_ + i; if (goal_waypoint_index &gt;= static_cast&lt;int&gt;(avoid_waypoints_.waypoints.size())) { break; } // æ›´æ–°ç›®æ ‡ä½å§¿ goal_pose_global_ = avoid_waypoints_.waypoints[goal_waypoint_index].pose; goal_pose_local_.header = costmap_.header /*æŒ‡å®šgoal_pose_local_å’Œgoal_pose_global_å„è‡ªçš„frame_id, *å°±å¯ä»¥é€šè¿‡transformPoseå‡½æ•°è·å¾—ä½å§¿goal_pose_global_.pose_ *ä»globalåæ ‡ç³»ä¸‹è½¬æ¢åˆ°costmap_åæ ‡ç³»ä¸‹çš„æ–°ä½å§¿goal_pose_local_.pose */ goal_pose_local_.pose = transformPose(goal_pose_global_.pose, getTransform(costmap_.header.frame_id, goal_pose_global_.header.frame_id)); // astar_çš„å®šä¹‰æ˜¯ AstarSearch astar_ // æ ¹æ®costmap_çš„ä¿¡æ¯åˆå§‹åŒ–astar_å†…A*æœç´¢çš„ä»£ä»·åœ°å›¾nodes_ astar_.initialize(costmap_); // å¯åŠ¨A*æœç´¢ found_path = astar_.makePlan(current_pose_local_.pose, goal_pose_local_.pose); static ros::Publisher pub = nh_.advertise&lt;nav_msgs::Path&gt;(&quot;debug&quot;, 1, true); if (found_path) { pub.publish(astar_.getPath()); end_of_avoid_index = goal_waypoint_index; //å°†ç”¨äºé¿éšœçš„è½¨è¿¹astar_.getPath()åˆå¹¶è¿›avoid_waypoints //å¹¶æ›´æ–°end_of_avoid_index mergeAvoidWaypoints(astar_.getPath(), end_of_avoid_index); if (avoid_waypoints_.waypoints.size() &gt; 0) { ROS_INFO(&quot;Found GOAL at index = %d&quot;, goal_waypoint_index); astar_.reset(); return true; } else { found_path = false; } } astar_.reset(); } ROS_ERROR(&quot;Can't find goal...&quot;); return false;} â‘¤ searchå‡½æ•°â€‹ searchå‡½æ•°å¯åŠ¨åŸºäºA*ç®—æ³•çš„æœç´¢è¿‡ç¨‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119bool AstarSearch::search(){ ros::WallTime begin = ros::WallTime::now(); // å¼€å§‹A*æœç´¢ // å¦‚æœopenlistä¸ºç©ºï¼Œæœç´¢å¤±è´¥img while (!openlist_.empty()) { // æ£€æŸ¥æ—¶é—´å¹¶åœ¨æœç´¢æ—¶é—´åˆ°è¾¾é™åˆ¶æ—¶ç»ˆæ­¢ ros::WallTime now = ros::WallTime::now(); double msec = (now - begin).toSec() * 1000.0; if (msec &gt; time_limit_) { ROS_DEBUG(&quot;Exceed time limit of %lf [ms]&quot;, time_limit_); return false; } // ä»openlistä¸­å¼¹å‡ºæœ€ä½ä»£ä»·èŠ‚ç‚¹ SimpleNode top_sn = openlist_.top(); openlist_.pop(); AstarNode* current_an = &amp;nodes_[top_sn.index_y][top_sn.index_x][top_sn.index_theta]; //å°†è¯¥èŠ‚ç‚¹çŠ¶æ€è®¾ä¸ºCLOSEDï¼Œå³å°†è¯¥èŠ‚ç‚¹æ”¾å…¥closelistä¸­ current_an-&gt;status = STATUS::CLOSED; //ç›®æ ‡æ£€æŸ¥ if (isGoal(current_an-&gt;x, current_an-&gt;y, current_an-&gt;theta)) { ROS_DEBUG(&quot;Search time: %lf [msec]&quot;, (now - begin).toSec() * 1000.0); setPath(top_sn); return true; } // æ‹“å±•èŠ‚ç‚¹ for (const auto&amp; state : state_update_table_[top_sn.index_theta]) { //ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ double next_x = current_an-&gt;x + state.shift_x; double next_y = current_an-&gt;y + state.shift_y; double next_theta = modifyTheta(current_an-&gt;theta + state.rotation); double move_cost = state.step; double move_distance = current_an-&gt;move_distance + state.step; // å¢åŠ åå‘ä»£ä»· if (state.back != current_an-&gt;back) move_cost *= reverse_weight_; // è®¡ç®—ä¸‹ä¸€ä¸ªçŠ¶æ€çš„ä¸‹æ ‡ SimpleNode next_sn; geometry_msgs::Point next_pos; next_pos.x = next_x; next_pos.y = next_y; pointToIndex(next_pos, &amp;next_sn.index_x, &amp;next_sn.index_y); next_sn.index_theta = top_sn.index_theta + state.index_theta; // é¿å…ä¸‹æ ‡æ— æ•ˆ next_sn.index_theta = (next_sn.index_theta + theta_size_) % theta_size_; // æ£€æŸ¥ä¸‹æ ‡æ˜¯å¦æœ‰æ•ˆ if (isOutOfRange(next_sn.index_x, next_sn.index_y) || detectCollision(next_sn)) { continue; } AstarNode* next_an = &amp;nodes_[next_sn.index_y][next_sn.index_x][next_sn.index_theta]; double next_gc = current_an-&gt;gc + move_cost; double next_hc = nodes_[next_sn.index_y][next_sn.index_x][0].hc; // wavefront æˆ–è·ç¦»å˜æ¢å¯å‘å¼ // å¢åŠ æ¬§å¼è·ç¦»æˆæœ¬ if (use_potential_heuristic_) { next_gc += nodes_[next_sn.index_y][next_sn.index_x][0].hc; next_hc += calcDistance(next_x, next_y, goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y); distance_heuristic_weight_; } //...(ä¸‹ç•¥) // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çŠ¶æ€ä¸ºSTATUS::NONE if (next_an-&gt;status == STATUS::NONE) { next_an-&gt;status = STATUS::OPEN; next_an-&gt;x = next_x; next_an-&gt;y = next_y; next_an-&gt;theta = next_theta; next_an-&gt;gc = next_gc; next_an-&gt;hc = next_hc; next_an-&gt;move_distance = move_distance; next_an-&gt;back = state.back; next_an-&gt;parent = current_an; next_sn.cost = next_an-&gt;gc + next_an-&gt;hc; openlist_.push(next_sn); continue; } // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åœ¨openlistæˆ–closelistä¸­ if (next_an-&gt;status == STATUS::OPEN || next_an-&gt;status == STATUS::CLOSED) { if (next_gc &lt; next_an-&gt;gc) { next_an-&gt;status = STATUS::OPEN; next_an-&gt;x = next_x; next_an-&gt;y = next_y; next_an-&gt;theta = next_theta; next_an-&gt;gc = next_gc; next_an-&gt;hc = next_hc; // already calculated ? next_an-&gt;move_distance = move_distance; next_an-&gt;back = state.back; next_an-&gt;parent = current_an; next_sn.cost = next_an-&gt;gc + next_an-&gt;hc; openlist_.push(next_sn); continue; } } } // çŠ¶æ€æ›´æ–° } // å¯»è·¯å¤±è´¥ ROS_DEBUG(&quot;Open list is empty...&quot;); return false;} 4.7 èŠ‚ç‚¹velocity_setâ€‹ èŠ‚ç‚¹velocity_setçš„ä¸»è¦ä½œç”¨ï¼šåœ¨èŠ‚ç‚¹astar_avoidå‘å¸ƒåœ¨è¯é¢˜â€œsafety_waypointsâ€ä¸Šçš„è½¨è¿¹åŸºç¡€ä¸Šï¼Œä¿®æ­£æ— äººè½¦é è¿‘éšœç¢ç‰©æˆ–åœè½¦çº¿çš„é€Ÿåº¦ã€‚ 4.7.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch waypoint_planner velocity_set_option.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹computing é€‰é¡¹å¡ -&gt; motion_planner -&gt;waypoint_planner-&gt;velocity_setï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 4.7.2 ç¨‹åºè·¯å¾„1src/autoware/core_planning/waypoint_planner/src/velocity_set 4.7.3 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ remove_points_upto double åˆ é™¤ç‚¹èŒƒå›´ stop_distance_obstacle double éšœç¢ç‰©å‰åœè½¦è·ç¦» stop_distance_stopline double åœæ­¢çº¿å‰åœè½¦è·ç¦» detection_range double éšœç¢ç‰©æ£€æµ‹èŒƒå›´ deceleration_range double å‡é€Ÿæ£€æµ‹èŒƒå›´ points_threshold int ç‚¹äº‘ä¸ªæ•°é˜ˆå€¼ deceleration_obstacle double å‰æ–¹å­˜åœ¨éšœç¢ç‰©æ—¶å‡é€Ÿåº¦å€¼ deceleration_stopline double å‰æ–¹å­˜åœ¨åœæ­¢çº¿æ—¶å‡é€Ÿåº¦å€¼ velocity_change_limit double é€Ÿåº¦å˜åŒ–é™åˆ¶ï¼ˆkm/h) 4.7.4 ä»£ç æ³¨è§£â‘  mainå‡½æ•°é¦–å…ˆæ˜¯mainå‡½æ•°ï¼Œmainå‡½æ•°åœ¨velocity_set.cppä¸­ï¼Œä¸»è¦åŠŸèƒ½ä¸ºï¼š â€‹ 1.Crosswalk: äººè¡Œæ¨ªé“æ£€æµ‹ â€‹ 2.obstacleDetection: æ£€æµ‹éšœç¢ç‰©ä½äºå½“å‰è½¨è¿¹è·¯æ ‡ç‚¹ç´¢å¼•å€¼ï¼Œå¹¶æ ¹æ®è·ç¦»ä¿¡æ¯åˆ¤æ–­å½“å‰éœ€è¦å‡é€Ÿè¿˜æ˜¯åœè½¦ï¼ˆEControl::STOPã€DECELERATEï¼‰ changeWaypoints: æ ¹æ®éšœç¢ç‰©ä¿¡æ¯ä¿®æ”¹waypointsä¸­çš„é€Ÿåº¦ä¿¡æ¯ï¼Œè¿›è€Œåœ¨pure_pursuitèŠ‚ç‚¹å½¢æˆå‡é€Ÿæˆ–è€…åœè½¦çš„æ•ˆæœ å‘å¸ƒè·¯å¾„åŠéšœç¢ç‰©ä¿¡æ¯ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112int main(int argc, char** argv){ //...(ä¸‹ç•¥) //ç±»å¯¹è±¡ CrossWalk crosswalk; VelocitySetPath vs_path; VelocitySetInfo vs_info; // é€Ÿåº¦è®¾å®šè·¯å¾„è®¢é˜…å™¨ ros::Subscriber waypoints_sub = nh.subscribe(&quot;safety_waypoints&quot;, 1, &amp;VelocitySetPath::waypointsCallback, &amp;vs_path); ros::Subscriber current_vel_sub = nh.subscribe(&quot;current_velocity&quot;, 1, &amp;VelocitySetPath::currentVelocityCallback, &amp;vs_path); // é€Ÿåº¦è®¾å®šä¿¡æ¯è®¢é˜…å™¨ ros::Subscriber config_sub = nh.subscribe(&quot;config/velocity_set&quot;, 1, &amp;VelocitySetInfo::configCallback, &amp;vs_info); // ç‚¹äº‘è®¢é˜…å™¨ ros::Subscriber points_sub = nh.subscribe(points_topic, 1, &amp;VelocitySetInfo::pointsCallback, &amp;vs_info); //...(ä¸‹ç•¥) // çŸ¢é‡åœ°å›¾è®¢é˜…å™¨ if (enable_crosswalk_detection) { crosswalk.setMultipleDetectionFlag(enable_multiple_crosswalk_detection); ros::Subscriber sub_dtlane = nh.subscribe(&quot;vector_map_info/cross_walk&quot;, 1, &amp;CrossWalk::crossWalkCallback, &amp;crosswalk); ros::Subscriber sub_area = nh.subscribe(&quot;vector_map_info/area&quot;, 1, &amp;CrossWalk::areaCallback, &amp;crosswalk); ros::Subscriber sub_line = nh.subscribe(&quot;vector_map_info/line&quot;, 1, &amp;CrossWalk::lineCallback, &amp;crosswalk); ros::Subscriber sub_point = nh.subscribe(&quot;vector_map_info/point&quot;, 1, &amp;CrossWalk::pointCallback, &amp;crosswalk); } // TFç›‘å¬ tf2_ros::Buffer tfBuffer;obstacleDetection tf2_ros::TransformListener tfListener(tfBuffer); //å‘å¸ƒå™¨ ros::Publisher detection_range_markers_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;detection_range&quot;, 1); ros::Publisher obstacle_marker_pub = nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;obstacle&quot;, 1); ros::Publisher obstacle_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;(&quot;obstacle_waypoint&quot;, 1, true); ros::Publisher stopline_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;(&quot;stopline_waypoint&quot;, 1, true); ros::Publisher final_waypoints_pub = nh.advertise&lt;autoware_msgs::Lane&gt;(&quot;final_waypoints&quot;, 1, true); ros::Rate loop_rate(update_rate); while (ros::ok()) { ros::spinOnce(); try { geometry_msgs::TransformStamped map_to_lidar_tf = tfBuffer.lookupTransform( &quot;map&quot;, &quot;velodyne&quot;, ros::Time::now(), ros::Duration(2.0)); vs_info.setLocalizerPose(map_to_lidar_tf); } catch(tf2::TransformException &amp;ex) { ROS_WARN(&quot;Failed to get map-&gt;lidar transform. skip computation: %s&quot;, ex.what()); continue; } // å› ä¸ºsafety_waypointsçš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºè·ç¦»è‡ªè½¦æœ€è¿‘è½¨è¿¹ç‚¹ï¼Œæ‰€ä»¥è®¾ç½®current_closest_waypoint ä¸º0 int32_t current_closest_waypoint = 0; int32_t closest_crosswalk_waypoint = -1; if (!vs_info.getSetPose() || !vs_path.getSetPath() || vs_path.getPrevWaypointsSize() == 0) { loop_rate.sleep(); continue; } if (enable_crosswalk_detection) { //æ›´æ–°crosswalkå†…çš„bdID_,detection_points_å’Œset_points if (crosswalk.loaded_all &amp;&amp; !crosswalk.set_points) { crosswalk.setCrossWalkPoints(); } // å¦‚æœ crosswalk.loaded_allä¸ºfalse, è®¾ç½® closest_crosswalk_waypointä¸º -1. closest_crosswalk_waypoint = crosswalk.findClosestCrosswalk(current_closest_waypoint, vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE); } crosswalk.setDetectionWaypoint(closest_crosswalk_waypoint); int32_t traffic_waypoint_idx = -1; //éšœç¢ç‰©æ£€æµ‹å¹¶å¯è§†åŒ–éšœç¢ç‰© EControl detection_result = obstacleDetection(current_closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info,detection_range_markers_pub, obstacle_marker_pub, &amp;traffic_waypoint_idx); // æ ¹æ®å‰æ–¹éšœç¢ç‰©/åœè½¦çº¿æƒ…å†µæ›´æ–°vs_pathä¸­çš„è½¨è¿¹ç‚¹é€Ÿåº¦ï¼Œå¹¶ä»vs_pathä¸­æˆªå–éƒ¨åˆ†è½¨è¿¹å‘å¸ƒåˆ°è¯é¢˜â€œfinal_waypointsâ€. changeWaypoints(vs_info, detection_result, current_closest_waypoint, traffic_waypoint_idx, &amp;vs_path); vs_path.setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), current_closest_waypoint, vs_info.getControlPose()); final_waypoints_pub.publish(vs_path.getTemporalWaypoints()); // å‘å¸ƒéšœç¢ç‰©å’Œåœæ­¢çº¿ä¿¡æ¯ std_msgs::Int32 obstacle_waypoint_index; std_msgs::Int32 stopline_waypoint_index; if (detection_result == EControl::STOP) { obstacle_waypoint_index.data = traffic_waypoint_idx; stopline_waypoint_index.data = -1; } else if (detection_result == EControl::STOPLINE) { obstacle_waypoint_index.data = -1; stopline_waypoint_index.data = traffic_waypoint_idx; } else { obstacle_waypoint_index.data = -1; stopline_waypoint_index.data = -1; } obstacle_waypoint_pub.publish(obstacle_waypoint_index); stopline_waypoint_pub.publish(stopline_waypoint_index); //é‡ç½®vs_pathå†…çš„set_path_;æ¸…ç©ºvs_infoä¸­çš„points_ vs_path.resetFlag(); vs_info.clearPoints(); loop_rate.sleep(); } return 0;} â‘¡ VelocitySetPathç±»ä¸­çš„å›è°ƒå‡½æ•°waypointsCallbackå’ŒcurrentVelocityCallbackâ€‹ waypointCallbackå‡½æ•°å’ŒcurrentVelocityCallbackå‡½æ•°åˆ†åˆ«æ˜¯è¯é¢˜â€œsafety_waypointsâ€å’Œâ€œcurrent_velocityâ€çš„å›è°ƒå‡½æ•°ã€‚waypointCallbackå‡½æ•°æ›´æ–°vs_pathå†…çš„ autoware_msgs::Laneç±»å‹å˜é‡original_waypoints_ å’Œupdated_waypoints_ ä»¥åŠboolå‹å˜é‡set_path_ ã€‚currentVelocityCallbackå‡½æ•°æ›´æ–°vs_pathå†…çš„current_velocity_å˜é‡ã€‚ â‘¢ VelocitySetInfoç±»ä¸­çš„å›è°ƒå‡½æ•°configCallback12345678910111213141516171819202122void VelocitySetInfo::configCallback(const autoware_config_msgs::ConfigVelocitySetConstPtr &amp;config){ //ç›¸è·éšœç¢ç‰©çš„åœè½¦è·ç¦»ï¼ˆm) stop_distance_obstacle_ = config-&gt;stop_distance_obstacle; //ç›¸è·åœæ­¢çº¿çš„åœè½¦è·ç¦» (m) stop_distance_stopline_ = config-&gt;stop_distance_stopline; //å¦‚æœéšœç¢ç‰©åœ¨æ­¤èŒƒå›´å†…ï¼Œåœè½¦ stop_range_ = config-&gt;detection_range; //åˆ¤æ–­ä¸ºéšœç¢ç‰©çš„é˜ˆå€¼ points_threshold_ = config-&gt;threshold_points; detection_height_top_ = config-&gt;detection_height_top; detection_height_bottom_ = config-&gt;detection_height_bottom; //é‡åˆ°éšœç¢ç‰©æ—¶å‡é€Ÿçš„åŠ é€Ÿåº¦ deceleration_obstacle_ = config-&gt;deceleration_obstacle; //é‡åˆ°åœæ­¢çº¿æ—¶å‡é€Ÿçš„åŠ é€Ÿåº¦ deceleration_stopline_ = config-&gt;deceleration_stopline; //é€Ÿåº¦å˜åŒ–çš„é™åˆ¶ velocity_change_limit_ = config-&gt;velocity_change_limit / 3.6; // kmph -&gt; mps //å¦‚æœéšœç¢ç‰©åœ¨æ­¤èŒƒå›´å†…ï¼Œå‡é€Ÿ deceleration_range_ = config-&gt;deceleration_range; temporal_waypoints_size_ = config-&gt;temporal_waypoints_size;} â‘£ obstacleDetectionå‡½æ•°â€‹ obstacleDetectionå‡½æ•°ä¸»è¦åŠŸèƒ½ä¸ºæ£€æµ‹éšœç¢ç‰©ï¼Œ å…¶ä¸­åŒ…å«pointsDetection() è¿™ä¸ªå‡½æ•°ï¼Œè€ŒpointsDetection()åˆåŒ…å«äº†detectStopObstacle() å’Œ detectDecelerateObstacle() ä¸¤ä¸ªé‡è¦çš„å‡½æ•° â€‹ detectStopObstacle() å‡½æ•°åŠŸèƒ½ä¸ºéšœç¢ç‰©æ£€æµ‹ï¼Œéœ€åœè½¦ï¼Œ detectDecelerateObstacle() å‡½æ•°åŠŸèƒ½ä¸ºéšœç¢ç‰©æ£€æµ‹ï¼Œéœ€å‡é€Ÿï¼Œ â€‹ â€‹ detectStopObstacleå‡½æ•°ï¼šä»è½¦è¾†ä½ç½®å¼€å§‹ï¼Œå‘åéå†ä¸€å®šæ•°é‡çš„è·¯å¾„ç‚¹(è“è‰²ç‚¹)ï¼Œå¯¹æ¯ä¸ªè·¯å¾„ç‚¹ï¼Œéå†æ‰€æœ‰çš„ç‚¹äº‘ï¼Œå¦‚æœè¯¥è·¯å¾„ç‚¹stop_rangeåŠå¾„å†…ä¸å­˜åœ¨ç‚¹äº‘ï¼Œåˆ™åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªè·¯å¾„ç‚¹ï¼Œå†æ¬¡éå†æ‰€æœ‰ç‚¹äº‘ï¼› â€‹ å½“åœ¨æŸä¸€è·¯å¾„ç‚¹Bçš„stop_rangeèŒƒå›´å†…æ£€æµ‹åˆ°äº†ç‚¹äº‘ï¼Œä¸”ç‚¹äº‘æ•°é‡åœ¨åˆç†èŒƒå›´å†…ï¼ˆå¤§äºpoints_threshold)ï¼Œ åˆ™å°†éšœç¢ç‰©åˆ¤å®šä¸ºstop_obstacleï¼Œéœ€è¦åœè½¦å¤„ç†ã€‚ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//å¯¹å½“å‰ä½ç½®åçš„è·¯å¾„ç‚¹ï¼Œè¿›è¡Œéšœç¢ç‰©æ£€æµ‹ï¼Œå¦‚æœå‡ºç°points_no_groundç‚¹äº‘èšé›†åˆ™è§†ä¸ºéšœç¢ç‰©ç‚¹ã€‚int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const autoware_msgs::Lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range, double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points, EObstacleType* obstacle_type, const int wpidx_detection_result_by_other_nodes){ int stop_obstacle_waypoint = -1; *obstacle_type = EObstacleType::NONE; // start search from the closest waypoint for (int i = closest_waypoint; i &lt; closest_waypoint + STOP_SEARCH_DISTANCE; i++)//STOP_SEARCH_DISTANCEé»˜è®¤æ˜¯60M,æ²¿ç€å½“å‰ä½ç½®å‘åæœç´¢ { //... // waypoint seen by localizer geometry_msgs::Point waypoint = calcRelativeCoordinate(lane.waypoints[i].pose.pose.position, localizer_pose.pose);//è®¡ç®—å®šä½ç‚¹å’Œè·¯å¾„ç‚¹çš„ç›¸å¯¹åæ ‡ tf::Vector3 tf_waypoint = point2vector(waypoint); tf_waypoint.setZ(0); //ä¸è€ƒè™‘zè½´æ•°æ®ï¼Œåªè®¡ç®—å¹³é¢è·ç¦» int stop_point_count = 0; for (const auto&amp; p : points)//éå†points_no_ground(å»é™¤åœ°é¢åçš„ç‚¹äº‘å›¾)ä¸­æ‰€æœ‰çš„ç‚¹ { tf::Vector3 point_vector(p.x, p.y, 0); // 2D distance between waypoint and points (obstacle) double dt = tf::tfDistance(point_vector, tf_waypoint);//è®¡ç®—éšœç¢ç‰©ç‚¹äº‘ä¸è·¯å¾„ç‚¹ä¹‹é—´çš„è·ç¦» if (dt &lt; stop_range)//dtèŒƒå›´å†…çš„ç‚¹äº‘å‡è§†ä¸ºéšœç¢ç‰©stop_obstacle { stop_point_count++; geometry_msgs::Point point_temp; point_temp.x = p.x; point_temp.y = p.y; point_temp.z = p.z; obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));//æŠŠæ‰€æœ‰çš„ç‚¹äº‘æ”¾åˆ°å®¹å™¨ä¸­ï¼Œ } } // there is an obstacle if the number of points exceeded the threshold if (stop_point_count &gt; points_threshold)//å¦‚æœéšœç¢ç‰©è¿‡äºåºå¤§ï¼Œåˆ™è§†ä¸ºä¸å¯é€šè¿‡ï¼ŒæŠŠObstacleTypeçŠ¶æ€è®¾ç½®ä¸ºON_WAYPOINTSã€‚ { stop_obstacle_waypoint = i; *obstacle_type = EObstacleType::ON_WAYPOINTS; break; } obstacle_points-&gt;clearStopPoints(); // check next waypoint... }} â€‹ pointsDetectionå‡½æ•°è°ƒç”¨detectStopObstacle() å’Œ detectDecelerateObstacle()ä¸¤ä¸ªå‡½æ•°ï¼Œç”¨æ¥æ£€æµ‹éšœç¢ç‰©åŠåˆ¤æ–­æ§åˆ¶æŒ‡ä»¤æ˜¯STOPè¿˜æ˜¯DECELERATIONï¼Œä¸è€ƒè™‘äººè¡Œæ¨ªé“çš„æƒ…å†µä¸‹ï¼Œæµç¨‹å›¾åŠä»£ç å¦‚ä¸‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; pcl_points, const int closest_waypoint, const autoware_msgs::Lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info, int* obstacle_waypoint, ObstaclePoints* obstacle_points){ // no input for detection || no closest waypoint if ((pcl_points.empty() &amp;&amp; vs_info.getDetectionResultByOtherNodes() == -1) || closest_waypoint &lt; 0) return EControl::KEEP; EObstacleType obstacle_type = EObstacleType::NONE; int stop_obstacle_waypoint = detectStopObstacle(pcl_points, closest_waypoint, lane, crosswalk, vs_info.getStopRange(), vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points, &amp;obstacle_type, vs_info.getDetectionResultByOtherNodes()); // skip searching deceleration range if (vs_info.getDecelerationRange() &lt; 0.01) { *obstacle_waypoint = stop_obstacle_waypoint; if (stop_obstacle_waypoint &lt; 0) return EControl::KEEP; else if (obstacle_type == EObstacleType::ON_WAYPOINTS || obstacle_type == EObstacleType::ON_CROSSWALK) return EControl::STOP; else if (obstacle_type == EObstacleType::STOPLINE) return EControl::STOPLINE; else return EControl::OTHERS; } int decelerate_obstacle_waypoint = detectDecelerateObstacle(pcl_points, closest_waypoint, lane, vs_info.getStopRange(), vs_info.getDecelerationRange(), vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points); // stop obstacle was not found if (stop_obstacle_waypoint &lt; 0) { *obstacle_waypoint = decelerate_obstacle_waypoint; return decelerate_obstacle_waypoint &lt; 0 ? EControl::KEEP : EControl::DECELERATE; } // stop obstacle was found but decelerate obstacle was not found if (decelerate_obstacle_waypoint &lt; 0) { *obstacle_waypoint = stop_obstacle_waypoint; return EControl::STOP; } // about 5.0 meter double waypoint_interval = getPlaneDistance(lane.waypoints[0].pose.pose.position, lane.waypoints[1].pose.pose.position); int stop_decelerate_threshold = 5 / waypoint_interval; // both were found if (stop_obstacle_waypoint - decelerate_obstacle_waypoint &gt; stop_decelerate_threshold) { *obstacle_waypoint = decelerate_obstacle_waypoint; return EControl::DECELERATE; } else { *obstacle_waypoint = stop_obstacle_waypoint; return EControl::STOP; }} â€‹ obstacleDetectionå‡½æ•°è°ƒç”¨pointsDetectionå‡½æ•°å®ç°éšœç¢ç‰©æ£€æµ‹åŠŸèƒ½ã€‚ 12345678910111213141516171819EControl obstacleDetection(int closest_waypoint, const autoware_msgs::Lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub, const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint){ ObstaclePoints obstacle_points; EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info, obstacle_waypoint, &amp;obstacle_points); //... // stop or decelerate because we found obstacles if (detection_result == EControl::STOP || detection_result == EControl::STOPLINE || detection_result == EControl::DECELERATE) { displayObstacle(detection_result, obstacle_points, obstacle_pub); prev_detection = detection_result; false_count = 0; prev_obstacle_waypoint = *obstacle_waypoint; return detection_result; } //...} â‘£ changeWaypointså‡½æ•°â€‹ æ ¹æ®å‰æ–¹éšœç¢ç‰©/åœè½¦çº¿æƒ…å†µï¼Œæ›´æ–°vs_pathå†…çš„update_waypoints_ä¸­çš„è½¨è¿¹ç‚¹é€Ÿåº¦ 1234567891011121314151617181920212223242526272829303132void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint,int obstacle_waypoint, VelocitySetPath* vs_path){ double deceleration = 0.0; double velocity_change_limit = vs_info.getVelocityChangeLimit(); if (detection_result == EControl::STOP || detection_result == EControl::STOPLINE) { // åœ¨éšœç¢ç‰©/åœæ­¢çº¿å‰åœè½¦ // stop_waypointå¤§çº¦è·ç¦»éšœç¢ç‰©/åœè½¦çº¿stop_distanceç±³è¿œ int stop_distance = (detection_result == EControl::STOP) ? vs_info.getStopDistanceObstacle() : vs_info.getStopDistanceStopline(); deceleration = (detection_result == EControl::STOP) ? vs_info.getDecelerationObstacle() : vs_info.getDecelerationStopline(); //ç¡®å®šä¸obstacle_waypointçš„è·ç¦»ä¸ºstop_distanceç›¸å¯¹åº”è½¨è¿¹ç‚¹ä¸‹æ ‡ int stop_waypoint = calcWaypointIndexReverse(vs_path-&gt;getPrevWaypoints(), obstacle_waypoint, stop_distance); //åŸºäºä¸Šè¿°ä¿¡æ¯æ›´æ–°update_waypoints_ä¸­çš„è½¨è¿¹ç‚¹é€Ÿåº¦ vs_path-&gt;changeWaypointsForStopping(stop_waypoint, obstacle_waypoint, closest_waypoint, deceleration); } else { // åœ¨éšœç¢ç‰©å‰å‡é€Ÿ vs_path-&gt;initializeNewWaypoints(); deceleration = vs_info.getDecelerationObstacle(); if (detection_result == EControl::DECELERATE) { vs_path-&gt;changeWaypointsForDeceleration(deceleration, closest_waypoint, obstacle_waypoint); } } //é¿å…æ€¥åŠ é€Ÿå’Œæ€¥å‡é€Ÿ vs_path-&gt;avoidSuddenAcceleration(deceleration, closest_waypoint); vs_path-&gt;avoidSuddenDeceleration(velocity_change_limit, deceleration, closest_waypoint);} 4.8 å‚è€ƒæ–‡çŒ® [1] ææŸï¼Œå¼ å‹æ°‘ï¼Œé‚µä¹‹æ±Ÿ. è‡ªåŠ¨é©¾é©¶è½¦è¾†è¿åŠ¨è§„åˆ’æ–¹æ³•ç»¼è¿°[J]ï¼šæ§åˆ¶ä¸ä¿¡æ¯æŠ€æœ¯ï¼Œ2018(6)ï¼š1-6. [2] é³å²šï¼Œèµµè‰ï¼Œè°¢é»æ˜ï¼åŸºäºä¸‰æ¬¡Bezierä¸‰è§’æ ·æ¡æ’å€¼çš„å·¥ä¸šæœºå™¨äººè¿ç»­è·¯å¾„è½¨è¿¹è§„åˆ’[J]. æœºæ¢°è®¾è®¡ä¸åˆ¶é€ å·¥ç¨‹,2019,48(4)ï¼š35-39. [3] æœå“æ´‹ï¼Œæ— äººé©¾é©¶è½¦è¾†è½¨è¿¹è§„åˆ’ç®—æ³•ç ”ç©¶[D]. æ­å·ï¼šæµ™æ±Ÿå¤§å­¦ï¼Œ2019. [4] åˆ›å®¢æ™ºé€ . autoware å…¥é—¨æ•™ç¨‹ä¸€ä½¿ç”¨rosbagæ•°æ®ç”Ÿæˆè·¯å¾„ç‚¹[DB/OLJ.[2020-04-11].https://www.ncnynl.com/archives/201910/3413.html. [5] åˆ›å®¢æ™ºé€ . autoware å…¥é—¨æ•™ç¨‹ä¸€ä½¿ç”¨rosbagæ•°æ®è¿›è¡Œè·¯å¾„è§„åˆ’[DB/OL].[2020-04-11].https://www.ncnynl.com/archives/201910/3414.html. [6] ä½•æ­¦. å®¤å†…æœåŠ¡æœºå™¨äººçš„å¯¼èˆªç ”ç©¶[D]. åˆè‚¥ï¼šä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦,2011. [7] é‚“é¹ï¼Œå¼ æ­ï¼Œç”³æœ‰å‰ï¼åŸºäºæ”¹è¿› Dijkstra ç®—æ³•åœ¨æ™ºèƒ½å¯¼èˆªä¸­çš„åº”ç”¨[J]. æ–°å‹å·¥ä¸šåŒ–ï¼Œ2019,9 (12) : 91-95. [8] é¡¾é’ï¼Œè±†é£é“…ï¼Œé©¬é£. åŸºäºæ”¹è¿›A*ç®—æ³•çš„ç”µåŠ¨è½¦èƒ½è€—æœ€ä¼˜è·¯å¾„è§„åˆ’[J]. å†œä¸šæœºæ¢°å­¦æŠ¥ï¼Œ2013,46 (12): 321-327. [9] å¾ç£Š. åŸºäº EPS çš„è‡ªåŠ¨æ³Šè½¦è·¯å¾„è§„åˆ’åŠè·Ÿç»¼æ§åˆ¶ç ”ç©¶[D]. åˆè‚¥ï¼šåˆè‚¥å·¥ä¸šå¤§å­¦,2017. äº”ã€Autoware æ§åˆ¶æ¨¡å—è§£æâ€‹ Autowareæ§åˆ¶æ¨¡å—çš„ä¸»è¦ä½œç”¨ä¸ºè·å–è½¦è¾†è·¯å¾„è§„åˆ’çš„ç»“æœï¼Œåœ¨è½¦è¾†è¿åŠ¨å­¦å’ŒåŠ¨åŠ›å­¦çº¦æŸä¸‹è®¡ç®—ç›¸åº”çš„æ§åˆ¶æŒ‡ä»¤ï¼ŒåŒ…æ‹¬é€Ÿåº¦è§’é€Ÿåº¦ç­‰ï¼Œæ¥ç€å‘å¸ƒæ§åˆ¶æŒ‡ä»¤åˆ°è½¦è¾†åº•ç›˜æ‰§è¡Œã€‚ â€‹ åœ¨å½“å‰åœºæ™¯ä¸‹ä¸»è¦è®²è§£çº¯è·Ÿè¸ªæ§åˆ¶ç®—æ³•ã€‚ 5.1 èŠ‚ç‚¹pure_pursuitâ€‹ èŠ‚ç‚¹pure_pursuitä¸»è¦ä½œç”¨ï¼šæ¥æ”¶velocity_setèŠ‚ç‚¹å‘å¸ƒçš„â€œfinal_waypointsâ€ï¼Œè®¡ç®—è‡ªè½¦ä¸‹ä¸€æ—¶åˆ»çš„é€Ÿåº¦ã€è§’é€Ÿåº¦æŒ‡ä»¤å¹¶å‘å¸ƒâ€œtwist_rawâ€è¯é¢˜ 5.1.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch pure_pursuit pure_pursuit.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹computing é€‰é¡¹å¡ -&gt; motion_planner -&gt;waypoint_follower-&gt;pure_pursuitï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 5.1.2 ç¨‹åºè·¯å¾„1src/autoware/core_planning/pure_pursuit 5.1.3 å‚æ•°è¯¦æƒ… å‚æ•°å ç±»å‹ è¯´æ˜ lookahead_ratio double é¢„ç„è·ç¦»ç³»æ•° minimum_lookahead_distance double æœ€å°é¢„ç„è·ç¦» 5.1.4 ä»£ç æ³¨è§£â‘  mainå‡½æ•°â€‹ mainå‡½æ•°åœ¨pure_pursuit_node.cppä¸­ï¼Œä¸»è¦åŠŸèƒ½ä¸ºåˆ›å»ºPurePursuitNodeå¯¹è±¡çš„å®ä¾‹ppnï¼Œppnçš„æ„é€ å‡½æ•°é‡Œé…ç½®ç›¸å…³å‚æ•°ï¼Œç¡®å®šç›¸å…³è®¢é˜…è€…å’Œå‘å¸ƒè€…ï¼Œppn.runå‡½æ•°å®ç°ä¸»è¦åŠŸèƒ½ã€‚ 123456789#include &lt;pure_pursuit/pure_pursuit_core.h&gt;int main(int argc, char** argv){ ros::init(argc, argv, &quot;pure_pursuit&quot;); waypoint_follower::PurePursuitNode ppn; ppn.run(); return 0;} â‘¡ runå‡½æ•°â€‹ å‡½æ•°é¦–å…ˆæ£€æµ‹èŠ‚ç‚¹æ‰€éœ€æ¶ˆæ¯è¾“å…¥æ˜¯å¦æ­£å¸¸æ¥æ”¶ï¼ŒIfå‡½æ•°ä¸­çš„åˆ¤æ–­æ¡ä»¶æ—¶å›è°ƒå‡½æ•°ä¸­çš„æ˜¯å¦æˆåŠŸæ¥æ”¶æ¶ˆæ¯çš„æ ‡å¿—ï¼Œåœ¨è¿™é‡Œè¦æ±‚ä¸‰ä¸ªæ ‡å¿—å¿…é¡»ä¸ºtrueç¨‹åºæ‰èƒ½ç»§ç»­å¾€ä¸‹è¿›è¡Œï¼Œå¦åˆ™æç¤ºå¿…è¦çš„è¯é¢˜æ²¡æœ‰æ¥æ”¶æˆåŠŸï¼Œå¹¶åœ¨æ­¤ç­‰å¾…ã€‚ifå‡½æ•°å¯¹çº¯è·Ÿè¸ªèŠ‚ç‚¹çš„è¿è¡Œæ¡ä»¶åšäº†ç­›æŸ¥ï¼Œä»¥ç¡®ä¿è¾“å…¥æ­£ç¡®ã€‚ â€‹ æ¥ç€é€šè¿‡setLookaheadDistanceå‡½æ•°å¯¹é¢„ç„è·ç¦»lookahead_distance_è¿›è¡Œè®¾ç½®ï¼Œå…¶å€¼æ ¹æ®computeLookaheadDistanceå‡½æ•°è·å¾—ã€‚ â€‹ éšåè°ƒç”¨canGetCurvatureå‡½æ•°å¯»æ‰¾ä¸‹ä¸€ç›®æ ‡ç‚¹ä¸å½“å‰ä½ç½®æ˜¯å¦å¯ä»¥å¾—åˆ°åˆç†è¿åŠ¨æ›²çº¿å¹¶è®¡ç®—å‡ºç›¸åº”çš„æ›²ç‡ã€‚ â€‹ æœ€ç»ˆæŠŠå¾—åˆ°çš„æ›²ç‡è®¡ç®—å‡ºç›¸åº”çš„æŒ‡ä»¤å‘å¸ƒå‡ºå»ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void PurePursuitNode::run(){ ros::Rate loop_rate(update_rate_); while (ros::ok()) { ros::spinOnce(); //åˆ¤æ–­æ¶ˆæ¯æ˜¯å¦æ­£å¸¸æ¥æ”¶ if (!is_pose_set_ || !is_waypoint_set_ || !is_velocity_set_) { if (!is_pose_set_) { ROS_WARN_THROTTLE(5, &quot;Waiting for current_pose topic ...&quot;); } if (!is_waypoint_set_) { ROS_WARN_THROTTLE(5, &quot;Waiting for final_waypoints topic ...&quot;); } if (!is_velocity_set_) { ROS_WARN_THROTTLE(5, &quot;Waiting for current_velocity topic ...&quot;); } loop_rate.sleep(); continue; } //è®¾ç½®é¢„ç„è·ç¦» pp_.setLookaheadDistance(computeLookaheadDistance()); pp_.setMinimumLookaheadDistance(minimum_lookahead_distance_); //å¯»æ‰¾ä¸‹ä¸€ç›®æ ‡ç‚¹å¹¶è®¡ç®—æ›²ç‡åˆ¤æ–­æ˜¯å¦æ˜¯æœ‰æ•ˆæ›²çº¿ double kappa = 0; bool can_get_curvature = pp_.canGetCurvature(&amp;kappa); //å‘å¸ƒæ§åˆ¶å‘½ä»¤ publishControlCommands(can_get_curvature, kappa); health_checker_ptr_-&gt;NODE_ACTIVATE(); health_checker_ptr_-&gt;CHECK_RATE(&quot;topic_rate_vehicle_cmd_slow&quot;, 8, 5, 1, &quot;topic vehicle_cmd publish rate slow.&quot;); // Rvizä¸­å¯è§†åŒ– pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint())); pub13_.publish(displaySearchRadius(pp_.getCurrentPose().position, pp_.getLookaheadDistance())); pub12_.publish(displayNextTarget(pp_.getPoseOfNextTarget())); pub15_.publish(displayTrajectoryCircle( waypoint_follower::generateTrajectoryCircle(pp_.getPoseOfNextTarget(), pp_.getCurrentPose()))); if (add_virtual_end_waypoints_) { pub18_.publish(displayExpandWaypoints(pp_.getCurrentWaypoints(), expand_size_)); } std_msgs::Float32 angular_gravity_msg; //è®¡ç®—æ¨ªå‘åŠ é€Ÿå¹¶å‘å¸ƒ angular_gravity_msg.data = computeAngularGravity(computeCommandVelocity(), kappa); pub16_.publish(angular_gravity_msg); //è®¡ç®—è‡ªè½¦ä¸è·Ÿè¸ªè·¯å¾„æ›²çº¿çš„æ¨ªå‘è¯¯å·® publishDeviationCurrentPosition(pp_.getCurrentPose().position, pp_.getCurrentWaypoints()); is_pose_set_ = false; is_velocity_set_ = false; loop_rate.sleep(); }} â‘¢ computeLookaheadDistanceå‡½æ•°â€‹ computeLookaheadDistanceå‡½æ•°åˆ©ç”¨è½¦é€Ÿçš„å€æ•°ä½œä¸ºé¢„ç„è·ç¦»ï¼Œé€Ÿåº¦è¶Šå¤§é¢„ç„è·ç¦»è¶Šè¿œï¼Œé€Ÿåº¦è¶Šå°é¢„ç„å‡†è·ç¦»è¶Šè¿‘ã€‚åœ¨æœ€å°é¢„ç„è·ç¦»ï¼Œå‚è€ƒå€¼ï¼Œæœ€å¤§é¢„ç„è·ç¦»ä¸­çš„ä¸­é—´å€¼ä½œä¸ºè¿”å›å€¼ã€‚ 12345678910111213double PurePursuitNode::computeLookaheadDistance() const{ if (velocity_source_ == enumToInteger(Mode::dialog)) { return const_lookahead_distance_; } const double maximum_lookahead_distance = current_linear_velocity_ * 10; const double ld = current_linear_velocity_ * lookahead_distance_ratio_; return ld &lt; minimum_lookahead_distance_ ? minimum_lookahead_distance_ : ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance : ld;} â‘£ canGetCurvatureå‡½æ•°123456789101112131415161718192021222324252627282930313233343536373839404142434445bool PurePursuit::canGetCurvature(double* output_kappa){ // å¯»æ‰¾ä¸‹ä¸€ä¸ªè·Ÿè¸ªè·¯å¾„ç‚¹ getNextWaypoint(); if (next_waypoint_number_ == -1) { ROS_INFO(&quot;lost next waypoint&quot;); return false; } // éå†è·¯å¾„ç‚¹åºåˆ—ä¸­çš„æ¯ä¸€ä¸ªç‚¹åˆ°å½“å‰ä½ç½®çš„è·ç¦»æ˜¯å¦å¤§äºé¢„ç„è·ç¦»ä»è€Œåˆ¤æ–­æ›²çº¿æ˜¯å¦åˆç† bool is_valid_curve = false; for (const auto&amp; el : current_waypoints_) { if (getPlaneDistance(el.pose.pose.position, current_pose_.position) &gt; minimum_lookahead_distance_) { is_valid_curve = true; break; } } if (!is_valid_curve) { return false; } // æ£€æŸ¥æ˜¯å¦æ˜¯ç¬¬ä¸€ä¸ªç‚¹ã€æœ€åä¸€ä¸ªç‚¹æˆ–è€…ä¸èƒ½çº¿æ€§æ’å€¼çš„æƒ…å†µ if (!is_linear_interpolation_ || next_waypoint_number_ == 0 || next_waypoint_number_ == (static_cast&lt;int&gt;(current_waypoints_.size() - 1))) { next_target_position_ = current_waypoints_.at(next_waypoint_number_).pose.pose.position; *output_kappa = calcCurvature(next_target_position_); return true; } // çº¿æ€§æ’å€¼ const bool interpolation = interpolateNextTarget(next_waypoint_number_, &amp;next_target_position_); if (!interpolation) { ROS_INFO(&quot;lost target!&quot;); return false; } //è®¡ç®—æ›²ç‡ *output_kappa = calcCurvature(next_target_position_); return true;} â‘¤ calcCurvatureå‡½æ•° 1234567891011121314151617double PurePursuit::calcCurvature(const geometry_msgs::Point&amp; target) const{ double kappa; const geometry_msgs::Point pt = calcRelativeCoordinate(target, current_pose_); const double denominator = pt.x * pt.x + pt.y * pt.y; const double numerator = 2.0 * pt.y; if (denominator != 0.0) { kappa = numerator / denominator; } else { kappa = numerator &gt; 0.0 ? KAPPA_MIN_ : -KAPPA_MIN_; } return kappa;} â‘¥ publishTwistStampedå‡½æ•°â€‹ publishTwistStampedå‡½æ•°ç”¨æ¥å‘å¸ƒtwist_cmdè¯é¢˜ï¼Œå‘å¸ƒæ¶ˆæ¯ä¸»è¦åŒ…å«çº¿é€Ÿåº¦ï¼ˆlinear.x)å’Œè§’é€Ÿåº¦ï¼ˆangular.zï¼‰ï¼Œå…¶å€¼åˆ†åˆ«ä¸ºcomputeCommandVelocityå‡½æ•°çš„ç»“æœå’Œæ›²ç‡ä¸é€Ÿåº¦çš„ä¹˜ç§¯ã€‚ 123456789101112131415161718void PurePursuitNode::publishTwistStamped(const bool&amp; can_get_curvature, const double&amp; kappa) const{ geometry_msgs::TwistStamped ts; ts.header.stamp = ros::Time::now(); //è®¡ç®—é€Ÿåº¦å’Œè§’é€Ÿåº¦çš„å€¼ ts.twist.linear.x = can_get_curvature ? computeCommandVelocity() : 0; ts.twist.angular.z = can_get_curvature ? kappa * ts.twist.linear.x : 0; pub1_.publish(ts);}double PurePursuitNode::computeCommandVelocity() const{ if (velocity_source_ == enumToInteger(Mode::dialog)) { return getSgn() * kmph2mps(const_velocity_); } return command_linear_velocity_;} 5.2 èŠ‚ç‚¹twist_filterâ€‹ èŠ‚ç‚¹twist_filterçš„ä¸»è¦ä½œç”¨ï¼šå¯¹pure_pursuitèŠ‚ç‚¹å‘å¸ƒçš„é€Ÿåº¦è¿›è¡Œæ»¤æ³¢å¤„ç†ã€‚ 5.2.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: roslaunch twist_filter twist_filter.launch ä»Runtime Managerå¯åŠ¨: â€‹ æ‰“å¼€Runtime Managerï¼Œä¸Šæ–¹computing é€‰é¡¹å¡ -&gt; motion_planner -&gt;waypoint_follower-&gt;twist_filterï¼Œå•å‡» [app] æŒ‰é’®å¯æ›´æ”¹è®¾ç½®ç­‰å‚æ•°ã€‚ 5.2.2 ç¨‹åºè·¯å¾„1src/autoware/core_planning/twist_filter 5.2.3 ä»£ç æ³¨è§£â‘  mainå‡½æ•°â€‹ mainå‡½æ•°åœ¨twist_filter_node.cppä¸­,ä¸»è¦ä½œç”¨ä¸ºæ„é€ TwistFilterNodeå¯¹è±¡nodeã€‚ 1234567int main(int argc, char** argv){ ros::init(argc, argv, &quot;twist_filter&quot;); twist_filter_node::TwistFilterNode node; ros::spin(); return 0;} â‘¡ TwistFilterNodeæ„é€ å‡½æ•°1234567891011121314151617TwistFilterNode::TwistFilterNode() : nh_(), pnh_(&quot;~&quot;), health_checker_(nh_, pnh_){ // è®¾ç½®å‚æ•° twist_filter::Configuration twist_filter_config; nh_.param(&quot;vehicle_info/wheel_base&quot;, twist_filter_config.wheel_base, 2.7); //...(ä¸‹ç•¥) // è®¢é˜…è€… twist_sub_ = nh_.subscribe(&quot;twist_raw&quot;, 1, &amp;TwistFilterNode::twistCmdCallback, this); //...(ä¸‹ç•¥) // å‘å¸ƒè€… twist_pub_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;twist_cmd&quot;, 5); ctrl_pub_ = nh_.advertise&lt;autoware_msgs::ControlCommandStamped&gt;(&quot;ctrl_cmd&quot;, 5); //...(ä¸‹ç•¥)} â‘¢ twistCmdCallbackå‡½æ•°â€‹ æ¥æ”¶çš„æ¶ˆæ¯åŒ…å«é€Ÿåº¦vå’Œè§’é€Ÿåº¦Omega,æ ¹æ®vå’ŒOmegaè¿›è¡Œæ¨ªå‘åŠ é€Ÿåº¦çš„çº¦æŸé™åˆ¶ï¼Œæ¥ç€å¯¹è¾“å‡ºçš„é€Ÿåº¦å’Œè§’é€Ÿåº¦è¿›è¡Œä¸€é˜¶ä½é€šæ»¤æ³¢å¤„ç†å¹¶å‘å¸ƒã€‚ 123456789101112131415161718192021222324252627282930313233343536void TwistFilterNode::twistCmdCallback(const geometry_msgs::TwistStampedConstPtr&amp; msg){ const twist_filter::Twist twist = { msg-&gt;twist.linear.x, msg-&gt;twist.angular.z }; ros::Time current_time = ros::Time::now(); static ros::Time last_callback_time = current_time; static twist_filter::Twist twist_prev = twist; double time_elapsed = (current_time - last_callback_time).toSec(); health_checker_.NODE_ACTIVATE(); checkTwist(twist, twist_prev, time_elapsed); twist_filter::Twist twist_out = twist; // æ¨ªå‘åŠ é€Ÿåº¦é™åˆ¶ auto twist_limit_result = twist_filter_ptr_-&gt;lateralLimitTwist(twist, twist_prev, time_elapsed); if (twist_limit_result) { twist_out = twist_limit_result.get(); } //...(ä¸‹ç•¥) if (enable_smoothing_) { // å¹³æ»‘å¤„ç† twist_out = twist_filter_ptr_-&gt;smoothTwist(twist_out); } // å‘å¸ƒæ»¤æ³¢åçš„twistæŒ‡ä»¤ geometry_msgs::TwistStamped out_msg = *msg; out_msg.twist.linear.x = twist_out.lx; out_msg.twist.angular.z = twist_out.az; twist_pub_.publish(out_msg); //...(ä¸‹ç•¥) // è®°å½•å½“å‰æŒ‡ä»¤å’Œæ—¶é—´ twist_prev = twist_out; last_callback_time = current_time;} 5.3 èŠ‚ç‚¹listener_car_driveâ€‹ listener_car_driveèŠ‚ç‚¹ä¸»è¦ä½œç”¨ï¼šå°†Autowareå‘å¸ƒçš„é€Ÿåº¦ä¿¡æ¯å‘é€ç»™åº•ç›˜å•ç‰‡æœºï¼Œæ§åˆ¶åº•ç›˜è¿åŠ¨ã€‚ 5.3.1 å¯åŠ¨æ–¹æ³• ç»ˆç«¯å¯åŠ¨: python3 listener_car_drive.py 5.3.2 ç¨‹åºè·¯å¾„1~/car_av/listener_car_drive.py 5.3. é€šä¿¡åè®®â€‹ ç”µè„‘ä¸åº•ç›˜é€šä¿¡æ—¶ï¼Œç”µè„‘ä¸Šä½æœºå‘é€14ä½16è¿›åˆ¶æ•°æ®ã€‚ â€‹ å¸§å¤´ä¸ºa5 11 01ï¼Œå¸§å°¾ä¸º0d 0aï¼Œç¬¬10ä½ä¸ºæ§åˆ¶ä½ï¼Œ01ä¸ºåˆ¹è½¦ï¼Œ02ä¸ºå‰è¿›ï¼Œ03ä¸ºç”µæœºåˆå§‹åŒ–ã€‚ç¬¬11ã€12ä½ä¸ºæ ¡éªŒä½ï¼Œé‡‡ç”¨crc16æ ¡éªŒã€‚ 1'a5 11 01 ' + speed_direction + speed + angle_direction + angle + '02' + check_1 + check_2 + ' 0d 0a' â‘  é€Ÿåº¦æ–¹å‘æ§åˆ¶â€‹ é€Ÿåº¦æ–¹å‘æ§åˆ¶speed_directionä»£è¡¨çº¿é€Ÿåº¦æ–¹å‘ï¼Œ01ä¸ºå‰è¿›ï¼Œ00ä¸ºåé€€ã€‚å…±1ä½ã€‚ â‘¡ é€Ÿåº¦æ§åˆ¶â€‹ é€Ÿåº¦æ§åˆ¶speedä»£è¡¨çº¿é€Ÿåº¦(è½¦é€Ÿ)ï¼ŒåŸå§‹å•ä½ä¸ºm/sï¼Œæ­¤å¤„å°†ç”µè„‘æ§åˆ¶ç«¯å‘é€çš„é€Ÿåº¦å€¼ä¹˜ä»¥100ï¼Œä¾¿äºå•ç‰‡æœºä»¥intå½¢å¼æ¥æ”¶ã€‚å…±ä¸¤ä½ã€‚ â‘¢ è§’é€Ÿåº¦æ–¹å‘æ§åˆ¶â€‹ è§’é€Ÿåº¦æ–¹å‘æ§åˆ¶angle_directionä»£è¡¨è§’é€Ÿåº¦æ–¹å‘ï¼Œ01ä¸ºæ­£å‘ï¼Œ00ä¸ºåå‘ã€‚å…±1ä½ã€‚ â‘£è§’é€Ÿåº¦æ§åˆ¶â€‹ è§’é€Ÿåº¦æ§åˆ¶angleä»£è¡¨è½¦è¾†è§’é€Ÿåº¦ï¼ŒåŸå§‹å•ä½ä¸ºrad/s,æ­¤å¤„å°†ç”µè„‘æ§åˆ¶ç«¯å‘é€çš„è§’é€Ÿåº¦å€¼ä¹˜ä»¥100ï¼Œä¾¿äºå•ç‰‡æœºä»¥intå½¢å¼æ¥æ”¶ã€‚å…±ä¸¤ä½ã€‚ é€šä¿¡åè®®demoï¼š 1a5 11 01 01 1f ff 01 0f ff 02 check_1 check_2 0d 0a 5.3.3 ä»£ç æ³¨è§£â‘  mainå‡½æ•°â€‹ mainå‡½æ•°å¯åŠ¨äº†ä¸‰ä¸ªç‹¬ç«‹çš„çº¿ç¨‹æ¥æ¥æ”¶è½¬æ¢è¿‡çš„æ§åˆ¶å‘½ä»¤ã€è·å–è½¦è¾†é€Ÿåº¦ã€å°†é€Ÿåº¦å‘é€ç»™åº•ç›˜å•ç‰‡æœºæ§åˆ¶çº¿æ§åº•ç›˜è¿åŠ¨ã€‚ 123456789101112if __name__ == '__main__': rosrun_start = Thread(target=start_rosrun) speed_angle = Thread(target=get_value) car = Thread(target=car_control) rosrun_start.start() speed_angle.start() car.start() rosrun_start.join() speed_angle.join() car.join() â‘¡ start_rosrunå‡½æ•°â€‹ start_rosrunå‡½æ•°ç›¸å½“äºåœ¨ç»ˆç«¯å¯åŠ¨äº†rosrun vehicle_ctl vehicle_cmd_å‘½ä»¤æ¥è½¬æ¢é€Ÿåº¦æ¶ˆæ¯ã€‚ 123# å¯åŠ¨æ§åˆ¶å‘½ä»¤è½¬æ¢èŠ‚ç‚¹def start_rosrun(): os.system('rosrun vehicle_ctl vehicle_cmd_') â‘¢ get_valueå‡½æ•°â€‹ get_valueå‡½æ•°åˆå§‹åŒ–äº†rosèŠ‚ç‚¹ï¼Œå¹¶å®šä¹‰äº†callbackå›è°ƒå‡½æ•°æ¥æ”¶è½¦è¾†é€Ÿåº¦åŠè§’é€Ÿåº¦ä¿¡æ¯ã€‚ 12345678910111213141516def get_value(): global break_f time.sleep(0.5) def callback(data): global angle global speed global break_f value = data.v_cmd speed = value[0] speed = round(float(speed), 4) angle = value[1] angle = round(float(angle), 4) rospy.init_node('listener', anonymous=True, disable_signals=True) rospy.Subscriber('speed_pub', cmd, callback) rospy.spin() â‘£ car_controlå‡½æ•°â€‹ car_controlå‡½æ•°æ‰“å¼€åä¸º/dev/carçš„ä¸²å£ï¼Œå°†é€Ÿåº¦ã€è§’é€Ÿåº¦ä¿¡æ¯å‘é€ç»™çº¿æ§åº•ç›˜å•ç‰‡æœºï¼Œæ§åˆ¶è½¦è¾†è¿åŠ¨ã€‚ 12345678910111213141516171819def car_control(): global speed global angle global break_f ser = car_drive() # æ‰“å¼€ä¸²å£ ret = ser.open_car('/dev/car', 115200) # åˆ¤æ–­ä¸²å£æ˜¯å¦æ‰“å¼€ï¼Œå½“ä¸²å£æˆåŠŸæ‰“å¼€ï¼Œåˆ™å°†æ¥æ”¶åˆ°Autowareåé¦ˆçš„é€Ÿåº¦ä¿¡æ¯å‘é€ç»™ä¸²å£ if ret == 1: while True: print('é€Ÿåº¦=', speed) print('è§’é€Ÿåº¦=', angle) if break_f == 0: ret = ser.write_car(run(speed, angle)) if ret == 1: print('write ok') else: print('write error') time.sleep(0.033) 5.4 å‚è€ƒæ–‡çŒ® [1] é¾šå»ºä¼Ÿï¼Œå§œå²©ï¼Œå¾å¨. æ— äººé©¾é©¶è½¦è¾†æ¨¡å‹é¢„æµ‹æ§åˆ¶[M]ï¼ŒåŒ—äº¬ï¼šåŒ—äº¬ç†å·¥å¤§å­¦å‡ºç‰ˆç¤¾ï¼Œ2014. [2] ç”°å¤§æ–°,æ®µç»­åº­ç­‰. Autowareä¸è‡ªåŠ¨é©¾é©¶æŠ€æœ¯ï¼ŒåŒ—äº¬ï¼šç§‘å­¦å‡ºç‰ˆç¤¾ï¼Œ2020. [3] Jarrod M S. Automatic steering methods for autonomous automobile path tracking[R]. Pittsburgh: Catnegie Mellon University, 2009. [4] é™ˆå®ï¼Œå‘¨å¿—å³°ï¼Œç‹æ°¸æ³‰ï¼Œç­‰. ä¸€ç§çº¯è¿½è¸ªæ¨¡å‹æ”¹è¿›ç®—æ³•. è½»å·¥æœºæ¢°[J] ,2014,32(4):69-72. [5] éŸ©äºšå¥‡. é«˜é€Ÿå…¬è·¯ç¯å¢ƒä¸­æ™ºèƒ½è½¦è¾†è·¯å¾„è§„åˆ’ä¸è·Ÿè¸ª[D]. å—å®ï¼šå¹¿è¥¿å¤§å­¦ï¼Œ2019. [6] ShinpeiKato.Autoware_TierIV_Academy_v1.1[DB/OLJ.[2020-04-22]]. https://github.com/CPFL/Autoware-Manuals/blob/master/en/Autoware_TierIV_Academy_v1.1.pdf.","link":"/posts/15d39967/"},{"title":"ã€è®ºæ–‡é˜…è¯»ã€‘æ¸…å&amp;ç†æƒ³æ±½è½¦ DriveVLM :è‡ªåŠ¨é©¾é©¶ä¸VLMå¤§æ¨¡å‹çš„èåˆ","text":"1ã€èƒŒæ™¯ä¸æ–¹æ³•ç®€ä»‹æ¸…åå¤§å­¦äº¤å‰ä¿¡æ¯é™¢èµµè¡Œè€å¸ˆç ”ç©¶ç»„MARS Labä¸ç†æƒ³æ±½è½¦åˆä½œï¼Œæå‡ºäº†ä¸€ç§åŸºäºå¤§æ¨¡å‹çš„é«˜é˜¶è‡ªåŠ¨é©¾é©¶çš„å…¨æ–°æ–¹æ¡ˆDriveVLMã€‚DriveVLMä»¥è§†è§‰è¯­è¨€å¤§æ¨¡å‹ä¸ºåŸºç¡€ï¼Œå¹¶ä¸ç«¯åˆ°ç«¯æ¨¡å‹å®ç°åŒç³»ç»Ÿï¼Œåœ¨å¤æ‚å’Œé©¾é©¶åœºæ™¯ä¸­è¡¨ç°å‡ºè‰²ã€‚æ¨¡å‹åœ¨ç†æƒ³Megaä¸Šéƒ¨ç½²è¿è¡Œï¼Œæ˜¯é¦–ä¸ªéƒ¨ç½²ä¸Šè½¦çš„è‡ªåŠ¨é©¾é©¶å¤§æ¨¡å‹ã€‚ åŸå¸‚ç¯å¢ƒä¸­è‡ªåŠ¨é©¾é©¶çš„ä¸»è¦éšœç¢æ˜¯ç†è§£å¤æ‚çš„ Long-tail åœºæ™¯ï¼Œä¾‹å¦‚å…·æœ‰æŒ‘æˆ˜æ€§çš„é“è·¯æ¡ä»¶å’Œå¾®å¦™çš„äººç±»è¡Œä¸ºã€‚DriveVLM é›†æˆäº†ç”¨äºåœºæ™¯æè¿°ã€åœºæ™¯åˆ†æå’Œåˆ†å±‚è§„åˆ’çš„æ¨ç†æ¨¡å—çš„ç‹¬ç‰¹ç»„åˆã€‚æ­¤å¤–ï¼Œè®¤è¯†åˆ° VLM åœ¨ç©ºé—´æ¨ç†å’Œç¹é‡è®¡ç®—è¦æ±‚æ–¹é¢çš„å±€é™æ€§ï¼Œæå‡ºä¸€ç§æ··åˆç³»ç»Ÿ DriveVLM-Dualï¼Œå¯é€‰æ‹©å°† DriveVLM ä¸ä¼ ç»Ÿ 3D æ„ŸçŸ¥å’Œè§„åˆ’æ¨¡å—é›†æˆï¼Œä¾‹å¦‚ 3D ç‰©ä½“æ£€æµ‹å™¨ã€å ç”¨ç½‘ç»œå’Œè¿åŠ¨è§„åˆ’å™¨ï¼Œä½¿ç³»ç»Ÿèƒ½å¤Ÿå®ç° 3D æ¥åœ°å’Œé«˜é¢‘è§„åˆ’èƒ½åŠ›ã€‚è¿™ç§åŒç³»ç»Ÿè®¾è®¡ç±»ä¼¼äºäººè„‘çš„æ…¢é€Ÿå’Œå¿«é€Ÿæ€ç»´è¿‡ç¨‹ï¼Œå¯ä»¥æœ‰æ•ˆåœ°é€‚åº”é©¾é©¶åœºæ™¯ä¸­ä¸åŒçš„å¤æ‚æ€§ã€‚ åœ¨ nuScenes æ•°æ®é›†å’Œ SUP-AD æ•°æ®é›†ä¸Šçš„å®éªŒè¯æ˜äº† DriveVLM å’Œ DriveVLM-Dual åœ¨å¤„ç†å¤æ‚ä¸”ä¸å¯é¢„æµ‹çš„é©¾é©¶æ¡ä»¶æ–¹é¢çš„åŠŸæ•ˆã€‚æœ€åï¼Œå°† DriveVLM-Dual éƒ¨ç½²åœ¨é‡äº§è½¦è¾†ä¸Šï¼ŒéªŒè¯å…¶åœ¨ç°å®è‡ªåŠ¨é©¾é©¶ç¯å¢ƒä¸­çš„æœ‰æ•ˆæ€§ã€‚ 2ã€DriveVLMå®ç°DriveVLM çš„æ•´ä½“æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚å›¾åƒåºåˆ—ç”±è§†è§‰è¯­è¨€æ¨¡å‹ï¼ˆVLMï¼‰å¤„ç†ï¼Œä»¥æ‰§è¡Œç‰¹æ®Šçš„æ€æƒ³é“¾ï¼ˆCoTï¼‰æ¨ç†ï¼Œä»è€Œå¾—å‡ºé©¾é©¶è§„åˆ’ç»“æœã€‚ DriveVLM çš„æ¶æ„æ¶‰åŠè§†è§‰è½¬æ¢å™¨ç¼–ç å™¨å’Œå¤§å‹è¯­è¨€æ¨¡å‹ ( LLM )ã€‚è§†è§‰ç¼–ç å™¨äº§ç”Ÿå›¾åƒæ ‡è®°ï¼›ç„¶ååŸºäºæ³¨æ„åŠ›çš„æå–å™¨å°†è¿™äº›æ ‡è®°ä¸LLMå¯¹é½ã€‚æ¨ç†è¿‡ç¨‹å¯ä»¥åˆ†ä¸ºä¸‰ä¸ªæ¨¡å—ï¼šåœºæ™¯æè¿°ã€åœºæ™¯åˆ†æå’Œåˆ†å±‚è·¯å¾„è§„åˆ’ï¼ˆHierarchical Planningï¼‰ã€‚è€Œ DriveVLM-Dual è¿›ä¸€æ­¥èåˆäº†ä¼ ç»Ÿçš„3Dæ„ŸçŸ¥å’Œè½¨è¿¹è§„åˆ’æ¨¡å—ï¼Œå®ç°ç©ºé—´æ¨ç†èƒ½åŠ›å’Œå®æ—¶è½¨è¿¹è§„åˆ’ã€‚ 2.1ã€Scene Descriptionåœºæ™¯æè¿°æ¨¡å—ç”¨äºè¯†åˆ«é©¾é©¶ç¯å¢ƒå’Œå…³é”®å¯¹è±¡ã€‚ 1ã€ç¯å¢ƒæè¿°ã€‚ å¤©æ°”ã€è·¯å†µç­‰é©¾é©¶ç¯å¢ƒå¯¹é©¾é©¶éš¾åº¦çš„å½±å“æ¯”è¾ƒå¤§ã€‚å› æ­¤ï¼Œæ¨¡å‹é¦–å…ˆæè¿°é©¾é©¶ç¯å¢ƒ E ï¼ŒåŒ…æ‹¬å‡ ä¸ªæ¡ä»¶ï¼š å…¶ä¸­ï¼ŒWeather æ¶µç›–ä»æ™´å¤©åˆ°ä¸‹é›ªçš„å„ç§æ¡ä»¶ï¼Œå½±å“èƒ½è§åº¦å’Œç‰µå¼•åŠ›ã€‚Time åŒºåˆ†ç™½å¤©å’Œå¤œé—´ï¼Œå› èƒ½è§åº¦å˜åŒ–è€Œå½±å“é©¾é©¶ç­–ç•¥ã€‚Road ï¼Œé“è·¯ç±»å‹ï¼Œä¾‹å¦‚åŸå¸‚æˆ–é«˜é€Ÿå…¬è·¯ï¼Œæ ¹æ®é“è·¯ç±»å‹é€‰æ‹©ä¸åŒé©¾é©¶ç­–ç•¥ã€‚Laneï¼Œè½¦é“æ¡ä»¶ï¼Œå…³æ³¨å½“å‰è½¦é“å®šä½å’Œå¯èƒ½çš„æ“ä½œï¼Œè¿™å¯¹äºå®‰å…¨é©¾é©¶å†³ç­–è‡³å…³é‡è¦ã€‚ 2ã€å…³é”®å¯¹è±¡è¯†åˆ«ã€‚ é™¤äº†ç¯å¢ƒæ¡ä»¶å¤–ï¼Œè‡ªåŠ¨é©¾é©¶åœºæ™¯ä¸­çš„å„ç§ç‰©ä½“ä¹Ÿä¼šæ˜¾è‘—å½±å“é©¾é©¶è¡Œä¸ºã€‚ ä¸ä¼ ç»Ÿçš„è‡ªåŠ¨é©¾é©¶æ„ŸçŸ¥æ¨¡å—æ£€æµ‹ç‰¹å®šèŒƒå›´å†…çš„æ‰€æœ‰ç‰©ä½“ä¸åŒï¼Œä½œè€…å—åˆ°äººç±»é©¾é©¶è¿‡ç¨‹ä¸­è®¤çŸ¥è¿‡ç¨‹çš„å¯å‘ï¼Œåªä¸“æ³¨äºè¯†åˆ«æœ€æœ‰å¯èƒ½å½±å“å½“å‰åœºæ™¯çš„å…³é”®ç‰©ä½“ã€‚ æ¯ä¸ªå…³é”®å¯¹è±¡ï¼Œè¡¨ç¤ºä¸º Oc ï¼ŒåŒ…å«ä¸¤ä¸ªå±æ€§ï¼šå¯¹è±¡ç±»åˆ« c åŠå…¶å›¾åƒä¸Šçš„è¿‘ä¼¼è¾¹ç•Œæ¡†åæ ‡ bâ¢(xâ¢1,yâ¢1,xâ¢2,yâ¢2) ã€‚ ç±»åˆ«å’Œåæ ‡è¢«æ˜ å°„åˆ°å¤§æ¨¡å‹æ¨¡æ€ä¸­ç›¸åº”çš„ language ğ‘¡ğ‘œğ‘˜ğ‘’ğ‘›_ğ‘–ğ‘‘ï¼Œèƒ½å¤Ÿæ— ç¼é›†æˆåˆ°æ¨¡å—ä¸­ã€‚ æ­¤å¤–ï¼Œåˆ©ç”¨é¢„è®­ç»ƒçš„è§†è§‰ç¼–ç å™¨ï¼ŒDriveVLM å¯ä»¥è¯†åˆ«ä¼ ç»Ÿ 3D ç‰©ä½“æ¢æµ‹å™¨æ— æ³•è¯†åˆ«çš„é•¿å°¾å…³é”®ç‰©ä½“ï¼Œå¦‚é“è·¯ä¸­ä¸æ˜ç‰©ä½“çš„ç¢ç‰‡æˆ–åŠ¨ç‰©ç­‰ã€‚ 2.2ã€Scene Analysisåœ¨ä¼ ç»Ÿçš„è‡ªåŠ¨é©¾é©¶æµç¨‹ä¸­ï¼Œé¢„æµ‹æ¨¡å—é€šå¸¸ä¸“æ³¨äºé¢„æµ‹ç‰©ä½“çš„æœªæ¥è½¨è¿¹ã€‚å…ˆè¿›è§†è§‰è¯­è¨€æ¨¡å‹çš„å‡ºç°ä½¿ä½œè€…èƒ½å¤Ÿå¯¹å½“å‰åœºæ™¯è¿›è¡Œæ›´å…¨é¢çš„åˆ†æã€‚åœºæ™¯çº§åˆ†ææ€»ç»“äº†æ‰€æœ‰å…³é”®å¯¹è±¡ä»¥åŠç¯å¢ƒæè¿°ã€‚è¯¥æ‘˜è¦æä¾›äº†å¯¹åœºæ™¯çš„å…¨é¢äº†è§£ï¼Œå¹¶è¾“å…¥åˆ°ä»¥ä¸‹è§„åˆ’æ¨¡å—ä¸­ã€‚ å…³é”®å¯¹è±¡åˆ†æã€‚ DriveVLM åœ¨ä¸‰ä¸ªæ–¹é¢è¡¨å¾å…³é”®å¯¹è±¡ï¼šé™æ€å±æ€§ Cs ï¼Œè¿åŠ¨çŠ¶æ€ Cm ï¼Œä»¥åŠç‰¹å®šçš„è¡Œä¸º Cb ã€‚ é™æ€å±æ€§ Cs æè¿°ç‰©ä½“çš„å›ºæœ‰å±æ€§ï¼Œä¾‹å¦‚è·¯è¾¹å¹¿å‘Šç‰Œæˆ–è£…è½½è¶…æ ‡è´§ç‰©çš„å¡è½¦ï¼Œè¿™å¯¹äºé¢„é˜²å’Œå¼•å¯¼æ½œåœ¨å±é™©è‡³å…³é‡è¦ã€‚ è¿åŠ¨çŠ¶æ€ Cm æè¿°ç‰©ä½“åœ¨ä¸€æ®µæ—¶é—´å†…çš„åŠ¨æ€ï¼ŒåŒ…æ‹¬ä½ç½®ã€æ–¹å‘å’ŒåŠ¨ä½œâ€”â€”è¿™äº›ç‰¹å¾å¯¹äºé¢„æµ‹ç‰©ä½“çš„æœªæ¥è½¨è¿¹ä»¥åŠä¸è‡ªæˆ‘è½¦è¾†çš„æ½œåœ¨äº¤äº’è‡³å…³é‡è¦ã€‚ ç‰¹æ®Šè¡Œä¸º Cb æŒ‡çš„æ˜¯å¯èƒ½ç›´æ¥å½±å“è‡ªæˆ‘è½¦è¾†çš„ä¸‹ä¸€æ¬¡é©¾é©¶å†³ç­–çš„ç‰©ä½“çš„ç‰¹æ®ŠåŠ¨ä½œæˆ–æ‰‹åŠ¿ã€‚ ç°å®ä¸­ï¼Œä¸éœ€è¦æ¨¡å‹åˆ†ææ‰€æœ‰å¯¹è±¡çš„æ‰€æœ‰ä¸‰ä¸ªç‰¹å¾ã€‚å®é™…ä¸Šï¼Œåªæœ‰ä¸€ä¸ªæˆ–ä¸¤ä¸ªç‰¹å¾é€‚ç”¨äºå…³é”®å¯¹è±¡å°±è¶³å¤Ÿäº†ã€‚æœ€åï¼ŒDriveVLM æ ¹æ®ä¸Šè¿°ç‰¹å¾ï¼Œé¢„æµ‹æ¯ä¸ªå…³é”®ç‰©ä½“å¯¹è‡ªæˆ‘è½¦è¾†çš„æ½œåœ¨å½±å“ Iã€‚ 2.3ã€Hierarchical Planningä¸Šè¿° Scene-Level æ‘˜è¦ä¸è·¯çº¿ã€è‡ªæˆ‘å§¿åŠ¿å’Œé€Ÿåº¦ç›¸ç»“åˆï¼Œå½¢æˆè§„åˆ’ Promptã€‚ æœ€åï¼ŒDriveVLM åˆ†ä¸‰ä¸ªé˜¶æ®µé€æ­¥ç”Ÿæˆé©¾é©¶è®¡åˆ’ï¼šMeta-Actionsã€å†³ç­–æè¿°å’Œè½¨è¿¹èˆªç‚¹ã€‚ Meta-Actions A ã€‚ Meta-Actionsï¼Œè¡¨ç¤ºä¸º ï¼Œä»£è¡¨é©¾é©¶ç­–ç•¥çš„çŸ­æœŸå†³ç­–ã€‚è¿™äº›åŠ¨ä½œåˆ†ä¸º17ç±»ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºåŠ é€Ÿã€å‡é€Ÿã€å·¦è½¬ã€å˜é“ã€è½»å¾®ä½ç½®è°ƒæ•´å’Œç­‰å¾…ã€‚ä¸ºäº†è®¡åˆ’è‡ªæˆ‘è½¦è¾†åœ¨ç‰¹å®šæ—¶æœŸå†…çš„æœªæ¥æœºåŠ¨ï¼Œç”Ÿæˆä¸€ç³»åˆ—Meta-Actionsã€‚ å†³ç­–æè¿° D ã€‚ å†³ç­–æè¿° D é˜æ˜äº†è‡ªè½¦åº”é‡‡ç”¨çš„æ›´ç»†ç²’åº¦çš„é©¾é©¶ç­–ç•¥ã€‚å®ƒåŒ…å«ä¸‰ä¸ªè¦ç´ ï¼š åŠ¨ä½œ ğ’œ ï¼Œ ä¸»ä½“ ğ’® ã€å’ŒæŒç»­æ—¶é—´ ğ’Ÿ ã€‚åŠ¨ä½œ ğ’œ ä¸ Meta-Actions A æœ‰å…³ï¼Œä¾‹å¦‚â€œè½¬å¼¯â€ã€â€œç­‰å¾…â€æˆ–â€œåŠ é€Ÿâ€ã€‚ä¸»ä½“ ğ’® æŒ‡äº¤äº’å¯¹è±¡ï¼Œä¾‹å¦‚è¡Œäººã€äº¤é€šä¿¡å·ç¯æˆ–ç‰¹å®šè½¦é“ã€‚æŒç»­æ—¶é—´ ğ’Ÿ æŒ‡æ“ä½œæ—¶é—´ï¼ŒæŒ‡å®šåº”æ‰§è¡Œå¤šé•¿æ—¶é—´æˆ–åº”å¼€å§‹çš„æ—¶é—´ã€‚ è½¨è¿¹èˆªç‚¹ W ã€‚ å»ºç«‹å†³ç­–æè¿° D åï¼Œä¸‹ä¸€é˜¶æ®µç”Ÿæˆç›¸åº”çš„è½¨è¿¹èˆªç‚¹ã€‚è¿™äº›èˆªç‚¹ï¼Œè¡¨ç¤ºä¸ºï¼š ï¼Œ å®ƒä»¬æç»˜äº†è½¦è¾†åœ¨æœªæ¥æŸä¸ªæ—¶é—´æ®µå†…çš„è·¯å¾„ï¼Œå¹¶æœ‰é¢„å®šçš„æ—¶é—´é—´éš” Î”ğ‘¡ã€‚ å°†è¿™äº›èˆªç‚¹æ•°å­—æ˜ å°„ä¸º language tokensï¼Œç”¨äºè‡ªå›å½’ç”Ÿæˆã€‚ 2.4ã€DriveVLM-Dualä¸ºäº†ç¼“è§£ VLM ä¸­é«˜å»¶è¿Ÿä»¥åŠä¸ç²¾ç¡®çš„ç©ºé—´å’Œè¿åŠ¨ç†è§£çš„æŒ‘æˆ˜ï¼Œä½œè€…æå‡ºäº† DriveVLM-Dualï¼Œè¿™æ˜¯ DriveVLM ä¸ä¼ ç»Ÿè‡ªåŠ¨é©¾é©¶ç³»ç»Ÿä¹‹é—´çš„åˆä½œã€‚è¿™ç§æ–°é¢–çš„æ–¹æ³•æ¶‰åŠä¸¤ä¸ªå…³é”®ç­–ç•¥ï¼šç»“åˆ 3D æ„ŸçŸ¥è¿›è¡Œå…³é”®å¯¹è±¡åˆ†æï¼Œä»¥åŠé«˜é¢‘è½¨è¿¹ç»†åŒ–ã€‚ é›†æˆ 3D æ„ŸçŸ¥ã€‚ ç”¨æ¥è¡¨ç¤ºä¸‰ç»´æ£€æµ‹å™¨æ£€æµ‹åˆ°çš„ç‰©ä½“ï¼Œå…¶ä¸­ è¡¨ç¤ºç¬¬ğ‘–ä¸ªbboxï¼Œè¡¨ç¤ºå…¶ç±»åˆ«ã€‚ ç„¶åå°†è¿™äº›ä¸‰ç»´è¾¹ç•Œæ¡†åæŠ•å½±åˆ°äºŒç»´å›¾åƒä¸Šï¼Œå¾—å‡ºç›¸åº”çš„äºŒç»´è¾¹ç•Œæ¡†ã€‚ ä½œè€…åœ¨è¿™äº›äºŒç»´è¾¹ç•Œæ¡†å’Œä¹‹é—´è¿›è¡Œ IoU åŒ¹é…ã€‚ æ˜¯å…ˆå‰ç¡®å®šçš„ä¸´ç•Œç‰©ä½“çš„è¾¹ç•Œæ¡†ã€‚ ä½œè€…å°†ç¬¦åˆæŸä¸ªè¿‘ä¼¼ IoU é˜ˆå€¼å¹¶ä¸åŒ¹é…çš„ä¸´ç•Œå¯¹è±¡ å±äºåŒä¸€ç±»åˆ«çš„ä¸´ç•Œå¯¹è±¡è¿›è¡Œåˆ†ç±»ï¼Œå…¶å®šä¹‰ä¸º åœ¨ 3D æ•°æ®ä¸­æ²¡æœ‰ç›¸åº”åŒ¹é…çš„å…³é”®å¯¹è±¡è¢«æ ‡è®°ä¸º ã€‚ åœ¨åœºæ™¯åˆ†ææ¨¡å—ä¸­ï¼Œå¯¹äº ï¼Œå°†å¯¹åº”3Dç‰©ä½“çš„ä¸­å¿ƒåæ ‡ã€æ–¹å‘å’Œå†å²è½¨è¿¹ä½œä¸ºæ¨¡å‹çš„è¯­è¨€æç¤ºï¼Œè¾…åŠ©ç‰©ä½“åˆ†æã€‚åä¹‹ï¼Œå¯¹äº ï¼Œåˆ†æä»…ä¾èµ–äºä»å›¾åƒæ´¾ç”Ÿçš„è¯­è¨€æ ‡è®°ã€‚è¿™ç§è®¾è®¡ä½¿ DriveVLM-Dual èƒ½å¤Ÿæ›´å‡†ç¡®åœ°äº†è§£å…³é”®ç‰©ä½“çš„ä½ç½®å’Œè¿åŠ¨ï¼Œä»è€Œæé«˜æ•´ä½“æ€§èƒ½ã€‚ é«˜é¢‘è½¨è¿¹ç»†åŒ–ã€‚ ä¸ºäº†å®ç°å®æ—¶ã€é«˜é¢‘çš„æ¨ç†èƒ½åŠ›ï¼Œå°†å…¶ä¸ä¼ ç»Ÿè§„åˆ’å™¨é›†æˆï¼Œå½¢æˆæ…¢é€ŸåŒç³»ç»Ÿï¼Œå°† DriveVLM çš„å…ˆè¿›åŠŸèƒ½ä¸ä¼ ç»Ÿè§„åˆ’æ–¹æ³•çš„æ•ˆç‡ç›¸ç»“åˆã€‚ ä» DriveVLM è·å¾—ä½é¢‘è½¨è¿¹åï¼Œè¡¨ç¤ºä¸º ï¼Œä½œè€…å°†å…¶ä½œä¸ºç»å…¸è§„åˆ’å™¨é«˜é¢‘è½¨è¿¹ç»†åŒ–çš„å‚è€ƒè½¨è¿¹ã€‚ å¯¹äºåŸºäºä¼˜åŒ–çš„è§„åˆ’å™¨ï¼Œ ä½œä¸ºä¼˜åŒ–æ±‚è§£å™¨çš„åˆå§‹è§£ã€‚ å¯¹äºåŸºäºç¥ç»ç½‘ç»œçš„è§„åˆ’å™¨ï¼Œ ç”¨ä½œè¾“å…¥æŸ¥è¯¢ï¼Œä¸é™„åŠ è¾“å…¥ç‰¹å¾ç›¸ç»“åˆ f ï¼Œç„¶åè§£ç ä¸ºæ–°çš„è§„åˆ’è½¨è¿¹ï¼Œè¡¨ç¤ºä¸º ã€‚ è¯¥è¿‡ç¨‹çš„è¡¨è¿°å¯ä»¥æè¿°ä¸ºï¼š æ­¤ç»†åŒ–æ­¥éª¤ç¡®ä¿ DriveVLM-Dual ç”Ÿæˆçš„è½¨è¿¹èƒ½å¤Ÿå®ç°æ›´é«˜çš„è½¨è¿¹è´¨é‡ï¼Œå¹¶ä¸”å¯ä»¥æ»¡è¶³å®æ—¶è¦æ±‚ã€‚ä¸¤ä¸ªåˆ†æ”¯ä»¥æ…¢-å¿«çš„æ–¹å¼å¼‚æ­¥è¿è¡Œï¼Œå…¶ä¸­ä¼ ç»Ÿè‡ªåŠ¨é©¾é©¶åˆ†æ”¯ä¸­çš„è§„åˆ’å™¨æ¨¡å—å¯ä»¥é€‰æ‹©æ€§åœ°æ¥æ”¶æ¥è‡ªVLMåˆ†æ”¯çš„è½¨è¿¹ä½œä¸ºé™„åŠ è¾“å…¥ã€‚ 3ã€æ•°æ®é›†ä¸ºä¾¿äºåœºæ™¯æ ‡æ³¨ï¼Œç ”ç©¶ç»„è¿˜å¼€å‘äº†ä¸€ä¸ªè§†é¢‘æ ‡æ³¨å·¥å…·ï¼Œèƒ½å¤Ÿæ¯”è¾ƒæ–¹ä¾¿çš„é’ˆå¯¹ç‰¹å®šæ ‡æ³¨å†…å®¹è¿›è¡Œå¯¹åº”çš„æ ‡æ³¨å’Œæ£€æŸ¥ã€‚SUP-ADæ•°æ®é›†ä¸­æŸä¸ªåœºæ™¯å…³é”®å¸§çš„æ ‡æ³¨ç»“æœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åœ¨äººå·¥æ™ºèƒ½çš„ä¸‰é©¾é©¬è½¦ä¸­ï¼Œæ•°æ®æ˜¯ç”Ÿäº§åŸæ–™ï¼Œç®—åŠ›æ˜¯åŸºç¡€è®¾æ–½ï¼Œç®—æ³•åˆ™æ˜¯å¤§æ¨¡å‹çš„é€»è¾‘è¡¨ç¤ºã€‚ä¸ºæå‡æ•°æ®è´¨é‡å’ŒDriveVLMå¤§æ¨¡å‹å‡†ç¡®åº¦ï¼Œç ”ç©¶ç»„æå‡ºäº†ä¸€ä¸ªå…¨é¢çš„æ•°æ®æŒ–æ˜å’Œæ ‡æ³¨æµæ°´çº¿ï¼Œå¹¶æ„å»ºäº†åŒ…å«è¶…40ä¸ªåœºæ™¯ç±»åˆ«çš„è‡ªåŠ¨é©¾é©¶æ•°æ®é›†SUP-ADï¼ˆscene understanding for planning-autonomous drivingï¼‰ã€‚ä¸‹é¢çš„æµç¨‹å›¾è§£é‡Šäº†æ„å»ºåœºæ™¯ç†è§£å’Œè§„åˆ’æ•°æ®é›†çš„æ•°æ®æŒ–æ˜å’Œæ ‡æ³¨æ–¹æ³•ã€‚åˆ—ä¸¾äº†ä¸€äº›ä»æ•°æ®é›†ä¸­éšæœºæŠ½å–çš„åœºæ™¯ç¤ºä¾‹å›¾ç‰‡ï¼Œå±•ç¤ºå‡ºäº†æ•°æ®é›†çš„å¤šæ ·æ€§å’Œå¤æ‚æ€§ã€‚ 4ã€å®éªŒä½¿ç”¨ Qwen-VL ä½œä¸ºé»˜è®¤çš„å¤§å‹è§†è§‰è¯­è¨€æ¨¡å‹ï¼Œå®ƒåœ¨é—®ç­”ã€è§†è§‰å®šä½å’Œæ–‡æœ¬è¯†åˆ«ç­‰ä»»åŠ¡ä¸­è¡¨ç°å‡ºå“è¶Šçš„æ€§èƒ½ã€‚å®ƒæ€»å…±åŒ…å« 9.6B å‚æ•°ï¼ŒåŒ…æ‹¬è§†è§‰ç¼–ç å™¨ï¼ˆ1.9Bï¼‰ã€Vision-Language Adapterï¼ˆ0.08Bï¼‰å’Œå¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆQwenï¼Œ7.7Bï¼‰ã€‚å›¾åƒå¤§å°è°ƒæ•´ä¸ºåˆ†è¾¨ç‡ 448Ã—448 åœ¨è¢«è§†è§‰ç¼–ç å™¨ç¼–ç ä¹‹å‰ã€‚åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œä½œè€…éšæœºé€‰æ‹©å½“å‰æ—¶é—´çš„å›¾åƒåºåˆ— T s, Tâˆ’1 s, Tâˆ’2ï¼ŒTâˆ’3 s ä½œä¸ºè¾“å…¥ã€‚æ‰€é€‰å›¾åƒç¡®ä¿åŒ…å«å½“å‰æ—¶é—´èŒƒå›´å¹¶éµå¾ªå‡åºæ—¶é—´é¡ºåºã€‚ DriveVLM çš„å®šæ€§ç»“æœå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚åœ¨ä¸‹é¢çš„ç¬¬ä¸€å¼ å›¾ä¸­ï¼ŒDriveVLM å¯å‡†ç¡®é¢„æµ‹å½“å‰çš„åœºæ™¯æ¡ä»¶ï¼Œå¹¶é’ˆå¯¹æ¥è¿‘ä½œè€…çš„éª‘è½¦äººåšå‡ºæ·±æ€ç†Ÿè™‘çš„è§„åˆ’å†³ç­–ã€‚åœ¨ç¬¬äºŒå¼ å›¾ä¸­ï¼ŒDriveVLMæœ‰æ•ˆåœ°ç†è§£äº†å‰æ–¹äº¤è­¦çš„æ‰‹åŠ¿ï¼Œå‘æœ¬è½¦å‘å‡ºç»§ç»­å‰è¿›çš„ä¿¡å·ï¼Œå¹¶ä¸”è¿˜è€ƒè™‘äº†å³ä¾§éª‘ä¸‰è½®è½¦çš„äººï¼Œä»è€Œåšå‡ºæ˜æ™ºçš„é©¾é©¶å†³ç­–ã€‚è¿™äº›å®šæ€§ç»“æœè¯æ˜äº†è¯¥å¤§æ¨¡å‹å…·æœ‰ç†è§£å¤æ‚åœºæ™¯å¹¶åˆ¶å®šåˆé€‚é©¾é©¶è®¡åˆ’çš„å“è¶Šèƒ½åŠ›ã€‚å›¾ç‰‡ä¸­çš„æ©™è‰²æ›²çº¿ä»£è¡¨æ¨¡å‹åœ¨æ¥ä¸‹æ¥ 3 ç§’å†…è®¡åˆ’çš„æœªæ¥è½¨è¿¹ã€‚ 5ã€æœ€ç»ˆéƒ¨ç½²åœ¨é…å¤‡ä¸¤ä¸ª OrinX å¤„ç†å™¨çš„ç†æƒ³ Mega è‡ªåŠ¨é©¾é©¶è½¦è¾†ä¸Šéƒ¨ç½² DriveVLM-Dualï¼Œåœ¨ OrinX-1 ä¸Šé…å¤‡é«˜é¢‘ç«¯åˆ°ç«¯é©±åŠ¨ç³»ç»Ÿï¼Œåœ¨ OrinX-2 ä¸Šé…å¤‡ DriveVLMã€‚è¿™ä¸¤ä¸ªç³»ç»Ÿå¼‚æ­¥è¿è¡Œå’Œåä½œã€‚æ­¤å¤–ï¼Œæ ¹æ® Orin ä¼˜åŒ–äº† DriveVLMï¼Œåœ¨ OrinX ä¸Šå®ç°äº† 410 æ¯«ç§’çš„å¹³å‡æ¨ç†é€Ÿåº¦ã€‚ Base LLMï¼šç”±äºè½¦è¾†ç¡¬ä»¶çš„å†…å­˜å’Œå¸¦å®½æœ‰é™ï¼Œæ— æ³•ä½¿ç”¨è¿‡å¤§çš„LLMsæ¥ç»´æŒå®æ—¶æ¨ç†ã€‚å› æ­¤ï¼Œé€‰æ‹©å‚æ•°å°‘äº40äº¿çš„æ¨¡å‹ã€‚å®éªŒè¡¨æ˜ï¼Œåœ¨Orinæ¶æ„ä¸Šï¼Œâ€œå®½è€Œæµ…â€çš„Qwenç³»åˆ—ï¼ˆæ›´å®½å’Œæ›´å°‘çš„å±‚ï¼‰æ¨¡å‹åœ¨æ¨ç†é€Ÿåº¦ä¸Šä¼˜äºâ€œçª„å’Œæ·±â€æ¨¡å‹ï¼ˆæ›´çª„å’Œæ›´å¤šçš„å±‚ï¼‰ã€‚ Visual Encoderï¼šé«˜åˆ†è¾¨ç‡å›¾åƒå¯¹äºè‡ªåŠ¨é©¾é©¶ä¸­çš„ç»†ç²’åº¦è§†è§‰ç†è§£è‡³å…³é‡è¦ã€‚ä¸ç”¨ä½œè§†è§‰ç¼–ç å™¨çš„åŸºæœ¬ViTæ¨¡å‹ç›¸æ¯”ï¼Œä½œè€…æ¢ç´¢äº†å‡ ç§é€‰æ‹©ï¼ŒåŒ…æ‹¬ä¸åŒçš„GridPatchç­–ç•¥å’ŒPEï¼ˆä½ç½®åµŒå…¥ï¼‰æ’å€¼ã€‚æœ€ç»ˆï¼Œä¸ºäº†å®æ—¶æ¨ç†ï¼Œé€‰æ‹©äº†æ›´ç®€å•çš„å¸¦ PE æ’å€¼çš„ SigLIP-L-384 æ¨¡å‹ï¼Œé€šè¿‡åŸå§‹ 384 åˆ†è¾¨ç‡ PE æ’å€¼å’Œé™„åŠ å·ç§¯å±‚å¾®è°ƒå‚æ•°æ¥å®ç°é«˜åˆ†è¾¨ç‡è¾“å…¥ã€‚ Vision Token Compressionï¼šä¸ºäº†è§£å†³é«˜åˆ†è¾¨ç‡å›¾åƒå¢åŠ çš„è®¡ç®—è´Ÿè½½ï¼Œå®ç°äº† LDPNetv2ï¼Œä»¥åœ¨ä¸å½±å“æ€§èƒ½çš„æƒ…å†µä¸‹å°†å›¾åƒæ ‡è®°çš„æ•°é‡å‡å°‘ 75%ã€‚æ­¤å¤–ï¼Œé€šè¿‡åœ¨ LDPNetv2 ä¸­ç”¨å·ç§¯å±‚æ›¿æ¢å¹³å‡æ± åŒ–å±‚æ¥å¢å¼ºæ€§èƒ½ã€‚ Video Inputï¼šåœ¨è‡ªåŠ¨é©¾é©¶åœºæ™¯ä¸­ï¼Œéœ€è¦æ›´å¤šçš„æ—¶é—´ä¸Šä¸‹æ–‡æ¥å‡†ç¡®è¯„ä¼°ç‰©ä½“è¿åŠ¨å˜åŒ–ã€‚ä½œè€…é‡‡ç”¨çŸ­æœŸè®°å¿†åº“ç­–ç•¥ï¼Œå°†å†å²å¸§ä¸­çš„è§†è§‰ç‰¹å¾ä¸´æ—¶å­˜å‚¨åœ¨ç‰¹å¾é˜Ÿåˆ—ä¸­ã€‚åœ¨æ˜ å°„åˆ°LLMä¹‹å‰ï¼Œä»…æå–å½“å‰æ—¶åˆ»çš„ç‰¹å¾å¹¶å°†å…¶ä¸å¤šä¸ªå†å²å¸§èåˆã€‚é™¤äº†åŸºæœ¬çš„æ—¶ç©ºPoolingä¹‹å¤–ï¼Œè¿˜æ·»åŠ äº† SE å—æ¥æ‰§è¡Œå¤šä¸ªæ—¶é—´å¸§çš„åŠ æƒèåˆã€‚ Speculative Samplingï¼šæ¨æµ‹é‡‡æ ·é€šè¿‡æŠ¢å…ˆç”Ÿæˆå¯èƒ½çš„è¾“å‡ºæ¥åŠ é€Ÿæ¨ç†ã€‚ è¿™ç§æ–¹æ³•å‡å°‘äº†ç”Ÿæˆé¢„æµ‹çš„å»¶è¿Ÿï¼Œåœ¨ä¸å¤§å¹…é™ä½å‡†ç¡®æ€§çš„æƒ…å†µä¸‹æ˜¾è‘—æé«˜äº†é€Ÿåº¦ã€‚ä½œè€…æµ‹è¯•äº†ä¸¤ç§æ¨æµ‹é‡‡æ ·æ–¹æ³•ï¼š Medusa å’Œä¸ä½œè€…ä¸“ä¸º OrinX èŠ¯ç‰‡è®¾è®¡çš„ Eagle æ¨ç†æ¡†æ¶ã€‚ ä¸ Medusa çš„ 2.17 å€è§£ç å»¶è¿Ÿç›¸æ¯”ï¼ŒEagle çš„è§£ç å»¶è¿Ÿé€Ÿåº¦æé«˜äº† 2.7 å€ï¼Œä½¿è½¦è¾†çš„å®æ—¶éƒ¨ç½²å˜å¾—å¯è¡Œã€‚ éƒ¨ç½²ç»“æœï¼š ä¸‹å›¾ä¸­ï¼ŒDriveVLM è¯†åˆ«å‰æ–¹ç¼“æ…¢ç§»åŠ¨çš„è½¦è¾†ï¼Œå¹¶æä¾›å˜é“è¶…è½¦çš„é©¾é©¶å†³ç­–ã€‚ ä¸‹å›¾ä¸­ï¼ŒDriveVLMå‡†ç¡®è¯†åˆ«äº†éå¸¸è§„è½¦è¾†çš„ç±»å‹å’Œå€’ä¸‹çš„æ ‘æœ¨ï¼Œå±•ç¤ºäº†å…¶è¯†åˆ«é•¿å°¾ç‰©ä½“çš„èƒ½åŠ› ä¸‹å›¾å±•ç¤ºå‡ºDriveVLM å‡†ç¡®æ•æ‰åˆ°äº†äº¤è­¦ç¤ºæ„ç»§ç»­è¡Œé©¶çš„æ‰‹åŠ¿ã€‚","link":"/posts/a11b1e0f/"},{"title":"ã€è¸©å‘ç¬”è®°ã€‘Nvidia T4è®¡ç®—å¡åœ¨WindowsæœåŠ¡å™¨ä½¿ç”¨docker","text":"1ã€èƒŒæ™¯ä¸šåŠ¡ä¸Šæœ‰ä¸ªéœ€æ±‚ï¼Œå¸Œæœ›åœ¨ Windows Server 2022 å†…é€šè¿‡ wsl2 éƒ¨ç½² docker è¿è¡Œç±»ä¼¼ Ollama çš„ GPU æœåŠ¡ã€‚ä½† T4 è®¡ç®—å¡ä½¿ç”¨é€šç”¨æ–¹æ¡ˆç›´æ¥å®‰è£…å®˜ç½‘ä¸‹è½½çš„ GPU é©±åŠ¨ + docker desktop æ— æ³•åœ¨ docker å†…è°ƒç”¨ GPUã€‚ å…·ä½“è¡¨ç°ä¸ºï¼šwsl å†…nvidia-smiå‘½ä»¤æ­£å¸¸ï¼›nvcc -Vå‘½ä»¤æ­£å¸¸ï¼Œdocker å†…nvidia-smiå‘½ä»¤å¼‚å¸¸ã€‚ç½‘ä¸Šæ‰¾åˆ°ä¿®æ”¹æ³¨å†Œè¡¨å¯ä»¥å¼ºå¯WDDMæ¨¡å¼ï¼Œå°è¯•åï¼Œdocker å†…èƒ½çœ‹åˆ° GPUï¼Œä½†ç¨‹åºæ— æ³•è°ƒç”¨ã€‚ 2ã€è§£å†³æ–¹æ³•T4è®¡ç®—å¡ä¿®æ”¹æ³¨å†Œè¡¨å¼ºå¯WDDMæ—¶ï¼Œé©±åŠ¨ä¸å…¨ã€‚éœ€è¦ä¸‹è½½ä¸“æœ‰å¸¦æˆæƒçš„ NVIDIA RTX è™šæ‹Ÿå·¥ä½œç«™ï¼ˆNVIDIA GRIDï¼‰é©±åŠ¨ã€‚Windowsç³»ç»Ÿ538.67é©±åŠ¨é“¾æ¥ å®‰è£…å®Œæˆå¹¶é‡å¯æœåŠ¡å™¨ä¹‹åï¼Œåœ¨Windowsç»ˆç«¯æµ‹è¯•nvidia-smiå‘½ä»¤ï¼Œæ˜¾ç¤º WDDM å³ä¸ºæˆåŠŸï¼ˆå®˜ç½‘é©±åŠ¨æ­¤å¤„æ˜¾ç¤ºTCCï¼‰ã€‚ 12345678910111213+---------------------------------------------------------------------------------------+| NVIDIA-SMI 537.70 Driver Version: 537.70 CUDA Version: 12.2 ||-----------------------------------------+----------------------+----------------------+| GPU Name TCC/WDDM | Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. ||=========================================+======================+======================|| 0 Tesla T4 WDDM | 00000000:3D:00.0 Off | 0 || N/A 26C P0 26W / 70W | 8MiB / 15360MiB | 0% Default |+-----------------------------------------+----------------------+----------------------+| 1 Tesla T4 WDDM | 00000000:3E:00.0 Off | 0 || N/A 25C P8 9W / 70W | 0MiB / 15360MiB | 0% Default |+-----------------------------------------+----------------------+----------------------+...... æ³¨æ„ï¼š å¦‚æœä½ çš„è®¡ç®—å¡æ˜¯ T4 æˆ– L4 ä¸” å®‰è£…äº† NVIDIA 510 æˆ–æ›´é«˜ç‰ˆæœ¬çš„é©±åŠ¨ç¨‹åºï¼Œåˆ™éœ€è¦åœç”¨ GSP å›ºä»¶ã€‚è¯·å‚é˜… Nvidia æ–‡æ¡£ä¸­çš„åœç”¨ GSP å›ºä»¶ã€‚ å¯¹äºåœ¨ Compute Engine ä¸Šè¿è¡Œçš„ L4ã€T4ã€P4 å’Œ P100 NVIDIA RTX è™šæ‹Ÿå·¥ä½œç«™ (vWS)ï¼Œå»ºè®®æ ¹æ®åº”ç”¨æ‰€éœ€çš„ NVIDIA è™šæ‹Ÿ GPU è½¯ä»¶ä½¿ç”¨ä»¥ä¸‹ NVIDIA é©±åŠ¨ç¨‹åºç‰ˆæœ¬ï¼š å¯¹äº NVIDIA è™šæ‹Ÿ GPU è½¯ä»¶ç‰ˆæœ¬ 17ï¼Œå»ºè®®ä½¿ç”¨ä»¥ä¸‹æœ€ä½ NVIDIA é©±åŠ¨ç¨‹åºï¼š å¯¹äº Linux è™šæ‹Ÿæœºï¼š550.90.07 å¯¹äº Windows è™šæ‹Ÿæœºï¼š552.55 å¯¹äº NVIDIA è™šæ‹Ÿ GPU è½¯ä»¶ç‰ˆæœ¬ 16ï¼Œå»ºè®®ä½¿ç”¨ä»¥ä¸‹æœ€ä½ NVIDIA é©±åŠ¨ç¨‹åºï¼š å¯¹äº Linux è™šæ‹Ÿæœºï¼š535.183.01 å¯¹äº Windows è™šæ‹Ÿæœºï¼š538.67 3ã€åç»­æ­¥éª¤é©±åŠ¨å®‰è£…å¦¥å½“ä¹‹åï¼Œæ­£å¸¸å®‰è£…dockerå³å¯ã€‚ ï¼ï¼ï¼æ³¨æ„ï¼š å¯¹äº4å¡ä»¥ä¸Šçš„æœºå™¨ï¼ŒåŒä¸€ä¸ªå®¹å™¨å†…ä»…æ”¯æŒ4å¼ åŠä»¥ä¸‹GPUï¼Œéœ€è¦åœ¨docker-composeæ—¶ é™å®šå¯è§GPUæ•°é‡ã€å¿…é€‰é¡¹ã€‘ã€‚å…·ä½“åŸå› æœªçŸ¥ï¼ŒçŒœæµ‹å¯èƒ½æ˜¯é©±åŠ¨ä¸æ”¯æŒï¼Ÿ é™å®šæ–¹æ³•ï¼šç¯å¢ƒå˜é‡ä¸­æ·»åŠ  - CUDA_VISIBLE_DEVICES=0,1,2,3 (docker composeå¯åŠ¨) æˆ– --env CUDA_VISIBLE_DEVICES=0,1,2,3ï¼ˆdocker runå¯åŠ¨ï¼‰","link":"/posts/11f6a109/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"ç³»ç»Ÿé—®é¢˜","slug":"ç³»ç»Ÿé—®é¢˜","link":"/tags/%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98/"},{"name":"æ¿€å…‰é›·è¾¾","slug":"æ¿€å…‰é›·è¾¾","link":"/tags/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/"},{"name":"æ„ŸçŸ¥ç®—æ³•","slug":"æ„ŸçŸ¥ç®—æ³•","link":"/tags/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95/"},{"name":"è‡ªåŠ¨é©¾é©¶","slug":"è‡ªåŠ¨é©¾é©¶","link":"/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"},{"name":"æ·±åº¦å­¦ä¹ ","slug":"æ·±åº¦å­¦ä¹ ","link":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"NVIDIA","slug":"NVIDIA","link":"/tags/NVIDIA/"},{"name":"Sophonç®—èƒ½","slug":"Sophonç®—èƒ½","link":"/tags/Sophon%E7%AE%97%E8%83%BD/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"æ‘„åƒå¤´","slug":"æ‘„åƒå¤´","link":"/tags/%E6%91%84%E5%83%8F%E5%A4%B4/"},{"name":"ç¯å¢ƒéƒ¨ç½²","slug":"ç¯å¢ƒéƒ¨ç½²","link":"/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"ç³»ç»Ÿå®‰è£…","slug":"ç³»ç»Ÿå®‰è£…","link":"/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"name":"ROG","slug":"ROG","link":"/tags/ROG/"},{"name":"ç½‘ç»œè®¾å¤‡","slug":"ç½‘ç»œè®¾å¤‡","link":"/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"},{"name":"å¤–è®¾","slug":"å¤–è®¾","link":"/tags/%E5%A4%96%E8%AE%BE/"},{"name":"å­˜å‚¨è®¾å¤‡","slug":"å­˜å‚¨è®¾å¤‡","link":"/tags/%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87/"},{"name":"LLM","slug":"LLM","link":"/tags/LLM/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Autoware","slug":"Autoware","link":"/tags/Autoware/"}],"categories":[{"name":"å†™ç‚¹ç¬”è®°","slug":"å†™ç‚¹ç¬”è®°","link":"/categories/%E5%86%99%E7%82%B9%E7%AC%94%E8%AE%B0/"},{"name":"å†™ç‚¹æ•™ç¨‹","slug":"å†™ç‚¹æ•™ç¨‹","link":"/categories/%E5%86%99%E7%82%B9%E6%95%99%E7%A8%8B/"},{"name":"æ¥ç‚¹å¹²è´§","slug":"æ¥ç‚¹å¹²è´§","link":"/categories/%E6%9D%A5%E7%82%B9%E5%B9%B2%E8%B4%A7/"},{"name":"ç©ç‰©æœ‰å¿—","slug":"ç©ç‰©æœ‰å¿—","link":"/categories/%E7%8E%A9%E7%89%A9%E6%9C%89%E5%BF%97/"}],"pages":[{"title":"ä¸ªäººç®€ä»‹","text":"Hi Thereï¼","link":"/about/index.html"}]}