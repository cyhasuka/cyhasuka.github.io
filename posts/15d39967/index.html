<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>Autoware 软件开发指南 - CuiYuhao&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="CuiYuhao&#039;s Blog"><meta name="msapplication-TileImage" content="/img/webicon.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="CuiYuhao&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="目录 一、Autoware 概述及安装指南  二、Autoware 感知模块解析  2.1 基于Darknet的Yolov3图像识别 2.2 voxel_grid_filter点云降采样程序注解 2.3 ring_ground_filter地面点云去除程序注解   三、Autoware 定位模块解析  3.0 基础知识 3.1 ndt_mapping节点解析 3.2 ndt_matchi"><meta property="og:type" content="blog"><meta property="og:title" content="Autoware 软件开发指南"><meta property="og:url" content="https://cyhasuka.github.io/posts/15d39967/"><meta property="og:site_name" content="CuiYuhao&#039;s Blog"><meta property="og:description" content="目录 一、Autoware 概述及安装指南  二、Autoware 感知模块解析  2.1 基于Darknet的Yolov3图像识别 2.2 voxel_grid_filter点云降采样程序注解 2.3 ring_ground_filter地面点云去除程序注解   三、Autoware 定位模块解析  3.0 基础知识 3.1 ndt_mapping节点解析 3.2 ndt_matchi"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.shields.io/static/v1?label=Ubuntu&amp;message=18.04LTS&amp;color=orange&amp;logo=ubuntu"><meta property="og:image" content="https://img.shields.io/static/v1?label=ROS&amp;message=Melodic&amp;color=&amp;logo=ros"><meta property="og:image" content="https://img.shields.io/static/v1?label=Autoware&amp;message=1.14&amp;color=blue&amp;logo=github"><meta property="og:image" content="https://img.shields.io/static/v1?label=Doc Version&amp;message=3.2&amp;color=&amp;logo=markdown"><meta property="og:image" content="https://api.visitorbadge.io/api/visitors?path=https://github.com/cyhasuka/Autoware-Manuals-Chinese&amp;label=Visitors&amp;countColor=%232ccce4&amp;style=flat&amp;labelStyle=none"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware.ai.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware_arc.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware_nodes.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/stage_diff.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/yolo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/4-matrix.svg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/3-matrix.svg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/1-matrix.svg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/math_NDT1.svg"><meta property="og:image" content="https://math.jianshu.com/math?formula=%5Cvec%20%5Cmu"><meta property="og:image" content="https://math.jianshu.com/math?formula=%5CSigma"><meta property="og:image" content="https://math.jianshu.com/math?formula=%5Cvec%20%5Cmu"><meta property="og:image" content="https://math.jianshu.com/math?formula=%5Cvec%20y_%7Bk=1,2,3,...,m%7D"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/math_ndt2.svg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/math_ndt3.svg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pcl.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/Pseudocode_ndt.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/ndt_mapping.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/ndt_matching.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/nodes_for_ctrl.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/nodes_for_vel.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/saved_waypoints_csv.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/limit_vel.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/calCrvPama1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/calCrvPama2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/eva_func.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/astar_avoid.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/obs_det1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/obs_det2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pointsDetection.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pure_pursuit.png"><meta property="article:published_time" content="2023-12-27T02:33:40.000Z"><meta property="article:modified_time" content="2024-01-03T02:08:34.395Z"><meta property="article:author" content="cyhasuka"><meta property="article:tag" content="ROS"><meta property="article:tag" content="激光雷达"><meta property="article:tag" content="Autoware"><meta property="article:tag" content="自动驾驶"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://img.shields.io/static/v1?label=Ubuntu&amp;message=18.04LTS&amp;color=orange&amp;logo=ubuntu"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cyhasuka.github.io/posts/15d39967/"},"headline":"Autoware 软件开发指南","image":["https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware.ai.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware_arc.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware_nodes.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/stage_diff.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/yolo.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pcl.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/Pseudocode_ndt.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/ndt_mapping.jpg","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/ndt_matching.jpg","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/nodes_for_ctrl.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/nodes_for_vel.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/saved_waypoints_csv.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/limit_vel.jpg","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/calCrvPama1.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/calCrvPama2.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/eva_func.jpg","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/astar_avoid.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/obs_det1.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/obs_det2.png","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pointsDetection.jpg","https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pure_pursuit.png"],"datePublished":"2023-12-27T02:33:40.000Z","dateModified":"2024-01-03T02:08:34.395Z","author":{"@type":"Person","name":"cyhasuka"},"publisher":{"@type":"Organization","name":"CuiYuhao's Blog","logo":{"@type":"ImageObject","url":"https://cyhasuka.github.io/img/toplogo.jpg"}},"description":"目录 一、Autoware 概述及安装指南  二、Autoware 感知模块解析  2.1 基于Darknet的Yolov3图像识别 2.2 voxel_grid_filter点云降采样程序注解 2.3 ring_ground_filter地面点云去除程序注解   三、Autoware 定位模块解析  3.0 基础知识 3.1 ndt_mapping节点解析 3.2 ndt_matchi"}</script><link rel="canonical" href="https://cyhasuka.github.io/posts/15d39967/"><link rel="icon" href="/img/webicon.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="/css/tianli_gpt.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>!function(){function e(){if(!location.hash)return;const e="#"+CSS.escape(location.hash.substring(1)),t=document.querySelector(`.tabs a[href="${e}"]`);if(!t)return;const n=t.parentElement.parentElement;Array.from(n.children).forEach(e=>e.classList.remove("is-active")),Array.from(n.querySelectorAll("a")).map(e=>document.getElementById(e.getAttribute("href").substring(1))).forEach(e=>e.classList.add("is-hidden")),t&&t.parentElement.classList.add("is-active");const r=document.querySelector(e);r&&r.classList.remove("is-hidden")}e(),window.addEventListener("hashchange",e,!1)}()</script><meta name="generator" content="Hexo 7.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/toplogo.jpg" alt="CuiYuhao&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/posts/c0297c2d">留言板</a><a class="navbar-item" href="/archives">个人简介</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="我的GitHub" href="https://github.com/cyhasuka"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2023-12-27T02:33:40.000Z" title="12/27/2023, 10:33:40 AM">2023-12-27</time>发表</span><span class="level-item"><time datetime="2024-01-03T02:08:34.395Z" title="1/3/2024, 10:08:34 AM">2024-01-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9D%A5%E7%82%B9%E5%B9%B2%E8%B4%A7/">来点干货</a></span><span class="level-item">完整阅读约4 小时 (34251个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Autoware 软件开发指南</h1><div class="content"><p><img src="https://img.shields.io/static/v1?label=Ubuntu&message=18.04LTS&color=orange&logo=ubuntu"> <img src="https://img.shields.io/static/v1?label=ROS&message=Melodic&color=&logo=ros"> <img src="https://img.shields.io/static/v1?label=Autoware&message=1.14&color=blue&logo=github"> <img src="https://img.shields.io/static/v1?label=Doc Version&message=3.2&color=&logo=markdown"> <img src="https://api.visitorbadge.io/api/visitors?path=https://github.com/cyhasuka/Autoware-Manuals-Chinese&label=Visitors&countColor=%232ccce4&style=flat&labelStyle=none"></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="#jump1.0">一、Autoware 概述及安装指南</a></p></li><li><p><a href="#jump2.0">二、Autoware 感知模块解析</a></p><ul><li><a href="#jump2.1">2.1 基于Darknet的Yolov3图像识别</a></li><li><a href="#jump2.2">2.2 voxel_grid_filter点云降采样程序注解</a></li><li><a href="#jump2.3">2.3 ring_ground_filter地面点云去除程序注解</a></li></ul></li><li><p><a href="#jump3.0">三、Autoware 定位模块解析</a></p><ul><li><a href="#jump3.0.0">3.0 基础知识</a></li><li><a href="#jump3.1">3.1 ndt_mapping节点解析</a></li><li><a href="#jump3.2">3.2 ndt_matching节点解析</a></li></ul></li><li><p><a href="#jump4.0">四、Autoware 决策规划模块解析</a></p><ul><li><a href="#jump4.1">4.1 节点waypoint_loader</a></li><li><a href="#jump4.2">4.2 节点waypoint_replanner</a></li><li><a href="#jump4.3">4.3 节点lane_navi</a></li><li><a href="#jump4.4">4.4 节点lane_rule</a></li><li><a href="#jump4.5">4.5 节点lane_select</a></li><li><a href="#jump4.6">4.6 节点 astar_avoid</a></li><li><a href="#jump4.7">4.7 节点velocity_set</a></li></ul></li><li><p><a href="#jump5.0">五、Autoware 控制模块解析</a></p><ul><li><a href="#jump5.1">5.1 节点pure_pursuit</a></li><li><a href="#jump5.2">5.2 节点twist_filter</a></li><li><a href="#jump5.3">5.3 节点listener_car_drive</a></li></ul></li></ul><p><span id="jump1.0"></span></p><h2 id="一、Autoware-概述及安装指南"><a href="#一、Autoware-概述及安装指南" class="headerlink" title="一、Autoware 概述及安装指南"></a>一、Autoware 概述及安装指南</h2><h3 id="1-1-Autoware简介"><a href="#1-1-Autoware简介" class="headerlink" title="1.1    Autoware简介"></a>1.1 Autoware简介</h3><p>​ Autoware最早是由名古屋大学研究小组在加藤伸平教授(Prof. Shinpei Kato)的领导下于2015年8月正式发布。2015年12月下旬，加藤伸平教授创立了Tier IV，以维护Autoware并将其应用于真正的自动驾驶汽车。随着时间的流逝，Autoware已成为公认的开源项目。Autoware也是世界上第一个用于自动驾驶技术的“多合一”开源软件。Autoware.ai版本基于ROS 1，并在Apache 2.0许可下可用。Autoware的功能主要适合与城市，但也可以覆盖高速公路。支持以下功能：路径规划、路径跟随、加速&#x2F;制动&#x2F;转向控制、数据记录、汽车&#x2F;行人&#x2F;物体检测、3D本地化、3D映射、交通信号检测、交通灯识别、车道检测、对象跟踪、传感器校准、传感器融合、面向云的地图连接自动化、智能手机导航、软件仿真、虚拟现实等。</p><p>​ Autoware作为第一款开源的自动驾驶框架，当前各大自动驾驶公司的框架几乎都借鉴过，Autoware框架是理解自动驾驶系统知识最好的学习模板之一。其包含了自动驾驶所有关键技术模块：建图、定位、感知、规划和运动控制。</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware.ai.png" alt="autoware.ai" style="zoom:23%"> <span id="more"></span><h3 id="1-2-Autoware主体框架"><a href="#1-2-Autoware主体框架" class="headerlink" title="1.2    Autoware主体框架"></a>1.2 Autoware主体框架</h3><p>​ autoware主要包括sensing、computing（perception、decision、planning）、actuation等几个部分，如下图所示。</p><p>​ sensing模块对应的是各类传感器对真实世界中各类数据的采样，例如camera采样图像、LiDAR采样激光点云等，采样数据属于未处理的原始数据，需要输入到computing模块进行计算处理。</p><p>​ computing模块主要是为了对传感器采样的原始数据进行加工处理，最后以为实现安全高效的导航为目的，将规划结果输出给actuation模块。其中computing模块主要分为三个小模块。① perception（感知模块），这部分要处理localization（通过车辆当前采集传感器数据和已有地图进行自身定位，若无地图需要通过SLAM构建地图），然后detection模块负责检测周围与车辆有场景交互的非自身个体（车辆、行人等），prediction模块会对检测初得物体进行未来预测估计，以便提前规划防止碰撞。② decision（决策模块），根据之前感知的结果，Autoware决策一个由有限状态机表示的驾驶行为，以便可以选择适当的计划功能。当前的决策方法是基于规则的系统。③ planning（规划模块），主要是根据决策和起始点和目标点，采用mission和motion模块可以计算出一条kinodynamic的路径。④ actuation模块，表示驱动器模块，如YMC驱动器等，接收planning模块出来的规划结果，通过驱动器实现驱动控制。</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware_arc.png" alt="img" style="zoom:50%"><p>​ 其各个模块都有对应不同的ros节点，如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/autoware_nodes.png" alt="img" style="zoom:50%"><h3 id="1-3-Autoware安装指南"><a href="#1-3-Autoware安装指南" class="headerlink" title="1.3    Autoware安装指南"></a>1.3 Autoware安装指南</h3><h4 id="1-3-1-系统版本及驱动确认"><a href="#1-3-1-系统版本及驱动确认" class="headerlink" title="1.3.1    系统版本及驱动确认"></a>1.3.1 系统版本及驱动确认</h4><p>​ 请确认系统版本为Ubuntu18.04，并正确安装英伟达显卡驱动460版本、CUDA版本10.0、cuDNN版本10.0。系统及驱动安装教程不再赘述。</p><h4 id="1-3-2-安装caffe"><a href="#1-3-2-安装caffe" class="headerlink" title="1.3.2    安装caffe"></a>1.3.2 安装caffe</h4><h5 id="①-caffe相关依赖包"><a href="#①-caffe相关依赖包" class="headerlink" title="① caffe相关依赖包"></a>① caffe相关依赖包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler</span><br><span class="line">$ sudo apt install -y --no-install-recommends libboost-all-dev</span><br><span class="line">$ sudo apt install -y libgflags-dev libgoogle-glog-dev liblmdb-dev</span><br></pre></td></tr></table></figure><h5 id="②-安装caffe"><a href="#②-安装caffe" class="headerlink" title="② 安装caffe"></a>② 安装caffe</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install caffe-cuda</span><br></pre></td></tr></table></figure><h4 id="1-3-3-安装eigen3-3-7"><a href="#1-3-3-安装eigen3-3-7" class="headerlink" title="1.3.3    安装eigen3.3.7"></a>1.3.3 安装eigen3.3.7</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd &amp;&amp; wget http://bitbucket.org/eigen/eigen/get/3.3.7.tar.gz</span><br><span class="line">$ mkdir eigen &amp;&amp; tar --strip-components=1 -xzvf 3.3.7.tar.gz -C eigen</span><br><span class="line">$ cd eigen &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ cd &amp;&amp; rm -rf 3.3.7.tar.gz &amp;&amp; rm -rf eigen</span><br></pre></td></tr></table></figure><h4 id="1-3-4-安装Autoware-1-14"><a href="#1-3-4-安装Autoware-1-14" class="headerlink" title="1.3.4    安装Autoware 1.14"></a>1.3.4 安装Autoware 1.14</h4><h5 id="①-安装Ubuntu-18-04-依赖"><a href="#①-安装Ubuntu-18-04-依赖" class="headerlink" title="① 安装Ubuntu 18.04 依赖"></a>① 安装Ubuntu 18.04 依赖</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y python-catkin-pkg python-rosdep ros-$ROS_DISTRO-catkin</span><br><span class="line">$ sudo apt install -y python3-pip python3-colcon-common-extensions python3-setuptools python3-vcstool</span><br><span class="line">$ pip3 install -U setuptools</span><br></pre></td></tr></table></figure><h5 id="②-建立workspace"><a href="#②-建立workspace" class="headerlink" title="② 建立workspace"></a>② 建立workspace</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p autoware.ai/src</span><br><span class="line">$ cd autoware.ai</span><br></pre></td></tr></table></figure><h5 id="③-下载Autoware-1-14"><a href="#③-下载Autoware-1-14" class="headerlink" title="③ 下载Autoware 1.14"></a>③ 下载Autoware 1.14</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O autoware.ai.repos &quot;https://gitlab.com/autowarefoundation/autoware.ai/autoware/raw/1.14.0/autoware.ai.repos?inline=false&quot;</span><br><span class="line">$ vcs import src &lt; autoware.ai.repos</span><br></pre></td></tr></table></figure><h5 id="④-安装ROS依赖"><a href="#④-安装ROS依赖" class="headerlink" title="④ 安装ROS依赖"></a>④ 安装ROS依赖</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rosdep update</span><br><span class="line">$ rosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO</span><br></pre></td></tr></table></figure><h5 id="⑤-编译环境"><a href="#⑤-编译环境" class="headerlink" title="⑤ 编译环境"></a>⑤ 编译环境</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ AUTOWARE_COMPILE_WITH_CUDA=1 colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release</span><br></pre></td></tr></table></figure><h3 id="1-4-参考文献"><a href="#1-4-参考文献" class="headerlink" title="1.4    参考文献"></a>1.4 参考文献</h3><p>[1] Autoware Foundation. Autoware-Documentation[DB&#x2F;OL]. [2023-02-13]. <a target="_blank" rel="noopener" href="https://autowarefoundation.github.io/autoware-documentation/main/">https://autowarefoundation.github.io/autoware-documentation/main/</a>.</p><p>[2] Github-Computing Platforms Federated Laboratory. Autoware Manuals[DB&#x2F;OL]. [2020-05-02]. <a target="_blank" rel="noopener" href="https://github.com/CPFL/Autoware-Manuals">https://github.com/CPFL/Autoware-Manuals</a>.</p><p><span id="jump2.0"></span></p><h2 id="二、Autoware-感知模块解析"><a href="#二、Autoware-感知模块解析" class="headerlink" title="二、Autoware 感知模块解析"></a>二、Autoware 感知模块解析</h2><p>​ Autoware是一个完整、系统化的自动驾驶平台，其中，core_perception模块包含了视觉和点云感知处理算法的实现过程。本节以视觉感知算法YoloV3、voxel grid filter及ring ground filter点云处理算法为例简要介绍Autoware感知相关算法原理及代码实现过程，梳理相关框架及逻辑。</p><p><span id="jump2.1"></span></p><h3 id="2-1-基于Darknet的Yolov3图像识别"><a href="#2-1-基于Darknet的Yolov3图像识别" class="headerlink" title="2.1    基于Darknet的Yolov3图像识别"></a>2.1 基于Darknet的Yolov3图像识别</h3><p>​ Yolo的全称是You Only Look Once，指<strong>只需要</strong>浏览一次就可以识别出图中的物体的类别和位置。Yolo算法是一种<strong>one-stage</strong>的目标检测算法，与<strong>two-stage</strong>目标检测算法（如R-CNN系列）的主要区别在于<strong>two-stage</strong>算法需要先生成proposal(一个有可能包含待检物体的预选框)，然后进行细粒度的物体检测。而<strong>one-stage</strong>算法会直接在网络中提取特征来预测物体分类和位置。<strong>two-stage</strong>算法速度相对较慢但是准确率高，<strong>one-stage</strong>算法准确率没有<strong>two-stage</strong>算法高但是速度较快。</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/stage_diff.png" alt="stage_diff" style="zoom:67%"><p>​ Yolo系列算法将图片划分成若干个网格，再基于anchor机制生成先验框，只用一步就生成检测框，这种方法大大提升了算法的预测速度，YOLOv3的论文于2018年发表在CVPR上。整个框架可划分为3个部分：分别为Darknet-53结构(下图Backbone部分)、特征层融合结构(下图黄色梯形concat部分)、以及分类检测结构(下图未画出)。</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/yolo.png" alt="yolo"></p><p>​ 从网络结构的输入说起，给一张图像，输入到Darkenet-53网络结构，进行一系列的卷积以及残差网络，分别得到原图像1&#x2F;8、1&#x2F;16、1&#x2F;32的特征图（即feature map），这个过程就是所谓的特征提取过程。在上图也可以看到经过Darkenet-53网络之后有3个分支，分别对应的就是3个不同尺寸的feature map。划分不同尺寸的feature map特征图，是为了让YOLO算法能适应不同大小目标的检测；比如：19×19×255的特征图，其一个特征点就对应原图大小为32×32（608&#x2F;19&#x3D;32）的块的检测，适合于大目标的检测；而76×76×255的特征图，其一个特征点对应原图大小为8×8（608&#x2F;76）的块的检测。适合与小目标的检测，同理38×38×255适合于中目标的检测。但由于提取的这些特征有时不能充分的反应原图中的目标信息。所以接下来需要将3个特征图进行特征融合，以获得更强的特征表现力，从而达到更好的效果；其中由于尺寸不一样，中间需要进行上采样以及下采样（其实就是卷积），使特征图变成相同大小，然后进行堆叠、融合及相应的卷积等操作后，得到最终的3个特征层，即上图中的19×19×255（Y1）、38×38×255（Y2）、76×76×255（Y3），这3个特征图恰好分别为原图像x的1&#x2F;32、1&#x2F;16、1&#x2F;8。</p><h4 id="2-1-1-依赖项"><a href="#2-1-1-依赖项" class="headerlink" title="2.1.1    依赖项"></a>2.1.1 依赖项</h4><ul><li>NVIDIA GPU 驱动、 CUDA</li><li>基于COCO数据集预训练的<a target="_blank" rel="noopener" href="https://pjreddie.com/media/files/yolov3.weights">YOLOv3</a>权重文件<br>详情见 : <a target="_blank" rel="noopener" href="https://pjreddie.com/darknet/yolo/">YOLO website</a>.</li><li>weights文件需放置在 <code>vision_darknet_detect/darknet/data/</code> 目录下</li></ul><h4 id="2-1-2-程序路径"><a href="#2-1-2-程序路径" class="headerlink" title="2.1.2    程序路径"></a>2.1.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/vision_darknet_detect/src/vision_darknet_detect.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">//launch文件路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/vision_darknet_detect/launch/vision_yolo3_detect.launch</span><br><span class="line"></span><br><span class="line"><span class="comment">//训练names文件</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/cfg/coco.names</span><br></pre></td></tr></table></figure><h4 id="2-1-3-启动方法"><a href="#2-1-3-启动方法" class="headerlink" title="2.1.3    启动方法"></a>2.1.3 启动方法</h4><ul><li><p>终端启动:</p><ul><li><code>roslaunch vision_darknet_detect vision_yolo3_detect.launch</code></li></ul></li><li><p>从Runtime Manager启动:</p></li></ul><p>​ 打开Runtime Manager，上方Computing 选项卡 -&gt; Detection&#x2F; vision_detector -&gt; <code>vision_darknet_detect</code>，单击 [app] 按钮可更改设置和文件路径等参数。</p><h4 id="2-1-4-参数详情"><a href="#2-1-4-参数详情" class="headerlink" title="2.1.4    参数详情"></a>2.1.4 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>score_threshold</code></td><td><em>Double</em></td><td>Detections with a confidence value larger than this value will be displayed. Default <code>0.5</code>.</td></tr><tr><td><code>nms_threshold</code></td><td><em>Double</em></td><td>Non-Maximum suppresion area threshold ratio to merge proposals. Default <code>0.45</code>.</td></tr><tr><td><code>network_definition_file</code></td><td><em>String</em></td><td>Network architecture definition configuration file. Default <code>yolov3.cfg</code>.</td></tr><tr><td><code>pretrained_model_file</code></td><td><em>String</em></td><td>Path to pretrained model. Default <code>yolov3.weights</code>.</td></tr><tr><td><code>camera_id</code></td><td><em>String</em></td><td>Camera workspace. Default <code>/</code>.</td></tr><tr><td><code>image_src</code></td><td><em>String</em></td><td>Image source topic. Default <code>/image_raw</code>.</td></tr><tr><td><code>names_file</code></td><td><em>String</em></td><td>Path to pretrained model. Default <code>coco.names</code>.</td></tr></tbody></table><h4 id="2-1-5-订阅话题名"><a href="#2-1-5-订阅话题名" class="headerlink" title="2.1.5    订阅话题名"></a>2.1.5 订阅话题名</h4><table><thead><tr><th>Topic</th><th>消息类型</th><th>说明</th></tr></thead><tbody><tr><td><code>/image_raw</code></td><td><code>sensor_msgs/Image</code></td><td>要检测的原始图像流</td></tr><tr><td><code>/config/Yolo3</code></td><td><code>autoware_config_msgs/ConfigSSD</code></td><td>阈值的配置调整参数</td></tr></tbody></table><h4 id="2-1-6-发布话题名"><a href="#2-1-6-发布话题名" class="headerlink" title="2.1.6    发布话题名"></a>2.1.6 发布话题名</h4><table><thead><tr><th>Topic</th><th>消息类型</th><th>说明</th></tr></thead><tbody><tr><td><code>/detection/vision_objects</code></td><td><code>autoware_msgs::DetectedObjectArray</code></td><td>检测到对象的边界框坐标</td></tr></tbody></table><h4 id="2-1-7-代码注解"><a href="#2-1-7-代码注解" class="headerlink" title="2.1.7    代码注解"></a>2.1.7 代码注解</h4><h5 id="①-Yolo3DetectorNode类"><a href="#①-Yolo3DetectorNode类" class="headerlink" title="① Yolo3DetectorNode类"></a>① Yolo3DetectorNode类</h5><p>​ 声明了ROS相关节点及参数类型，定义目标检测所需关键方法。最后在公有域中执行Run。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Yolo3DetectorNode</span> &#123;</span><br><span class="line">    <span class="comment">//定义ROS中相应节点</span></span><br><span class="line">    ros::Subscriber      subscriber_image_raw_;</span><br><span class="line">    ros::Subscriber      subscriber_yolo_config_;</span><br><span class="line">    ros::Publisher       publisher_objects_;</span><br><span class="line">    ros::NodeHandle      node_handle_;</span><br><span class="line">    <span class="comment">//定义类方法Yolo3Detector</span></span><br><span class="line">    darknet::Yolo3Detector     yolo_detector_;</span><br><span class="line">    image darknet_image_ = &#123;&#125;;</span><br><span class="line">    <span class="comment">//定义参数类型</span></span><br><span class="line">    <span class="type">float</span>     score_threshold_;</span><br><span class="line">    <span class="type">float</span>     nms_threshold_;</span><br><span class="line">    <span class="type">double</span>    image_ratio_;</span><br><span class="line">    <span class="type">uint32_t</span>  image_top_bottom_border_;</span><br><span class="line">    <span class="type">uint32_t</span>  image_left_right_border_;</span><br><span class="line">    std::vector&lt;cv::Scalar&gt;    colors_;</span><br><span class="line">    std::vector&lt;std::string&gt;   custom_names_;</span><br><span class="line">    <span class="type">bool</span>      use_coco_names_;</span><br><span class="line">    <span class="comment">//定义目标检测中所使用的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span>      <span class="title">convert_rect_to_image_obj</span><span class="params">(std::vector&lt; RectClassScore&lt;<span class="type">float</span>&gt; &gt;&amp; in_objects,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      autoware_msgs::DetectedObjectArray&amp; out_message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>      <span class="title">rgbgr_image</span><span class="params">(image&amp; im)</span></span>;</span><br><span class="line">    <span class="function">image     <span class="title">convert_ipl_to_image</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>      <span class="title">image_callback</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr&amp; in_image_message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>      <span class="title">config_cb</span><span class="params">(<span class="type">const</span> autoware_config_msgs::ConfigSSD::ConstPtr&amp; param)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt;     <span class="title">read_custom_names_file</span><span class="params">(<span class="type">const</span> std::string&amp; in_path)</span></span>;</span><br><span class="line"><span class="comment">//公有化参数域</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="②-convert-rect-to-image-obj函数"><a href="#②-convert-rect-to-image-obj函数" class="headerlink" title="② convert_rect_to_image_obj函数"></a>② convert_rect_to_image_obj函数</h5><p>​ 对矩形框预测结果进行处理，包括坐标值转换、目标类别标签获取等，然后发布检测结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Yolo3DetectorNode::convert_rect_to_image_obj</span><span class="params">(std::vector&lt; RectClassScore&lt;<span class="type">float</span>&gt; &gt;&amp; in_objects, autoware_msgs::DetectedObjectArray&amp; out_message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; in_objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            autoware_msgs::DetectedObject obj;</span><br><span class="line">            <span class="comment">//yolov3检测算法中对目标矩形框四个坐标值的处理</span></span><br><span class="line">            obj.x = (in_objects[i].x /image_ratio_) - image_left_right_border_/image_ratio_;</span><br><span class="line">            obj.y = (in_objects[i].y /image_ratio_) - image_top_bottom_border_/image_ratio_;</span><br><span class="line">            obj.width = in_objects[i].w /image_ratio_;</span><br><span class="line">            obj.height = in_objects[i].h /image_ratio_;</span><br><span class="line">            <span class="keyword">if</span> (in_objects[i].x &lt; <span class="number">0</span>)</span><br><span class="line">                obj.x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (in_objects[i].y &lt; <span class="number">0</span>)</span><br><span class="line">                obj.y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (in_objects[i].w &lt; <span class="number">0</span>)</span><br><span class="line">                obj.width = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (in_objects[i].h &lt; <span class="number">0</span>)</span><br><span class="line">                obj.height = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//目标类型分数</span></span><br><span class="line">            obj.score = in_objects[i].score;</span><br><span class="line">            <span class="comment">//使用Coco数据集时，将检测结果与相应的类别标签对应</span></span><br><span class="line">            <span class="comment">//GetClassString()方法用于映射目标类别标签方法</span></span><br><span class="line">            <span class="keyword">if</span> (use_coco_names_)</span><br><span class="line">            &#123;</span><br><span class="line">                obj.label = in_objects[i].<span class="built_in">GetClassString</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (in_objects[i].class_type &lt; custom_names_.<span class="built_in">size</span>())</span><br><span class="line">                    obj.label = custom_names_[in_objects[i].class_type];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    obj.label = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            obj.valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//发送检测结果</span></span><br><span class="line">            out_message.objects.<span class="built_in">push_back</span>(obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③-rgbgr-image函数"><a href="#③-rgbgr-image函数" class="headerlink" title="③ rgbgr_image函数"></a>③ rgbgr_image函数</h5><p>​ rgbgr_image主要用于对输入图片进行通道变换处理，以适应网络的输入类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Yolo3DetectorNode::rgbgr_image</span><span class="params">(image&amp; im)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; im.w*im.h; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> swap = im.data[i];</span><br><span class="line">        im.data[i] = im.data[i+im.w*im.h*<span class="number">2</span>];</span><br><span class="line">        im.data[i+im.w*im.h*<span class="number">2</span>] = swap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-convert-ipl-to-image函数"><a href="#④-convert-ipl-to-image函数" class="headerlink" title="④ convert_ipl_to_image函数"></a>④ convert_ipl_to_image函数</h5><p>​ convert_ipl_to_image函数主要对输入图片的尺寸进行处理以适应网络输入大小。当图片尺寸与输入大小不符，计算比值并将其作为缩放因子对图片进行裁剪填充处理，最后进行归一化以提高网络训练的数值稳定性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">image <span class="title">Yolo3DetectorNode::convert_ipl_to_image</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cv_bridge定义opencv类型的cv_image</span></span><br><span class="line">    cv_bridge::CvImagePtr cv_image = cv_bridge::<span class="built_in">toCvCopy</span>(msg, <span class="string">&quot;bgr8&quot;</span>);</span><br><span class="line">    cv::Mat mat_image = cv_image-&gt;image;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> network_input_width = yolo_detector_.<span class="built_in">get_network_width</span>();</span><br><span class="line">    <span class="type">int</span> network_input_height = yolo_detector_.<span class="built_in">get_network_height</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> image_height = msg-&gt;height,</span><br><span class="line">            image_width = msg-&gt;width;</span><br><span class="line"></span><br><span class="line">    IplImage ipl_image;</span><br><span class="line">    cv::Mat final_mat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (network_input_width!=image_width</span><br><span class="line">        || network_input_height != image_height)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//网络输入和图像不符时，计算两者比值</span></span><br><span class="line">        image_ratio_ = (<span class="type">double</span> ) network_input_width /  (<span class="type">double</span>)mat_image.cols;</span><br><span class="line">        <span class="comment">//对图像进行resize，缩放因子为网络输入与图像的比值</span></span><br><span class="line">        cv::<span class="built_in">resize</span>(mat_image, final_mat, cv::<span class="built_in">Size</span>(), image_ratio_, image_ratio_);</span><br><span class="line">        <span class="comment">//填充</span></span><br><span class="line">        image_top_bottom_border_ = <span class="built_in">abs</span>(final_mat.rows-network_input_height)/<span class="number">2</span>;</span><br><span class="line">        image_left_right_border_ = <span class="built_in">abs</span>(final_mat.cols-network_input_width)/<span class="number">2</span>;</span><br><span class="line">        cv::<span class="built_in">copyMakeBorder</span>(final_mat, final_mat,</span><br><span class="line">                           image_top_bottom_border_, image_top_bottom_border_,</span><br><span class="line">                           image_left_right_border_, image_left_right_border_,</span><br><span class="line">                           cv::BORDER_CONSTANT, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        final_mat = mat_image;</span><br><span class="line"></span><br><span class="line">    ipl_image = final_mat;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *data = (<span class="type">unsigned</span> <span class="type">char</span> *)ipl_image.imageData;</span><br><span class="line">    <span class="type">int</span> h = ipl_image.height;</span><br><span class="line">    <span class="type">int</span> w = ipl_image.width;</span><br><span class="line">    <span class="type">int</span> c = ipl_image.nChannels;</span><br><span class="line">    <span class="type">int</span> step = ipl_image.widthStep;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    image darknet_image = <span class="built_in">make_image</span>(w, h, c);</span><br><span class="line">    <span class="comment">//填充后的图像进行归一化</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; h; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k= <span class="number">0</span>; k &lt; c; ++k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; w; ++j)&#123;</span><br><span class="line">                darknet_image.data[k*w*h + i*w + j] = data[i*step + j*c + k]/<span class="number">255.</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rgbgr_image</span>(darknet_image);</span><br><span class="line">    <span class="keyword">return</span> darknet_image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑤-image-callback函数"><a href="#⑤-image-callback函数" class="headerlink" title="⑤ image_callback函数"></a>⑤ image_callback函数</h5><p>​ image_callback函数通过convert_ipl_to_image对图片预处理，然后利用convert_rect_to_image_obj将检测结果进一步转换为具体的目标信息并发布。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Yolo3DetectorNode::image_callback</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr&amp; in_image_message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt; RectClassScore&lt;<span class="type">float</span>&gt; &gt; detections;</span><br><span class="line">    <span class="comment">//调用convert_ipl_to_image对图片resize</span></span><br><span class="line">    darknet_image_ = <span class="built_in">convert_ipl_to_image</span>(in_image_message);</span><br><span class="line">    <span class="comment">//以resize后的图像作为yolov3检测器的输入</span></span><br><span class="line">    detections = yolo_detector_.<span class="built_in">detect</span>(darknet_image_);</span><br><span class="line">    autoware_msgs::DetectedObjectArray output_message;</span><br><span class="line">    output_message.header = in_image_message-&gt;header;</span><br><span class="line">    <span class="comment">//调用convert_rect_to_image_obj()将检测结果转换为相应的目标信息</span></span><br><span class="line">    <span class="built_in">convert_rect_to_image_obj</span>(detections, output_message);</span><br><span class="line">    <span class="comment">//发布检测结果</span></span><br><span class="line">    publisher_objects_.<span class="built_in">publish</span>(output_message);</span><br><span class="line">    <span class="built_in">free</span>(darknet_image_.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑥-read-custom-names-file函数"><a href="#⑥-read-custom-names-file函数" class="headerlink" title="⑥ read_custom_names_file函数"></a>⑥ read_custom_names_file函数</h5><p>​ read_custom_names_file函数主要用于获取文件路径、文件名等信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">Yolo3DetectorNode::read_custom_names_file</span><span class="params">(<span class="type">const</span> std::string&amp; in_names_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//文件路径</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(in_names_path)</span></span>;</span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="comment">//文件名</span></span><br><span class="line">    std::vector&lt;std::string&gt; names;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, str))</span><br><span class="line">    &#123;</span><br><span class="line">        names.<span class="built_in">push_back</span>(str);</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt;  std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑦-Run函数"><a href="#⑦-Run函数" class="headerlink" title="⑦ Run函数"></a>⑦ Run函数</h5><p>​ 首先声明了ROS函数命名空间，并通过节点名判断来接受相应的参数信息，然后调用yolo_detector检测器通过配置文件、预训练模型文件、像素均值等参数来初始化yolov3模型进行目标检测。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Yolo3DetectorNode::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ROS构造函数指定命名空间</span></span><br><span class="line">    <span class="function">ros::NodeHandle <span class="title">private_node_handle</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//声明标准字符变量接受图片</span></span><br><span class="line">    std::string image_raw_topic_str;</span><br><span class="line">    <span class="keyword">if</span> (private_node_handle.<span class="built_in">getParam</span>(<span class="string">&quot;image_raw_node&quot;</span>, image_raw_topic_str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Setting image node to %s&quot;</span>, image_raw_topic_str.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC&quot;</span>);</span><br><span class="line">        image_raw_topic_str = <span class="string">&quot;/image_raw&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明标准字符变量，接收网络配置文件</span></span><br><span class="line">    std::string network_definition_file;</span><br><span class="line">    <span class="comment">//声明标准字符变量，接收预训练模型文件</span></span><br><span class="line">    std::string pretrained_model_file, names_file;</span><br><span class="line">    <span class="comment">//判断是否有网络配置文件节点名</span></span><br><span class="line">    <span class="keyword">if</span> (private_node_handle.<span class="built_in">getParam</span>(<span class="string">&quot;network_definition_file&quot;</span>, network_definition_file))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Network Definition File (Config): %s&quot;</span>, network_definition_file.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;No Network Definition File was received. Finishing execution.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否有预训练模型节点名</span></span><br><span class="line">    <span class="keyword">if</span> (private_node_handle.<span class="built_in">getParam</span>(<span class="string">&quot;pretrained_model_file&quot;</span>, pretrained_model_file))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Pretrained Model File (Weights): %s&quot;</span>, pretrained_model_file.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;No Pretrained Model File was received. Finishing execution.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (private_node_handle.<span class="built_in">getParam</span>(<span class="string">&quot;names_file&quot;</span>, names_file))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Names File: %s&quot;</span>, names_file.<span class="built_in">c_str</span>());</span><br><span class="line">        use_coco_names_ = <span class="literal">false</span>;</span><br><span class="line">        custom_names_ = <span class="built_in">read_custom_names_file</span>(names_file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;No Names file was received. Using default COCO names.&quot;</span>);</span><br><span class="line">        use_coco_names_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义私有节点参数score_threshold，阈值为0.5</span></span><br><span class="line">    private_node_handle.<span class="built_in">param</span>&lt;<span class="type">float</span>&gt;(<span class="string">&quot;score_threshold&quot;</span>, score_threshold_, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;[%s] score_threshold: %f&quot;</span>,__APP_NAME__, score_threshold_);</span><br><span class="line">    <span class="comment">//定义私有节点参数nms_threshold，阈值为0.45</span></span><br><span class="line">    private_node_handle.<span class="built_in">param</span>&lt;<span class="type">float</span>&gt;(<span class="string">&quot;nms_threshold&quot;</span>, nms_threshold_, <span class="number">0.45</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;[%s] nms_threshold: %f&quot;</span>,__APP_NAME__, nms_threshold_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用yolo_detector_函数，初始化模型</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Initializing Yolo on Darknet...&quot;</span>);</span><br><span class="line">    yolo_detector_.<span class="built_in">load</span>(network_definition_file, pretrained_model_file, score_threshold_, nms_threshold_);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Initialization complete.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (CV_MAJOR_VERSION &lt;= 2)</span></span><br><span class="line">        cv::<span class="built_in">generateColors</span>(colors_, <span class="number">80</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">generateColors</span>(colors_, <span class="number">80</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    publisher_objects_ = node_handle_.<span class="built_in">advertise</span>&lt;autoware_msgs::DetectedObjectArray&gt;(<span class="string">&quot;/detection/image_detector/objects&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subscribing to... %s&quot;</span>, image_raw_topic_str.<span class="built_in">c_str</span>());</span><br><span class="line">    subscriber_image_raw_ = node_handle_.<span class="built_in">subscribe</span>(image_raw_topic_str, <span class="number">1</span>, &amp;Yolo3DetectorNode::image_callback, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">config_topic</span><span class="params">(<span class="string">&quot;/config&quot;</span>)</span></span>;</span><br><span class="line">    config_topic += <span class="string">&quot;/Yolo3&quot;</span>;</span><br><span class="line">    subscriber_yolo_config_ = node_handle_.<span class="built_in">subscribe</span>(config_topic, <span class="number">1</span>, &amp;Yolo3DetectorNode::config_cb, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ROS_INFO_STREAM</span>( __APP_NAME__ &lt;&lt; <span class="string">&quot;&quot;</span> );</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;END Yolo&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump2.2"></span></p><h3 id="2-2-voxel-grid-filter点云降采样程序注解"><a href="#2-2-voxel-grid-filter点云降采样程序注解" class="headerlink" title="2.2    voxel_grid_filter点云降采样程序注解"></a>2.2 voxel_grid_filter点云降采样程序注解</h3><h4 id="2-2-1-启动方法"><a href="#2-2-1-启动方法" class="headerlink" title="2.2.1    启动方法"></a>2.2.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li><code>roslaunch points_downsampler points_downsample.launch</code></li></ul></li><li><p>从Runtime Manager启动:</p></li></ul><p>​ 打开Runtime Manager，上方Sensing 选项卡 -&gt; Points Downsampler -&gt; <code>voxel_grid_filter</code>，单击 [app] 按钮可更改设置等参数。</p><h4 id="2-2-2-点云消息数据结构"><a href="#2-2-2-点云消息数据结构" class="headerlink" title="2.2.2    点云消息数据结构"></a>2.2.2 点云消息数据结构</h4><p>激光雷达雷达坐标系名称：<code>velodyne</code> 点云话题名：<code>/points_raw</code></p><p>消息类型为<code>sensor_msgs/PointCloud2</code>，下面为消息类型的详细介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">header:         <span class="comment">// 点云头</span></span><br><span class="line">  seq:          <span class="comment">// 序列号</span></span><br><span class="line">  stamp:        <span class="comment">// 话题时间戳</span></span><br><span class="line">  frame_id:     <span class="comment">// 点云坐标系名称</span></span><br><span class="line">height:         <span class="comment">// 点云的二维结构。如果云是无序的，则高度为1，宽度为点云的长度。</span></span><br><span class="line">width:          <span class="comment">// 点云的长度</span></span><br><span class="line">fields:         <span class="comment">// 描述二进制数据blob中的通道及其布局。</span></span><br><span class="line">is_bigendian:   <span class="comment">// 数据存储方式，包括大端与小端</span></span><br><span class="line">point_step:     <span class="comment">// 一个点占的字节数 </span></span><br><span class="line">row_step:       <span class="comment">// 一行的长度占用的字节数</span></span><br><span class="line">data:[]         <span class="comment">// 点云数据</span></span><br><span class="line">is_dense:       <span class="comment">// 有没有非法数据点</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-程序路径"><a href="#2-2-3-程序路径" class="headerlink" title="2.2.3    程序路径"></a>2.2.3 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">// launch启动文件路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/points_downsampler/launch/points_downsample.launch</span><br></pre></td></tr></table></figure><h4 id="2-2-4-参数详情"><a href="#2-2-4-参数详情" class="headerlink" title="2.2.4    参数详情"></a>2.2.4 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>voxel_leaf_size</code></td><td><em>int</em></td><td>滤波器处理时采用的体素大小</td></tr><tr><td><code>measurement_range</code></td><td><em>double</em></td><td>测量距离</td></tr><tr><td><code>output_log</code></td><td><em>bool</em></td><td>是否输出log</td></tr><tr><td><code>points_topic</code></td><td><em>string</em></td><td>点云接收话题名</td></tr></tbody></table><h4 id="2-2-5-订阅话题名"><a href="#2-2-5-订阅话题名" class="headerlink" title="2.2.5    订阅话题名"></a>2.2.5 订阅话题名</h4><table><thead><tr><th>话题名</th><th>消息类型</th></tr></thead><tbody><tr><td><code>/config/voxel_grid_filter</code></td><td><code>autoware_config_msgs/ConfigVoxelGridFilter</code></td></tr><tr><td><code>/points_raw</code></td><td><code>sensor_msgs/PointCloud2</code></td></tr></tbody></table><h4 id="2-2-6-发布话题名"><a href="#2-2-6-发布话题名" class="headerlink" title="2.2.6    发布话题名"></a>2.2.6 发布话题名</h4><table><thead><tr><th>话题名</th><th>消息类型</th></tr></thead><tbody><tr><td><code>/filtered_points</code></td><td><code>sensor_msgs::PointCloud2</code></td></tr><tr><td><code>/points_downsampler_info</code></td><td><code>points_downsampler::PointsDownsamplerInfo</code></td></tr></tbody></table><h4 id="2-2-7-代码注解"><a href="#2-2-7-代码注解" class="headerlink" title="2.2.7    代码注解"></a>2.2.7 代码注解</h4><h5 id="①-main函数"><a href="#①-main函数" class="headerlink" title="① main函数"></a>① main函数</h5><p>​ main函数主要初始化ROS，订阅点云及参数信息，初始化发布者。使用体素化网格方法实现降采样，即减少点的数量，减少点云数据，并同时保持点云的形状特征，在提高配准、曲面重建、形状识别等算法速度中非常实用。PCL实现的VoxelGrid类通过输入的点云数据创建一个三维体素栅格（可把体素栅格想象为微小的空间三维立方体的集合），然后在每个体素（即 三维立方体）内，用体素中所有点的重心来近似显示体素中其他点，这样该体素就内所有点就用一个重心点最终表示，对于所有体素处理后得到过滤后的点云。这种方法比用体素中心来逼近的方法更慢，但它对于采样点对应曲面的表示更为准确。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;voxel_grid_filter&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="function">ros::NodeHandle <span class="title">private_nh</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">  <span class="comment">//参数服务器获取激光点云topic以及是否输出log</span></span><br><span class="line">  private_nh.<span class="built_in">getParam</span>(<span class="string">&quot;points_topic&quot;</span>, POINTS_TOPIC);</span><br><span class="line">  private_nh.<span class="built_in">getParam</span>(<span class="string">&quot;output_log&quot;</span>, _output_log);</span><br><span class="line">  <span class="comment">//输出log</span></span><br><span class="line">  <span class="keyword">if</span>(_output_log == <span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line">    std::<span class="type">time_t</span> now = std::<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    std::tm *pnow = std::<span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">    std::<span class="built_in">strftime</span>(buffer,<span class="number">80</span>,<span class="string">&quot;%Y%m%d_%H%M%S&quot;</span>,pnow);</span><br><span class="line">    filename = <span class="string">&quot;voxel_grid_filter_&quot;</span> + std::<span class="built_in">string</span>(buffer) + <span class="string">&quot;.csv&quot;</span>;</span><br><span class="line">    ofs.<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), std::ios::app);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//参数服务器获取激光测量距离参数</span></span><br><span class="line">  private_nh.<span class="built_in">param</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;measurement_range&quot;</span>, measurement_range, MAX_MEASUREMENT_RANGE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布降采样点云、info</span></span><br><span class="line">  filtered_points_pub = nh.<span class="built_in">advertise</span>&lt;sensor_msgs::PointCloud2&gt;(<span class="string">&quot;/filtered_points&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  points_downsampler_info_pub = nh.<span class="built_in">advertise</span>&lt;points_downsampler::PointsDownsamplerInfo&gt;(<span class="string">&quot;/points_downsampler_info&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅config、点云话题</span></span><br><span class="line">  ros::Subscriber config_sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;config/voxel_grid_filter&quot;</span>, <span class="number">10</span>, config_callback);</span><br><span class="line">  ros::Subscriber scan_sub = nh.<span class="built_in">subscribe</span>(POINTS_TOPIC, <span class="number">10</span>, scan_callback);</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-config-callback函数"><a href="#②-config-callback函数" class="headerlink" title="② config_callback函数"></a>② config_callback函数</h5><p>​ config_callback 回调函数的参数为降采样参数消息(autoware_config_msgs::ConfigVoxelGridFilter.msg）。此处接收降采样参数及测量距离范围信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">config_callback</span><span class="params">(<span class="type">const</span> autoware_config_msgs::ConfigVoxelGridFilter::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  voxel_leaf_size = input-&gt;voxel_leaf_size;</span><br><span class="line">  measurement_range = input-&gt;measurement_range;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③-scan-callback函数"><a href="#③-scan-callback函数" class="headerlink" title="③ scan_callback函数"></a>③ scan_callback函数</h5><p>​ scan_callback函数接收激光雷达sensor_msgs::PointCloud2类型消息，并对点云进行降采样处理。</p><p>​ PCL点云降采样库详情请见：<a target="_blank" rel="noopener" href="https://docs.ros.org/en/hydro/api/pcl/html/classpcl_1_1VoxelGrid.html">pcl::VoxelGrid<a href="pcl::PointXYZI">pcl::PointXYZI</a>官方文档web</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">scan_callback</span><span class="params">(<span class="type">const</span> sensor_msgs::PointCloud2::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 声明pcl::PointCloud&lt;pcl::PointXYZI&gt;类型的点云数据用来储存接收到的点云</span></span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;</span><br><span class="line">  <span class="comment">// 点云类型转换sensor_msgs::PointCloud2 -&gt; pcl::PointCloud&lt;pcl::PointXYZI&gt;</span></span><br><span class="line">  pcl::<span class="built_in">fromROSMsg</span>(*input, scan);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断要使用的激光点距离是否超限，并移除超限的激光点</span></span><br><span class="line">  <span class="keyword">if</span>(measurement_range != MAX_MEASUREMENT_RANGE)&#123;</span><br><span class="line">    scan = <span class="built_in">removePointsByRange</span>(scan, <span class="number">0</span>, measurement_range);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">scan_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan))</span></span>;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">filtered_scan_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">  sensor_msgs::PointCloud2 filtered_msg;</span><br><span class="line"></span><br><span class="line">  filter_start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若voxel_leaf_size &lt; 0.1，voxel_grid_filter无法完成降采样(PCL规范)</span></span><br><span class="line">  <span class="keyword">if</span> (voxel_leaf_size &gt;= <span class="number">0.1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 使用VoxelGrid滤波器对点云进行降采样 </span></span><br><span class="line">    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;</span><br><span class="line">    voxel_grid_filter.<span class="built_in">setLeafSize</span>(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);</span><br><span class="line">    voxel_grid_filter.<span class="built_in">setInputCloud</span>(scan_ptr);</span><br><span class="line">    voxel_grid_filter.<span class="built_in">filter</span>(*filtered_scan_ptr);</span><br><span class="line">    pcl::<span class="built_in">toROSMsg</span>(*filtered_scan_ptr, filtered_msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="comment">// 若设置的voxel_leaf_size&lt;0.1，无法降采样，直接输出原始点云</span></span><br><span class="line">  &#123;</span><br><span class="line">    pcl::<span class="built_in">toROSMsg</span>(*scan_ptr, filtered_msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录降采样结束时间</span></span><br><span class="line">  filter_end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="comment">// 发布filtered_msg降采样后点云消息</span></span><br><span class="line">  filtered_msg.header = input-&gt;header;</span><br><span class="line">  filtered_points_pub.<span class="built_in">publish</span>(filtered_msg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布points_downsampler_info_msg降采样info消息</span></span><br><span class="line">  points_downsampler_info_msg.header = input-&gt;header;</span><br><span class="line">  <span class="comment">//...（下略）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump2.3"></span></p><h3 id="2-3-ring-ground-filter地面点云去除程序注解"><a href="#2-3-ring-ground-filter地面点云去除程序注解" class="headerlink" title="2.3    ring_ground_filter地面点云去除程序注解"></a>2.3 ring_ground_filter地面点云去除程序注解</h3><h4 id="2-3-1-启动方法"><a href="#2-3-1-启动方法" class="headerlink" title="2.3.1    启动方法"></a>2.3.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li><code>roslaunch points_preprocessor ring_ground_filter.launch</code></li></ul></li><li><p>从Runtime Manager启动:</p></li></ul><p>​ 打开Runtime Manager，上方Sensing 选项卡 -&gt; Points Preprocessor -&gt; <code>ring_ground_filter</code>，单击 [app] 按钮可更改设置等参数。</p><h4 id="2-3-2-程序路径"><a href="#2-3-2-程序路径" class="headerlink" title="2.3.2    程序路径"></a>2.3.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/ring_ground_filter/ring_ground_filter.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">// launch启动文件路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ring_ground_filter.launch</span><br></pre></td></tr></table></figure><h4 id="2-3-3-参数详情"><a href="#2-3-3-参数详情" class="headerlink" title="2.3.3    参数详情"></a>2.3.3 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>point_topic</code></td><td><em>string</em></td><td>点云接收话题名</td></tr><tr><td><code>remove_floor</code></td><td><em>bool</em></td><td>是否移除地面</td></tr><tr><td><code>sensor_model</code></td><td><em>int</em></td><td>激光雷达发射线束数量(16,32,64)</td></tr><tr><td><code>sensor_height</code></td><td><em>double</em></td><td>激光雷达安装高度</td></tr><tr><td><code>max_slope</code></td><td><em>double</em></td><td>环境地面最大坡度</td></tr><tr><td><code>vertical_thres</code></td><td><em>double</em></td><td>障碍物和地面的差异度，大于这个值则被认为是障碍</td></tr></tbody></table><h4 id="2-3-4-订阅话题名"><a href="#2-3-4-订阅话题名" class="headerlink" title="2.3.4    订阅话题名"></a>2.3.4 订阅话题名</h4><table><thead><tr><th>话题名</th><th>消息类型</th></tr></thead><tbody><tr><td><code>/points_raw</code></td><td><code>sensor_msgs::PointCloud2</code></td></tr></tbody></table><h4 id="2-3-5-发布话题名"><a href="#2-3-5-发布话题名" class="headerlink" title="2.3.5    发布话题名"></a>2.3.5 发布话题名</h4><table><thead><tr><th>话题名</th><th>消息类型</th><th>说明</th></tr></thead><tbody><tr><td><code>/points_no_ground</code></td><td><code>sensor_msgs::PointCloud2</code></td><td>去除地面点云</td></tr><tr><td><code>/points_ground</code></td><td><code>sensor_msgs::PointCloud2</code></td><td>地面点云</td></tr></tbody></table><h4 id="2-3-6-代码注解"><a href="#2-3-6-代码注解" class="headerlink" title="2.3.6    代码注解"></a>2.3.6 代码注解</h4><h5 id="①-VelodyneCallback函数"><a href="#①-VelodyneCallback函数" class="headerlink" title="① VelodyneCallback函数"></a>① VelodyneCallback函数</h5><p>​ VelodyneCallback函数主要接收来自激光雷达的点云信息，将原始点云数据传给FilterGround函数处理，并发布处理好的地面点云、去除地面点云数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GroundFilter::VelodyneCallback</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 声明pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;类型的点云数据</span></span><br><span class="line">  pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; vertical_points;</span><br><span class="line">  pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; ground_points;</span><br><span class="line">  vertical_points.header = in_cloud_msg-&gt;header;</span><br><span class="line">  ground_points.header = in_cloud_msg-&gt;header;</span><br><span class="line">  <span class="comment">//初始化清空</span></span><br><span class="line">  vertical_points.<span class="built_in">clear</span>();</span><br><span class="line">  ground_points.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用FilterGround函数进行地面过滤</span></span><br><span class="line">  <span class="built_in">FilterGround</span>(in_cloud_msg, vertical_points, ground_points);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!floor_removal_)</span><br><span class="line">  &#123;</span><br><span class="line">    vertical_points = *in_cloud_msg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//发布处理完毕的点云</span></span><br><span class="line">  groundless_points_pub_.<span class="built_in">publish</span>(vertical_points);</span><br><span class="line">  ground_points_pub_.<span class="built_in">publish</span>(ground_points);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-FilterGround函数"><a href="#②-FilterGround函数" class="headerlink" title="② FilterGround函数"></a>② FilterGround函数</h5><p>​ FilterGround函数用于将VelodyneCallback传入的点云进行地面去除，并输出处理好的地面点云、去除地面点云数据。首先，将所有与点集具有相同水平角的点分组，然后逐点集进行计算。在每个点集中，此算法应用两步滤波器，该滤波器使用两个连续点的角度和距离来区分地面点云和垂直地面(障碍物)点云。</p><ul><li><p>(1) 基于角度的滤波器</p><p>​ 两步滤波器的第一步是基于角度的滤波器，若两个连续点的角度小于角度阈值，则将其添加进“候选组”，计算一直持续到角度大于阈值为止，然后检查“候选组”的大小。如果点数足够大，这一点集中的所有点都会被标记为地面点云。</p></li><li><p>(2) 基于距离的滤波器</p><p>​ 通过比较连续点与动态阈值之间的距离来过滤上一步的其余点。如果这些点彼此足够接近，则将其标记为垂直地面的点云(障碍物点云)，其余的点被标记为地面点云。</p><p>算法具体流程图及伪代码请见：<a target="_blank" rel="noopener" href="https://github.com/CPFL/Autoware-Manuals/blob/master/en/pdfs/ground_filter.pdf">round_filter介绍pdf</a></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GroundFilter::FilterGround</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">      pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,</span></span></span><br><span class="line"><span class="params"><span class="function">      pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  velodyne_pointcloud::PointXYZIR point;</span><br><span class="line">  <span class="built_in">InitDepthMap</span>(horizontal_res_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算点云集中每个点的角度，并使每个激光点对应到列表中的行和列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; in_cloud_msg-&gt;points.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">double</span> u = <span class="built_in">atan2</span>(in_cloud_msg-&gt;points[i].y,in_cloud_msg-&gt;points[i].x) * <span class="number">180</span>/M_PI;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span>) &#123; u = <span class="number">360</span> + u; &#125;</span><br><span class="line">    <span class="type">int</span> column = horizontal_res_ - (<span class="type">int</span>)((<span class="type">double</span>)horizontal_res_ * u / <span class="number">360.0</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> row = vertical_res_ - <span class="number">1</span> - in_cloud_msg-&gt;points[i].ring;</span><br><span class="line">    index_map_.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(row, column) = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按每条激光线束上点的数量遍历(以16线雷达为例，每条环形线有1000个激光点)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; horizontal_res_; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    Label point_class[vertical_res_];</span><br><span class="line">    <span class="type">int</span> point_index[vertical_res_];</span><br><span class="line">    <span class="type">int</span> point_index_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> z_max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> z_min = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> r_ref = <span class="number">0</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(class_label_, class_label_ + vertical_res_, point_class);</span><br><span class="line">    <span class="comment">// 按激光线束ID遍历每线激光</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertical_res_; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 如果存在列表中(j,i)这个点，且此点没有被分类到任何一个点云集</span></span><br><span class="line">      <span class="keyword">if</span> (index_map_.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(j,i) &gt; <span class="number">-1</span> &amp;&amp; point_class[j] == UNKNOWN)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 读取每点xyz坐标</span></span><br><span class="line">        <span class="type">double</span> x0 = in_cloud_msg-&gt;points[index_map_.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(j, i)].x;</span><br><span class="line">        <span class="type">double</span> y0 = in_cloud_msg-&gt;points[index_map_.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(j, i)].y;</span><br><span class="line">        <span class="type">double</span> z0 = in_cloud_msg-&gt;points[index_map_.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(j, i)].z;</span><br><span class="line">        <span class="comment">// 计算该点距离</span></span><br><span class="line">        <span class="type">double</span> r0 = <span class="built_in">sqrt</span>(x0*x0 + y0*y0);</span><br><span class="line">        <span class="type">double</span> r_diff = <span class="built_in">fabs</span>(r0 - r_ref);</span><br><span class="line">        <span class="keyword">if</span> (r_diff &lt; radius_table_[j] || r_ref == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          r_ref = r0;</span><br><span class="line">          <span class="keyword">if</span> (z0 &gt; z_max || r_ref == <span class="number">0</span>) z_max = z0;</span><br><span class="line">          <span class="keyword">if</span> (z0 &lt; z_min || r_ref == <span class="number">0</span>) z_min = z0;</span><br><span class="line">          point_index[point_index_size] = j;</span><br><span class="line">          point_index_size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 判断点云集类型</span></span><br><span class="line">          <span class="keyword">if</span> (point_index_size &gt; <span class="number">1</span> &amp;&amp; (z_max - z_min) &gt; vertical_thres_)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 点云类型为非地面点云(障碍物)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; point_index_size; m++)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">//...(下略)</span></span><br><span class="line">              point_class[point_index[m]] = VERTICAL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置point_index_size</span></span><br><span class="line">            point_index_size = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">// 点云类型为地面点云</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; point_index_size; m++)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">//...(下略)</span></span><br><span class="line">              point_class[point_index[m]] = GROUND;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置point_index_size</span></span><br><span class="line">            point_index_size = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          r_ref = r0;</span><br><span class="line">          z_max = z0;</span><br><span class="line">          z_min = z0;</span><br><span class="line">          point_index[point_index_size] = j;</span><br><span class="line">          point_index_size++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断剩余的点云</span></span><br><span class="line">      <span class="keyword">if</span> (j == vertical_res_ - <span class="number">1</span> &amp;&amp; point_index_size != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 点云类型为非地面点云(障碍物)</span></span><br><span class="line">          <span class="keyword">if</span> (point_index_size &gt; <span class="number">1</span> &amp;&amp; (z_max - z_min) &gt; vertical_thres_)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; point_index_size; m++)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">//...(下略)</span></span><br><span class="line">              point_class[point_index[m]] = VERTICAL;</span><br><span class="line">            &#125;</span><br><span class="line">            point_index_size = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 点云类型为地面点云</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; point_index_size; m++)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">//...(下略)</span></span><br><span class="line">              point_class[point_index[m]] = GROUND;</span><br><span class="line">            &#125;</span><br><span class="line">            point_index_size = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-参考文献"><a href="#2-4-参考文献" class="headerlink" title="2.4    参考文献"></a>2.4 参考文献</h3><p>[1] YOLO: Real-Time Object Detection[OB&#x2F;OL].[2018-3-25]. <a target="_blank" rel="noopener" href="https://pjreddie.com/darknet/yolo/">https://pjreddie.com/darknet/yolo/</a>.</p><p>[2] Redmon J, Farhadi A. YOLOv3: An Incremental Improvement[J]. arXiv: Computer Vision and Pattern Recognition,2018.</p><p>[3] Redmon J, Farhadi A. YOLO9000: Better, faster and stronger[C]. Computer Vision and Patter Recognition, 2017: 6517-6525.</p><p>[4] Redmon J, Farhadi A. YOLOv3: An incremental improvement[J]. arXiv: Computer Vision and Pattern Recognition, 2018.</p><p>[5] Simon M, Milz S, Amende K, et al. Complex-YOLO: Real-time 3D object detection on point clouds[J]. arXiv: Computer Vision and Pattern Recognition, 2018.</p><p>[6] PCL VoxelGrid Class Template Reference[OB&#x2F;OL]. [2015-8-26]. <a target="_blank" rel="noopener" href="https://docs.ros.org/en/hydro/api/pcl/html/classpcl_1_1VoxelGrid.html">https://docs.ros.org/en/hydro/api/pcl/html/classpcl_1_1VoxelGrid.html</a>.</p><p>[7] Nagoya University. Ground Filter Method[OB&#x2F;OL]. [2017-8-4]. <a target="_blank" rel="noopener" href="https://github.com/CPFL/Autoware-Manuals/blob/master/en/pdfs/ground_filter.pdf">https://github.com/CPFL/Autoware-Manuals/blob/master/en/pdfs/ground_filter.pdf</a>.</p><p><span id="jump3.0"></span></p><h2 id="三、Autoware-定位模块解析"><a href="#三、Autoware-定位模块解析" class="headerlink" title="三、Autoware 定位模块解析"></a>三、Autoware 定位模块解析</h2><p>​ 自动驾驶车辆在行驶过程中需要为决策模块提供自身在车道上的精确位姿，精度一般需要达到厘米级别。目前主流的自动驾驶定位技术大致有三种，分别是基于GNSS定位、基于航迹推算的定位，以及基于环境特征匹配的定位方法。其中基于环境特征匹配的方法采用激光雷达获取点云数据，然后与地图中的点云数据进行特征匹配，实现精确定位。</p><p><span id="jump3.0.0"></span></p><h3 id="3-0-基础知识"><a href="#3-0-基础知识" class="headerlink" title="3.0    基础知识"></a>3.0 基础知识</h3><h4 id="3-0-1-三维空间描述与坐标变换"><a href="#3-0-1-三维空间描述与坐标变换" class="headerlink" title="3.0.1    三维空间描述与坐标变换"></a>3.0.1 三维空间描述与坐标变换</h4><p>​ 无人驾驶汽车在三维空间中运动与工作，为准确描述其在运动过程中车辆本身与相关传感器的相对位姿关系，需要建立包括车体自身在内的各个元器件所对应三维坐标系间的关系。</p><h5 id="1、位置描述"><a href="#1、位置描述" class="headerlink" title="1、位置描述"></a>1、位置描述</h5><p>​ 车辆在三维空间中运动时，我们首先对整个空间建立一个三维坐标系，即World坐标系。建立好之后我们可以用一个向量来表示车辆在World坐标系中的位置。车辆本身也同样建立一个固定在车体上的坐标系base_link，一般满足右手坐标系规则。</p><h5 id="2、姿态描述"><a href="#2、姿态描述" class="headerlink" title="2、姿态描述"></a>2、姿态描述</h5><p>​ 车辆在World坐标系中的位置确定之后，车辆与World之间的坐标原点的距离也随之确定。欲求得车辆的姿态，我们需要一个固定坐标系World，求出base_link相对于World坐标系的关系，使用旋转矩阵来表示。</p><p>​ 假设World坐标系的单位正交基底为 <strong><em>e1,e2,e3</em></strong> ，base_link坐标系的单位正交基底为 <strong><em>γ1,γ2,γ3</em></strong> ，两坐标系间存在旋转关系。那么对于同一个向量 <strong><em>α</em></strong> 在两坐标系下的坐标分别为 <strong><em>(α1,α2,α3)</em></strong> 和 <strong><em>(β1,β2,β3)</em></strong> ，此时有</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/4-matrix.svg" alt="math_NDT4" style="zoom:120%"><p>​ 等式两端同乘 <strong><em>[e1,e2,e3]</em></strong> 的转置矩阵得到</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/3-matrix.svg" alt="math_NDT3" style="zoom:120%"><p>​ 通过上述变换，得到旋转矩阵 <strong><em>R</em></strong> ，其描述了向量从base_link坐标系到World坐标系的旋转变换关系。</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/1-matrix.svg" alt="math_NDT2" style="zoom:120%"><h5 id="3、运动描述"><a href="#3、运动描述" class="headerlink" title="3、运动描述"></a>3、运动描述</h5><p>​ 我们一般用位姿来描述刚体的运动，此时我们通过变换矩阵 <strong><em>T</em></strong> 来表示位姿在坐标系之间的变换关系。 <strong><em>R</em></strong> 表示旋转矩阵，**<em>t</em>** 表示平移向量。所以向量 <strong><em>α</em></strong> 从base_link到World的转换关系可以由下式表示。</p><p>$$\begin{array}{c}<br>\boldsymbol{T}&#x3D;\left[\begin{array}{ll}<br>\boldsymbol{R} &amp; \boldsymbol{t} \<br>0 &amp; 1<br>\end{array}\right] \<br>{\left[\begin{array}{l}<br>\alpha_{1} \<br>\alpha_{2} \<br>\alpha_{3}<br>\end{array}\right]&#x3D;\boldsymbol{T}\left[\begin{array}{l}<br>\beta_{1} \<br>\beta_{2} \<br>\beta_{3}<br>\end{array}\right]}<br>\end{array}$$</p><h4 id="3-0-2-正态分布变换算法NDT"><a href="#3-0-2-正态分布变换算法NDT" class="headerlink" title="3.0.2    正态分布变换算法NDT"></a>3.0.2 正态分布变换算法NDT</h4><p>​ NDT，Normal Distributions Transform正态分布变换算法是一种统计学模型。如果一组随机向量满足正态分布，那么它的概率密度函数为：</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/math_NDT1.svg" alt="math_NDT1" style="zoom:120%"><p>​ 其中D表示维度，<img src="https://math.jianshu.com/math?formula=%5Cvec%20%5Cmu" alt="\vec \mu">表示均值向量，<img src="https://math.jianshu.com/math?formula=%5CSigma" alt="\Sigma">表示随机向量的协方差矩阵。由于扫描得到的激光点云数据点是三维空间点坐标，所以需要采用三维正态分布。NDT能够通过概率的形式描述点云的分部情况，这有利于减少配准所需要的时间。</p><p>​ 下面简要介绍一下NDT算法的主要流程。</p><h5 id="1、NDT算法的主要流程"><a href="#1、NDT算法的主要流程" class="headerlink" title="1、NDT算法的主要流程"></a>1、NDT算法的主要流程</h5><h6 id="①-栅格化目标点云"><a href="#①-栅格化目标点云" class="headerlink" title="① 栅格化目标点云"></a>① 栅格化目标点云</h6><p>​ 首先要将激光雷达收到的点云进行栅格化，点云配准一般是对两个点云数据进行两两配准，需要先固定一个点云数据，另外一个点云数据再通过旋转平移来和固定点云进行匹配拼接。这里的固定点云就是目标点云，平移旋转的点云就是源点云。栅格化目标点云主要是利用立方体将激光点云所在空间进行均匀划分，使得激光点处于相应的立方体中，这一步作为NDT算法的第一步非常重要。</p><h6 id="②-注册激光点云数据"><a href="#②-注册激光点云数据" class="headerlink" title="② 注册激光点云数据"></a>② 注册激光点云数据</h6><p>​ 在第一步栅格化完成后，将点云加载到网格内，计算均值向量<img src="https://math.jianshu.com/math?formula=%5Cvec%20%5Cmu" alt="\vec \mu">，其中<img src="https://math.jianshu.com/math?formula=%5Cvec%20y_%7Bk=1,2,3,...,m%7D" alt="\vec y_{k=1,2,3,...,m}">表示网格中所有扫描点的坐标。</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/math_ndt2.svg" alt="math_ndt2" style="zoom:120%"><p>​ 然后计算协方差矩阵并求出每个网格内的正态分布概率密度函数。需要注意，由于需要用到协方差矩阵的逆矩阵，所以每个网格中包含的激光点不可少于三个，一般至少要保证有五个点。</p><h6 id="③-求出源点云相对于目标点云的初始坐标变换参数"><a href="#③-求出源点云相对于目标点云的初始坐标变换参数" class="headerlink" title="③ 求出源点云相对于目标点云的初始坐标变换参数"></a>③ 求出源点云相对于目标点云的初始坐标变换参数</h6><p>​ 坐标变换通常涉及到平移与旋转，平移通过平移向量表示，旋转则可以通过旋转矩阵表示，旋转是关于自身zyx三个固定轴的旋转，转角分别用<strong>α、β、γ</strong>表示，分别与yaw，pitch，roll对应。通过计算旋转平移矩阵，可以得到同一个激光点云在这两个点云坐标系下的位置坐标变换关系。</p><p>​ 这一步是为了寻找一个合适的初始坐标变换使得源点云大致处于目标点云的坐标平面当中。这一步提供的变换参数的初值，为下一步变换参数的迭代提供距离最优点较近的初值。在自动驾驶里初始值的提供可以依靠GNSS、Odom或者IMU惯性导航，利用这些传感器获取车辆的当前位姿，通过坐标变换得到相对于目标点云的坐标变换参数，也就是旋转矩阵 <strong><em>R</em></strong> 和平移向量 <strong><em>t</em></strong> 。</p><h6 id="④-源点云进行初始坐标变换，并计算在目标点云网格中的概率"><a href="#④-源点云进行初始坐标变换，并计算在目标点云网格中的概率" class="headerlink" title="④ 源点云进行初始坐标变换，并计算在目标点云网格中的概率"></a>④ 源点云进行初始坐标变换，并计算在目标点云网格中的概率</h6><p>​ 源点云根据初始变换参数将坐标转换到目标点云中。此时源点云分布在目标点云网格中，转换后源点云的坐标X’由对应所在的网格的正态分布概率密度函数，求出激光点坐标为X‘的概率。将每个点的概率乘积起来作为目标似然函数。通过似然函数找到概率乘积最大时候的坐标转换关系。</p><p>​ 简单来说就是由最大的概率找到最优的坐标变换。</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/math_ndt3.svg" alt="math_ndt3" style="zoom:120%"><h6 id="⑤-高斯牛顿法进行优化，找出最佳变换参数p完成点云配准"><a href="#⑤-高斯牛顿法进行优化，找出最佳变换参数p完成点云配准" class="headerlink" title="⑤ 高斯牛顿法进行优化，找出最佳变换参数p完成点云配准"></a>⑤ 高斯牛顿法进行优化，找出最佳变换参数p完成点云配准</h6><h5 id="2、点云配准原理"><a href="#2、点云配准原理" class="headerlink" title="2、点云配准原理"></a>2、点云配准原理</h5><p>​ 在激光点云地图建图过程中，由于激光雷达扫描距离存在限制，一次扫描难以获取完整的目标环境，并且距离激光雷达越远，点云就会变得越稀疏，所以需要经过连续多次扫描，然后将每次扫描的点云数据进行配准拼接，最终才能形成连续完整的激光点云地图。</p><p>​ 从不同角度扫描同一场景所得到的的点云数据统一转换到同一坐标系的过程叫做<strong>点云配准</strong>。简单地说就是将离散的点云数据在统一的坐标系下拼接成一整个完整的点云数据。通常点云配准算法能够利用两个点集之间的最小距离或者利用统计学方法，得到两个点集之间的变换关系，使得点云达到变换配准的效果。问题关键在于如何得到激光点云之间的RT矩阵。通常可以直接利用PCL开源点云库来对相关点云数据进行处理，PCL点云库中包含了基于NDT正态分布变换等多种点云配准算法。C++ PCL库架构图如下图所示，PCL更多资料见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268524083">PCL学习指南</a></p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pcl.png" alt="pcl" style="zoom:80%"><p>点云配准具体的步骤如下：</p><h6 id="①-输入实时点云并下采样"><a href="#①-输入实时点云并下采样" class="headerlink" title="① 输入实时点云并下采样"></a>① 输入实时点云并下采样</h6><p>​ 激光雷达扫描得到的激光点云数据需要去除距离车体较近与较远的激光点集，然后利用<strong>体素滤波</strong>过滤剩下的激光点云数据，在保持点云统计特征的情况下，降低激光点云数据集的尺寸大小，最好将<strong>降采样后的过滤点云</strong>作为NDT配准算法的输入源点云以降低运算时间，节省资源。</p><h6 id="②-输入源点云-全局地图"><a href="#②-输入源点云-全局地图" class="headerlink" title="② 输入源点云(全局地图)"></a>② 输入源点云(全局地图)</h6><p>​ 加载全局地图作为NDT配准的输入目标点云。特别的，建图时第一帧激光点云作为初始全局地图。</p><h6 id="③-输入初始位姿"><a href="#③-输入初始位姿" class="headerlink" title="③ 输入初始位姿"></a>③ 输入初始位姿</h6><p>​ 为了快速得到准确的配准结果，需要给NDT算法提供良好的初始值，该节点通过IMU、Odom以及两者联合来求得初始位姿估计。</p><h6 id="④-点云配准"><a href="#④-点云配准" class="headerlink" title="④ 点云配准"></a>④ 点云配准</h6><p>​ 将前三者得到的结果作为参数传入到NDT配准算法中进行激光点云配准。</p><h5 id="3、伪代码"><a href="#3、伪代码" class="headerlink" title="3、伪代码"></a>3、伪代码</h5><p>​ 具体详见4中两篇参考论文，此处以二维举例。</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/Pseudocode_ndt.png" alt="Pseudocode_ndt"></p><h5 id="4、参考论文"><a href="#4、参考论文" class="headerlink" title="4、参考论文"></a>4、参考论文</h5><p><a target="_blank" rel="noopener" href="https://www.researchgate.net/publication/4045903_The_Normal_Distributions_Transform_A_New_Approach_to_Laser_Scan_Matching">[1] Biber P, Straßer W. The normal distributions transform: A new approach to laser scan matching[C] IROS 2003 . IEEE, 2003, 3: 2743-2748.</a></p><p><a target="_blank" rel="noopener" href="http://130.243.105.49/Research/mro/publications/2009/Magnusson_2009-Doctoral_Thesis-3D_NDT.pdf">[2] Merten H. The three-dimensional normal-distributions transform[J]. threshold, 2008, 10: 3.</a></p><p><span id="jump3.1"></span></p><h3 id="3-1-ndt-mapping节点解析"><a href="#3-1-ndt-mapping节点解析" class="headerlink" title="3.1    ndt_mapping节点解析"></a>3.1 ndt_mapping节点解析</h3><p>​ ndt_mapping主要利用的是scan_to_map的方式实现激光点云建图，该方法经常使用在SLAM同时定位与建图中，当激光雷达进行扫描建图的时候，由于受到扫描距离等因素的限制，使得激光雷达不能一次扫描得到完整的环境地图，因此需要进行连续多次的扫描。最终扫描得到的整个环境地图就是全局地图map，而其中scan表示当前扫描得到的激光点云数据，可以通过固定目标点云地图submap，然后利用NDT配准算法，将每一帧扫描得到的激光点云数据scan变换到目标点云submap中，并使得两者拼接在一起，最终得到拼接完整的全局地图map。ndt_mapping简要流程如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/ndt_mapping.jpg" alt="ndt_mapping"></p><h4 id="3-1-1-启动方法"><a href="#3-1-1-启动方法" class="headerlink" title="3.1.1    启动方法"></a>3.1.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li><code>roslaunch lidar_localizer ndt_mapping.launch</code></li></ul></li><li><p>从Runtime Manager启动:</p></li></ul><p>​ 打开Runtime Manager，上方Computing 选项卡 -&gt; Localization&#x2F; lidar_localizer -&gt; <code>ndt_mapping</code>，单击 [app] 按钮可更改设置等参数。</p><h4 id="3-1-2-程序路径"><a href="#3-1-2-程序路径" class="headerlink" title="3.1.2    程序路径"></a>3.1.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/lidar_localizer/nodes/ndt_mapping/ndt_mapping.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">//launch文件路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/lidar_localizer/launch/ndt_mapping.launch</span><br></pre></td></tr></table></figure><h4 id="3-1-3-参数详情"><a href="#3-1-3-参数详情" class="headerlink" title="3.1.3    参数详情"></a>3.1.3 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>method_type</code></td><td><em>int</em></td><td>ndt使用算法类型</td></tr><tr><td><code>use_odom</code></td><td><em>bool</em></td><td>是否使用里程计减少误差</td></tr><tr><td><code>use_imu</code></td><td><em>bool</em></td><td>是否使用IMU减少误差</td></tr><tr><td><code>imu_upside_down</code></td><td><em>bool</em></td><td>IMU坐标系是否翻转</td></tr><tr><td><code>imu_topic</code></td><td><em>String</em></td><td>IMU话题名</td></tr><tr><td><code>incremental_voxel_update</code></td><td><em>bool</em></td><td>是否更新增量体素</td></tr></tbody></table><h4 id="3-1-4-订阅话题名"><a href="#3-1-4-订阅话题名" class="headerlink" title="3.1.4    订阅话题名"></a>3.1.4 订阅话题名</h4><table><thead><tr><th>话题名</th><th>消息类型</th></tr></thead><tbody><tr><td><code>/config/ndt_mapping</code></td><td><code>autoware_config_msgs/ConfigNDTMapping</code></td></tr><tr><td><code>/config/ndt_mapping_output</code></td><td><code>autoware_config_msgs/ConfigNDTMappingOutput</code></td></tr><tr><td><code>/points_raw</code></td><td><code>sensor_msgs/PointCloud2</code></td></tr><tr><td><code>/vehicle/odom</code></td><td><code>nav_msgs/Odometry</code></td></tr><tr><td><code>/imu_raw</code></td><td><code>sensor_msgs/Imu</code></td></tr><tr><td><code>/vehicle/twist</code></td><td><code>geometry_msgs/TwistStamped</code></td></tr></tbody></table><h4 id="3-1-5-发布话题名"><a href="#3-1-5-发布话题名" class="headerlink" title="3.1.5    发布话题名"></a>3.1.5 发布话题名</h4><table><thead><tr><th>话题名</th><th>消息类型</th></tr></thead><tbody><tr><td><code>/ndt_map</code></td><td><code>sensor_msgs/PointCloud2</code></td></tr><tr><td><code>/current_pose</code></td><td><code>geometry_msgs/PoseStamped</code></td></tr></tbody></table><h4 id="3-1-6-代码注解"><a href="#3-1-6-代码注解" class="headerlink" title="3.1.6    代码注解"></a>3.1.6 代码注解</h4><h5 id="①-主函数"><a href="#①-主函数" class="headerlink" title="① 主函数"></a>① 主函数</h5><p>​ 主函数初始化位姿、ROS节点及参数，并写入日志文件。从参数服务器中获取参数值，计算变换矩阵tf_btol，最后发布与订阅相关消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//私有句柄调用getparam函数从参数服务器上得到参数值，若无参数则置为默认值  </span></span><br><span class="line">private_nh.<span class="built_in">getParam</span>(<span class="string">&quot;method_type&quot;</span>, method_type_tmp);</span><br><span class="line">_method_type = <span class="built_in">static_cast</span>&lt;MethodType&gt;(method_type_tmp);</span><br><span class="line">private_nh.<span class="built_in">getParam</span>(<span class="string">&quot;use_gnss&quot;</span>, _use_gnss);</span><br><span class="line">private_nh.<span class="built_in">getParam</span>(<span class="string">&quot;queue_size&quot;</span>, _queue_size);</span><br><span class="line">private_nh.<span class="built_in">getParam</span>(<span class="string">&quot;offset&quot;</span>, _offset);</span><br><span class="line"><span class="comment">//...(下略)</span></span><br></pre></td></tr></table></figure><p>​ 计算map与base_link的坐标转换关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    初始平移向量tl_btol，激光雷达相对于车身底盘坐标系的位姿</span></span><br><span class="line"><span class="function">Eigen::Translation3f <span class="title">tl_btol</span><span class="params">(tf_x, tf_y, tf_z)</span></span>;<span class="comment">// tl: translation</span></span><br><span class="line"><span class="comment">//    初始化旋转向量，分别绕着x、y、z轴旋转</span></span><br><span class="line">tf::<span class="built_in">Matrix3x3</span>(tf_baselink2primarylidar.<span class="built_in">getRotation</span>()).<span class="built_in">getRPY</span>( tf_roll, tf_pitch,tf_yaw);</span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">rot_x_btol</span><span class="params">(tf_roll, Eigen::Vector3f::UnitX())</span></span>;  <span class="comment">// rot: rotation</span></span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">rot_y_btol</span><span class="params">(tf_pitch, Eigen::Vector3f::UnitY())</span></span>;</span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">rot_z_btol</span><span class="params">(tf_yaw, Eigen::Vector3f::UnitZ())</span></span>;</span><br><span class="line">tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).<span class="built_in">matrix</span>();</span><br><span class="line">tf_ltob = tf_btol.<span class="built_in">inverse</span>();</span><br><span class="line"><span class="comment">//...(下略)</span></span><br></pre></td></tr></table></figure><h5 id="②-param-callback函数"><a href="#②-param-callback函数" class="headerlink" title="② param_callback函数"></a>② param_callback函数</h5><p>​ param_callback函数通过autoware_config_msgs::ConfigNDTMapping文件进行参数配置，主要设置ndt算法配准时的参数。其中定义了配准时的消息、网格大小、高斯牛顿法步长等参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">param_callback</span><span class="params">(<span class="type">const</span> autoware_config_msgs::ConfigNDTMapping::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">//设置ndt参数：分辨率、步长，最大迭代次数、体素叶大小、激光扫描范围等</span></span><br><span class="line">    ndt_res = input-&gt;resolution;    <span class="comment">//resolution表示点云网格化时网格的边长，过大会影响精度，过小则影响内存使用</span></span><br><span class="line">      step_size = input-&gt;step_size;    <span class="comment">//step_size设置利用牛顿法优化的最大步长</span></span><br><span class="line">      trans_eps = input-&gt;trans_epsilon;    <span class="comment">//trans_epsilon设置两连续变换的最大差值用于判断是否收敛至阈值</span></span><br><span class="line">      max_iter = input-&gt;max_iterations;    <span class="comment">//max_iterations设置优化迭代的最大次数</span></span><br><span class="line">      voxel_leaf_size = input-&gt;leaf_size;    <span class="comment">//leaf_size设置体素滤波叶的大小用于原始点云过滤</span></span><br><span class="line">    <span class="comment">//激光点云有效扫描距离</span></span><br><span class="line">      min_scan_range = input-&gt;min_scan_range;</span><br><span class="line">      max_scan_range = input-&gt;max_scan_range;</span><br><span class="line">      min_add_scan_shift = input-&gt;min_add_scan_shift;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③-output-callback函数"><a href="#③-output-callback函数" class="headerlink" title="③ output_callback函数"></a>③ output_callback函数</h5><p>​ output_callback主要使用体素滤波将原始点云数据进行过滤，在保持点云特性的情况下降低点云数量，然后将滤波后的点云通过ROS发布，并写入PCD文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">output_callback</span><span class="params">(<span class="type">const</span> autoware_config_msgs::ConfigNDTMappingOutput::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> filter_res = input-&gt;filter_res;</span><br><span class="line">  std::string filename = input-&gt;filename;</span><br><span class="line">  <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">map_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;(map))</span></span>;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">map_filtered</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;</span><br><span class="line">  map_ptr-&gt;header.frame_id = <span class="string">&quot;map&quot;</span>;</span><br><span class="line">  map_filtered-&gt;header.frame_id = <span class="string">&quot;map&quot;</span>;</span><br><span class="line">  sensor_msgs::<span class="function">PointCloud2::Ptr <span class="title">map_msg_ptr</span><span class="params">(<span class="keyword">new</span> sensor_msgs::PointCloud2)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运用体素滤波，如果不滤波则输出原始点云，并将pcl::PointCloud&lt;pcl::PointXYZI&gt;转化为sensor_msgs::PointCloud2类型</span></span><br><span class="line">  <span class="keyword">if</span> (filter_res == <span class="number">0.0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original: &quot;</span> &lt;&lt; map_ptr-&gt;points.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; points.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    pcl::<span class="built_in">toROSMsg</span>(*map_ptr, *map_msg_ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 声明体素滤波对象voxel_grid_filter</span></span><br><span class="line">    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;</span><br><span class="line">    <span class="comment">// 设置体素滤波网格大小，网格是边长为filter_res的立方体</span></span><br><span class="line">    voxel_grid_filter.<span class="built_in">setLeafSize</span>(filter_res, filter_res, filter_res);</span><br><span class="line">    <span class="comment">// 将map作为输入地图</span></span><br><span class="line">    voxel_grid_filter.<span class="built_in">setInputCloud</span>(map_ptr);</span><br><span class="line">    <span class="comment">// 点云下采样并保存结果至map_filtered</span></span><br><span class="line">    voxel_grid_filter.<span class="built_in">filter</span>(*map_filtered);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original: &quot;</span> &lt;&lt; map_ptr-&gt;points.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; points.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Filtered: &quot;</span> &lt;&lt; map_filtered-&gt;points.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; points.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 将点云类型转换为ROS可用的sensor_msgs::PointCloud2格式</span></span><br><span class="line">    pcl::<span class="built_in">toROSMsg</span>(*map_filtered, *map_msg_ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布过滤点云消息</span></span><br><span class="line">  ndt_map_pub.<span class="built_in">publish</span>(*map_msg_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点云数据写入PCD文件</span></span><br><span class="line">  <span class="keyword">if</span> (filter_res == <span class="number">0.0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    pcl::io::<span class="built_in">savePCDFileASCII</span>(filename, *map_ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Saved &quot;</span> &lt;&lt; map_ptr-&gt;points.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; data points to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    pcl::io::<span class="built_in">savePCDFileASCII</span>(filename, *map_filtered);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Saved &quot;</span> &lt;&lt; map_filtered-&gt;points.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; data points to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-points-callback函数"><a href="#④-points-callback函数" class="headerlink" title="④ points_callback函数"></a>④ points_callback函数</h5><p>​ points_callback函数由ros::Subscriber points_sub &#x3D; nh.subscribe(“points_raw”, 100000, points_callback)调用，参数为激光雷达所取到的 sensormsgs::PointCloud2 类型的激光点云数据，r表示激光点云中每一个点与激光雷达的距离，这用来后续滤除距离车体较近与较远的激光点集。p表示原始激光点云中的点对象，类型为pcl::PointXYZI。函数声明了两个类型为pcl::PointxYZI的点云对象 tmp, scan。 tmp表示临时的原始点云数据，scan 表示的是 tmp 滤除距离激光雷达过近和过远的激光点的点云数据。t_localizer 与 t_base_ link 分别表示为激光雷达与车体相对于 map 坐标系的变换矩阵，并且均初始化为4阶单位阵。需要注意的是，NDT配准算法是将激光雷达获取到的激光点云与地图目标点云进行配准，激光点云是相对于激光雷达坐标系，所以进行 NDT 配准的时候求出的是激光雷达相对于全局地图坐标系 map 的变换关系 t_localizer。要想求得车身底盘相对于全局地图map 坐标系的变换关系，需要在t_localizer 的基础上补偿一个激光雷达与车身底盘之间的变换矩阵tf_ltob。</p><p>​ 函数获取当前时间戳作为当前的点云扫描时间，然后利用 pcl:fromROSMsg 函数将输入的 sensor msgs:PointCloud2 类型的点云数据转化为 PCL 使用的数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">points_callback</span><span class="params">(<span class="type">const</span> sensor_msgs::PointCloud2::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// r表示点云到激光雷达的距离</span></span><br><span class="line">  <span class="type">double</span> r;</span><br><span class="line">  pcl::PointXYZI p;</span><br><span class="line">  <span class="comment">// 声明点云对象tmp, scan</span></span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt; tmp, scan;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">filtered_scan_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">transformed_scan_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;</span><br><span class="line">  tf::Quaternion q;</span><br><span class="line"></span><br><span class="line">  <span class="function">Eigen::Matrix4f <span class="title">t_localizer</span><span class="params">(Eigen::Matrix4f::Identity())</span></span>;</span><br><span class="line">  <span class="function">Eigen::Matrix4f <span class="title">t_base_link</span><span class="params">(Eigen::Matrix4f::Identity())</span></span>;</span><br><span class="line">  <span class="comment">// 声明tf发布者br</span></span><br><span class="line">  <span class="type">static</span> tf::TransformBroadcaster br;</span><br><span class="line">  <span class="comment">// 声明变换对象transform</span></span><br><span class="line">  tf::Transform transform;</span><br><span class="line">  <span class="comment">// 获取当前帧点云扫描时间戳</span></span><br><span class="line">  current_scan_time = input-&gt;header.stamp;</span><br><span class="line">  <span class="comment">// 点云类型转换</span></span><br><span class="line">  pcl::<span class="built_in">fromROSMsg</span>(*input, tmp);</span><br></pre></td></tr></table></figure><p>​ 这一部分代码块主要实现上一步提到的滤除距离车体过近与过远的激光点集。tmp 是原始的激光点云数据，在for循环中逐一获取tmp中的点云数据，然后利用r&#x3D;√x^2+y^2求出激光点与激光雷达之间的距离，其中，x,y分别表示激光点的横纵坐标。当r在最小扫描距离以及最大扫描距离之间时，则将激光点添加至 scan 点云容器中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理tmp点云容器中的点</span></span><br><span class="line"><span class="keyword">for</span> (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = tmp.<span class="built_in">begin</span>(); item != tmp.<span class="built_in">end</span>(); item++)</span><br><span class="line">&#123;</span><br><span class="line">  p.x = (<span class="type">double</span>)item-&gt;x;</span><br><span class="line">  p.y = (<span class="type">double</span>)item-&gt;y;</span><br><span class="line">  p.z = (<span class="type">double</span>)item-&gt;z;</span><br><span class="line">  p.intensity = (<span class="type">double</span>)item-&gt;intensity;</span><br><span class="line">  <span class="comment">// 计算点与激光雷达的欧氏距离r，逐一判断每个点，将满足扫描距离的点插入scan</span></span><br><span class="line">  r = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(p.x, <span class="number">2.0</span>) + <span class="built_in">pow</span>(p.y, <span class="number">2.0</span>));</span><br><span class="line">  <span class="keyword">if</span> (min_scan_range &lt; r &amp;&amp; r &lt; max_scan_range)</span><br><span class="line">  &#123;</span><br><span class="line">    scan.<span class="built_in">push_back</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">scan_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan))</span></span>;</span><br></pre></td></tr></table></figure><p>​ 激光点云地图需要初始化载入，实际上是将第一帧激光点云加入到map中。initial_scan_loaded 用来表示初始化载入是否成功，当地图没有初始化载入时，则将第一帧点云数据通过 pcl::transformPointcloud 函数进行转换后加入到map，pcl::transformPointCloud 函数的第一个参数为输入点云，第二个参数为输出点云，第三个参数为变换矩阵tf_btol.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将初始化点云加入地图，若点云地图未初始化</span></span><br><span class="line"><span class="keyword">if</span> (initial_scan_loaded == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 通过tf_btol变换矩阵作为输入将原始点云进行转化</span></span><br><span class="line">  pcl::<span class="built_in">transformPointCloud</span>(*scan_ptr, *transformed_scan_ptr, tf_btol);</span><br><span class="line">  <span class="comment">// 将转换后的点云加入map进行拼接，实际上是作为第一帧点云图像</span></span><br><span class="line">  map += *transformed_scan_ptr;</span><br><span class="line">  initial_scan_loaded = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 即使筛选掉距离激光雷达过近与过远的激光点，scan_ptr 中含有的激光点的数量仍然较大，所以函数通过体素滤波来降低点云数据的规模。PCL提供的VoxelGrid 类将输入点云集合空间进行三维网格化，然后以每一个网格(每一个立方体)内所有点的重心来代表体素内的所有点，体素内所有点由一个点来表示，这减少了数据规模，而且还保持了输入点云的形状特征。体素滤波主要设置网格大小voxel_leaf_ size， 然后将scan_ptr过滤，得到输出点云*filtered_scan_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对scan_ptr输入点云进行体素过滤</span></span><br><span class="line">pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;</span><br><span class="line">voxel_grid_filter.<span class="built_in">setLeafSize</span>(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);</span><br><span class="line">voxel_grid_filter.<span class="built_in">setInputCloud</span>(scan_ptr);</span><br><span class="line">voxel_grid_filter.<span class="built_in">filter</span>(*filtered_scan_ptr);</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">map_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;(map))</span></span>;</span><br></pre></td></tr></table></figure><p>​ 根据 method_type 参数进行相应的NDT参数设置，在ndt配准算法中Epsilon参数主要表示平移向量和旋转角度的临界递增量，当增量小于该参数时，配准算法结束，完成配准，该参数是 NDT 配准算法的收敛条件。步长参数step_size表示的是牛顿迭代法允许的最大步长，ndt_res 表示的是 NDT 配淮算法的网格划分分辨率的大小，分辨率大则网格所含点的数量整体较多，一般不少于5个。max_iter 表示的是牛顿迭代法的最大迭代次数，filtered_scan_ptr 作为 NDT 算法的输入源点云。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置转换参数Epsilon、最大步长、网格大小最大迭代次数，设置输入点云为已过滤点云</span></span><br><span class="line"> <span class="keyword">if</span> (_method_type == MethodType::PCL_GENERIC)</span><br><span class="line"> &#123;</span><br><span class="line">   ndt.<span class="built_in">setTransformationEpsilon</span>(trans_eps);</span><br><span class="line">   ndt.<span class="built_in">setStepSize</span>(step_size);</span><br><span class="line">   ndt.<span class="built_in">setResolution</span>(ndt_res);</span><br><span class="line">   ndt.<span class="built_in">setMaximumIterations</span>(max_iter);</span><br><span class="line">   ndt.<span class="built_in">setInputSource</span>(filtered_scan_ptr);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//...(下略)</span></span><br></pre></td></tr></table></figure><p>​ 全局地图map 初始化之后，ndt.setlnputTarget 函数将第一帧点云作为 NDT 配准算法的输入目标点云。结合上一段代码可以得到 NDT 目标点云为map全局地图，NDT 源点云为每一次接收到的降采样过滤点云 filtered_scan_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将第一张地图map_ptr设置输入NDT点云</span></span><br><span class="line">  <span class="type">static</span> <span class="type">bool</span> is_first_map = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (is_first_map == <span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_method_type == MethodType::PCL_GENERIC)</span><br><span class="line">      ndt.<span class="built_in">setInputTarget</span>(map_ptr);</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">    is_first_map = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​ NDT 配准算法需要提供一个位姿初值，该位姿初值用来计算配准算法的初始变换矩阵，然后再利用牛顿迭代法进行不断选代优化直至达到收敛或者最大迭代次数。Autoware利用IMU、里程计数据融合提供一个更加准确的位姿初值。车辆位姿是随着时间变化的，上一时刻的位姿加上位姿的变化量得到当前时刻的位姿，NDT配准算法所需要的初始位置可以利用前一帧位姿加上前后两帧位姿变化来得到。根据传感器的使用情况，来选择初始位姿计算方法。其中，imu_odom_calc, imu_calc, odom_calc 分别表示选择 imu 与里程计联合，单独使用imu或里程计时的初值计算函数。当不使用 IMU 与里程计计算初值的肘候，使用 guess_pose 作为 NDT 配准算法的初始位姿 guess_pose_for_ndt。代码中使用 guess_pose_for_ndt 初始位姿来构造初始变换矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">guess_pose.x = previous_pose.x + diff_x;</span><br><span class="line">guess_pose.y = previous_pose.y + diff_y;</span><br><span class="line">guess_pose.z = previous_pose.z + diff_z;</span><br><span class="line">guess_pose.roll = previous_pose.roll;</span><br><span class="line">guess_pose.pitch = previous_pose.pitch;</span><br><span class="line">guess_pose.yaw = previous_pose.yaw + diff_yaw;</span><br><span class="line"><span class="comment">// 选择使用初值的计算方法，第一种使用imu与里程计融合</span></span><br><span class="line"><span class="keyword">if</span> (_use_imu == <span class="literal">true</span> &amp;&amp; _use_odom == <span class="literal">true</span>)</span><br><span class="line">  <span class="built_in">imu_odom_calc</span>(current_scan_time);</span><br><span class="line"><span class="keyword">if</span> (_use_imu == <span class="literal">true</span> &amp;&amp; _use_odom == <span class="literal">false</span>)</span><br><span class="line">  <span class="built_in">imu_calc</span>(current_scan_time);</span><br><span class="line"><span class="keyword">if</span> (_use_imu == <span class="literal">false</span> &amp;&amp; _use_odom == <span class="literal">true</span>)</span><br><span class="line">  <span class="built_in">odom_calc</span>(current_scan_time);</span><br><span class="line"><span class="comment">// 声明NDT初值</span></span><br><span class="line">pose guess_pose_for_ndt;</span><br><span class="line"><span class="keyword">if</span> (_use_imu == <span class="literal">true</span> &amp;&amp; _use_odom == <span class="literal">true</span>)</span><br><span class="line">  guess_pose_for_ndt = guess_pose_imu_odom;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_use_imu == <span class="literal">true</span> &amp;&amp; _use_odom == <span class="literal">false</span>)</span><br><span class="line">  guess_pose_for_ndt = guess_pose_imu;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_use_imu == <span class="literal">false</span> &amp;&amp; _use_odom == <span class="literal">true</span>)</span><br><span class="line">  guess_pose_for_ndt = guess_pose_odom;</span><br><span class="line"><span class="keyword">else</span>    <span class="comment">// 若未使用imu或里程计，用guess_pose</span></span><br><span class="line">  guess_pose_for_ndt = guess_pose;</span><br><span class="line"><span class="comment">// 利用guess_pose_for_ndt位置的位姿旋转量来初始化xyz轴的旋转向量</span></span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation_x</span><span class="params">(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX())</span></span>;</span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation_y</span><span class="params">(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY())</span></span>;</span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation_z</span><span class="params">(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ())</span></span>;</span><br><span class="line"><span class="comment">// 使用guess_pose_for_ndt的三维坐标初始化平移向量</span></span><br><span class="line"><span class="function">Eigen::Translation3f <span class="title">init_translation</span><span class="params">(guess_pose_for_ndt.x, guess_pose_for_ndt.y, guess_pose_for_ndt.z)</span></span>;</span><br><span class="line">Eigen::Matrix4f init_guess =</span><br><span class="line">    (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).<span class="built_in">matrix</span>() * tf_btol;</span><br></pre></td></tr></table></figure><p>​ 这段代码主要进行了 NDT 的配准操作。代码首先获取当前时间戳作为配准计时的起始时间t4，然后根据方法类型进行 NDT 配准。ndt.align 函数开始进行 NDT 配准，该函数第一个参数是输出点云，第二个参数是初始化变换矩阵，其中，初始化变换矩阵是上一步得到的 init_guess，ndt.align 实际上调用了 ndt.computeTransformation 函数得到最终的配准点云。代码使用 ndt.getFitnessScore()计算匹配得分，一般来说匹配得分小于 1。t_localizer 表示的是 NDT 配准算法得到的激光雷达相对于map 坐标系的最终变换矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">t3_end = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">d3 = t3_end - t3_start;</span><br><span class="line">t4_start = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="function">Ptr <span class="title">output_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;)</span></span>;</span><br><span class="line"><span class="comment">// 根据_method_type类型进行配准</span></span><br><span class="line"><span class="keyword">if</span> (_method_type == MethodType::PCL_GENERIC)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 开始配准，ndt.align以init_guess为初值进行迭代优化</span></span><br><span class="line">  ndt.<span class="built_in">align</span>(*output_cloud, init_guess);</span><br><span class="line">  <span class="comment">// 利用ndt.getFitnessScore()计算目标点云与源点云最近点间的欧式距离平方和作为匹配得分</span></span><br><span class="line">  fitness_score = ndt.<span class="built_in">getFitnessScore</span>();</span><br><span class="line">  <span class="comment">// 通过NDT配准得到最终雷达相对于map坐标系的变换矩阵t_localizer</span></span><br><span class="line">  t_localizer = ndt.<span class="built_in">getFinalTransformation</span>();</span><br><span class="line">  <span class="comment">// 判断是否收敛</span></span><br><span class="line">  has_converged = ndt.<span class="built_in">hasConverged</span>();</span><br><span class="line">  <span class="comment">// 得到最后的迭代次数</span></span><br><span class="line">  final_num_iteration = ndt.<span class="built_in">getFinalNumIteration</span>();</span><br><span class="line">  transformation_probability = ndt.<span class="built_in">getTransformationProbability</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...(下略)</span></span><br></pre></td></tr></table></figure><p>​ 这段代码首先求出车体相对于原点的变换矩阵 t_base link，然后pcl::transformPointcloud 函数主要将降采样后的原始点云 scan 变换为点云*transformed_scan_ptr，变换时采用的变换矩阵为基于 NDT 配准方法得到的变换矩阵。mat_l，mat_b 分别表示激光雷达与车体相对于全局地图map的旋转矩阵，分别由 t_localizer与t_base_ link 矩阵的前三列与前三行进行对应赋值。ndt_pose 表示 NDT 配准后的车辆在全局地图中的位姿，其坐标位置由t_base_link 变换矩阵的平移向量进行赋值。<br>​ 此时的 ndt_pose 作为当前时刻的位姿估计 current_pose。最后利用当前扫描时间current_scan_time 减去上一帧扫描时间 previous_scan_time 得到激光雷达的扫描间隔时间scan_duration。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">t_base_link = t_localizer * tf_ltob;</span><br><span class="line"><span class="comment">// 将原始图像经过NDT变换后输出点云transformed_scan_ptr</span></span><br><span class="line">pcl::<span class="built_in">transformPointCloud</span>(*scan_ptr, *transformed_scan_ptr, t_localizer);</span><br><span class="line">tf::Matrix3x3 mat_l, mat_b;</span><br><span class="line"><span class="comment">// t_localize为4*4的变换矩阵，其中前三行前三列为旋转矩阵，第四列第三行为平移向量</span></span><br><span class="line">mat_l.<span class="built_in">setValue</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">0</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">0</span>, <span class="number">1</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">0</span>, <span class="number">2</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">1</span>, <span class="number">0</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">1</span>, <span class="number">1</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">1</span>, <span class="number">2</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">2</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">2</span>, <span class="number">1</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_localizer</span>(<span class="number">2</span>, <span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">mat_b.<span class="built_in">setValue</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">0</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">0</span>, <span class="number">1</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">0</span>, <span class="number">2</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">1</span>, <span class="number">0</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">1</span>, <span class="number">1</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">1</span>, <span class="number">2</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">2</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">2</span>, <span class="number">1</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t_base_link</span>(<span class="number">2</span>, <span class="number">2</span>)));</span><br><span class="line"><span class="comment">// 更新localizer_pose</span></span><br><span class="line">localizer_pose.x = <span class="built_in">t_localizer</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">localizer_pose.y = <span class="built_in">t_localizer</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">localizer_pose.z = <span class="built_in">t_localizer</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//通过mat_l.getRPY设置localizer_pose的旋转rpy角度</span></span><br><span class="line">mat_l.<span class="built_in">getRPY</span>(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新ndt_pose</span></span><br><span class="line">ndt_pose.x = <span class="built_in">t_base_link</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">ndt_pose.y = <span class="built_in">t_base_link</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">ndt_pose.z = <span class="built_in">t_base_link</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">mat_b.<span class="built_in">getRPY</span>(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将NDT配准后的位置作为当前位置</span></span><br><span class="line">current_pose.x = ndt_pose.x;</span><br><span class="line">current_pose.y = ndt_pose.y;</span><br><span class="line">current_pose.z = ndt_pose.z;</span><br><span class="line">current_pose.roll = ndt_pose.roll;</span><br><span class="line">current_pose.pitch = ndt_pose.pitch;</span><br><span class="line">current_pose.yaw = ndt_pose.yaw;</span><br><span class="line"><span class="comment">// 以当前位置为坐标原点</span></span><br><span class="line">transform.<span class="built_in">setOrigin</span>(tf::<span class="built_in">Vector3</span>(current_pose.x, current_pose.y, current_pose.z));</span><br><span class="line"><span class="comment">// 当前位置旋转角度RPY，设置四元数Q</span></span><br><span class="line">q.<span class="built_in">setRPY</span>(current_pose.roll, current_pose.pitch, current_pose.yaw);</span><br><span class="line">transform.<span class="built_in">setRotation</span>(q);</span><br><span class="line"><span class="comment">// 发布坐标变换信息</span></span><br><span class="line">br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, current_scan_time, <span class="string">&quot;map&quot;</span>, <span class="string">&quot;base_link&quot;</span>));</span><br><span class="line"><span class="comment">// 计算扫描间隔时间</span></span><br><span class="line">scan_duration = current_scan_time - previous_scan_time;</span><br><span class="line"><span class="type">double</span> secs = scan_duration.<span class="built_in">toSec</span>();</span><br></pre></td></tr></table></figure><p>​ 这一部分代码计算了相邻两帧之间的位移 diff 和偏航角变化 diff_yaw。 NDT建图过程要求车辆尽量保持匀速行驶，由于相邻两帧时问差较小，所以车辆短时间内近似为匀速模型，利用x，y，z方向的位移变化与激光雷达扫描间隔的比值作为当前的速度 current_velocity。最后代码将当前位姿 current_pose 赋值于前一帧位姿previous_pose， 为下一次 NDT 配准提供计算初值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算相邻位姿偏差 (curren_pos - previous_pos)</span></span><br><span class="line">diff_x = current_pose.x - previous_pose.x;</span><br><span class="line">diff_y = current_pose.y - previous_pose.y;</span><br><span class="line">diff_z = current_pose.z - previous_pose.z;</span><br><span class="line">diff_yaw = <span class="built_in">calcDiffForRadian</span>(current_pose.yaw, previous_pose.yaw);</span><br><span class="line">diff = <span class="built_in">sqrt</span>(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);</span><br><span class="line"><span class="comment">// 利用前后两帧扫描位置偏差与扫描间隔计算此时的瞬时速度</span></span><br><span class="line">current_velocity_x = diff_x / secs;</span><br><span class="line">current_velocity_y = diff_y / secs;</span><br><span class="line">current_velocity_z = diff_z / secs;</span><br><span class="line"><span class="comment">// 当前位姿current_pose赋予imu当前位姿并更新校正</span></span><br><span class="line">current_pose_imu.x = current_pose.x;</span><br><span class="line">current_pose_imu.y = current_pose.y;</span><br><span class="line">current_pose_imu.z = current_pose.z;</span><br><span class="line">current_pose_imu.roll = current_pose.roll;</span><br><span class="line">current_pose_imu.pitch = current_pose.pitch;</span><br><span class="line">current_pose_imu.yaw = current_pose.yaw;</span><br><span class="line"><span class="comment">//...(下略)  </span></span><br></pre></td></tr></table></figure><p>​ 这一部分代码主要负责地图的更新，每隔一定的距离会更新一次地图，这里的距离由 shift 表示。added_pose 是上一帧车辆的位姿，用于判断是否需要更新地图。当前后两帧距离差 shift 大于min_add scan_ shift 最小更新距离时，将转换后的点云数据*transformed scan ptr 加入到 map 全局地图，然后将当前位姿 current_pose 赋値于added_pose 进行位姿更新。最后把当前配准拼接后的点云数据 map_ptr 设置为下一次配准的输入目标点云。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 计算added_pose与current_pose间距离</span></span><br><span class="line">  <span class="type">double</span> shift = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(current_pose.x - added_pose.x, <span class="number">2.0</span>) + <span class="built_in">pow</span>(current_pose.y - added_pose.y, <span class="number">2.0</span>));</span><br><span class="line">  <span class="keyword">if</span> (shift &gt;= min_add_scan_shift)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 将经过坐标转换后的transformed_scan_ptr加到map中完成拼接</span></span><br><span class="line">    map += *transformed_scan_ptr;</span><br><span class="line">    added_pose.x = current_pose.x;</span><br><span class="line">    added_pose.y = current_pose.y;</span><br><span class="line">    added_pose.z = current_pose.z;</span><br><span class="line">    added_pose.roll = current_pose.roll;</span><br><span class="line">    added_pose.pitch = current_pose.pitch;</span><br><span class="line">    added_pose.yaw = current_pose.yaw;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_method_type == MethodType::PCL_GENERIC)</span><br><span class="line">      ndt.<span class="built_in">setInputTarget</span>(map_ptr);</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明sensor_msgs::PointCloud2点云对象</span></span><br><span class="line">  sensor_msgs::<span class="function">PointCloud2::Ptr <span class="title">map_msg_ptr</span><span class="params">(<span class="keyword">new</span> sensor_msgs::PointCloud2)</span></span>;</span><br><span class="line">  <span class="comment">// 数据类型转换</span></span><br><span class="line">  pcl::<span class="built_in">toROSMsg</span>(*map_ptr, *map_msg_ptr);</span><br><span class="line">  <span class="comment">// 发布点云</span></span><br><span class="line">  ndt_map_pub.<span class="built_in">publish</span>(*map_msg_ptr);</span><br><span class="line">  <span class="comment">//...(下略)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑤-odom-callback函数"><a href="#⑤-odom-callback函数" class="headerlink" title="⑤ odom_callback函数"></a>⑤ odom_callback函数</h5><p>​ odom_callback 函数由ros::Subscriber odom_sub &#x3D; nh.subscribe(“vehicle&#x2F;odom”, 100000, odom_callback)所调用。odom_callback 函数以里程计接收到的数据作为函数参数，主要调用 odom_calc 初值计算函数，该函数以接收到的里程计数据时间戳作为输入参数，求得 NDT 的初始位姿估计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">odom_callback</span><span class="params">(<span class="type">const</span> nav_msgs::Odometry::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  odom = *input;</span><br><span class="line">  <span class="built_in">odom_calc</span>(input-&gt;header.stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ odom_calc里程计初始位姿计算函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">odom_calc</span><span class="params">(ros::Time current_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> ros::Time previous_time = current_time;</span><br><span class="line">  <span class="comment">// 获取两帧时间差</span></span><br><span class="line">  <span class="type">double</span> diff_time = (current_time - previous_time).<span class="built_in">toSec</span>();</span><br><span class="line">  <span class="comment">// 计算两帧时间间隔内的里程计旋转角度</span></span><br><span class="line">  <span class="type">double</span> diff_odom_roll = odom.twist.twist.angular.x * diff_time;</span><br><span class="line">  <span class="type">double</span> diff_odom_pitch = odom.twist.twist.angular.y * diff_time;</span><br><span class="line">  <span class="type">double</span> diff_odom_yaw = odom.twist.twist.angular.z * diff_time;</span><br><span class="line">  <span class="comment">// 更新当前里程计位置的角度</span></span><br><span class="line">  current_pose_odom.roll += diff_odom_roll;</span><br><span class="line">  current_pose_odom.pitch += diff_odom_pitch;</span><br><span class="line">  current_pose_odom.yaw += diff_odom_yaw;</span><br><span class="line">  <span class="comment">// diff_distance为x方向的变化距离，offset为车身不稳定造成的计算偏差</span></span><br><span class="line">  <span class="type">double</span> diff_distance = odom.twist.twist.linear.x * diff_time;</span><br><span class="line">  offset_odom_x += diff_distance * <span class="built_in">cos</span>(-current_pose_odom.pitch) * <span class="built_in">cos</span>(current_pose_odom.yaw);</span><br><span class="line">  offset_odom_y += diff_distance * <span class="built_in">cos</span>(-current_pose_odom.pitch) * <span class="built_in">sin</span>(current_pose_odom.yaw);</span><br><span class="line">  offset_odom_z += diff_distance * <span class="built_in">sin</span>(-current_pose_odom.pitch);</span><br><span class="line"></span><br><span class="line">  offset_odom_roll += diff_odom_roll;</span><br><span class="line">  offset_odom_pitch += diff_odom_pitch;</span><br><span class="line">  offset_odom_yaw += diff_odom_yaw;</span><br><span class="line">  <span class="comment">// 对初始位置修正</span></span><br><span class="line">  guess_pose_odom.x = previous_pose.x + offset_odom_x;</span><br><span class="line">  guess_pose_odom.y = previous_pose.y + offset_odom_y;</span><br><span class="line">  guess_pose_odom.z = previous_pose.z + offset_odom_z;</span><br><span class="line">  guess_pose_odom.roll = previous_pose.roll + offset_odom_roll;</span><br><span class="line">  guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;</span><br><span class="line">  guess_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;</span><br><span class="line">  previous_time = current_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑥-imu-callback函数"><a href="#⑥-imu-callback函数" class="headerlink" title="⑥ imu_callback函数"></a>⑥ imu_callback函数</h5><p>​ imu_callback函数由ros::Subscriber imu_sub &#x3D; nh.subscribe(_imu_topic, 100000, imu_callback)调用。该函数主要是利用 imu_calc (input-&gt;header.stamp) 函数计算位置初值，为 NDT 配准提供初始位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">imu_callback</span><span class="params">(<span class="type">const</span> sensor_msgs::Imu::Ptr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_imu_upside_down)</span><br><span class="line">    <span class="built_in">imuUpsideDown</span>(input);</span><br><span class="line">  <span class="comment">// 接收到imu消息的时候获取当前时间戳</span></span><br><span class="line">  <span class="type">const</span> ros::Time current_time = input-&gt;header.stamp;</span><br><span class="line">  <span class="type">static</span> ros::Time previous_time = current_time;</span><br><span class="line">  <span class="comment">// 计算前后两次接收消息的微小时间差</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> diff_time = (current_time - previous_time).<span class="built_in">toSec</span>();</span><br><span class="line">  <span class="type">double</span> imu_roll, imu_pitch, imu_yaw;</span><br><span class="line">  <span class="comment">// 声明用于转换的四元数</span></span><br><span class="line">  tf::Quaternion imu_orientation;</span><br><span class="line">  <span class="comment">// 将IMU采集到的四元数消息转化为TF类型</span></span><br><span class="line">  tf::<span class="built_in">quaternionMsgToTF</span>(input-&gt;orientation, imu_orientation);</span><br><span class="line">  <span class="comment">// 初始化3*3旋转矩阵，使用getRPY获取当前rpy旋转角</span></span><br><span class="line">  tf::<span class="built_in">Matrix3x3</span>(imu_orientation).<span class="built_in">getRPY</span>(imu_roll, imu_pitch, imu_yaw);</span><br><span class="line">  <span class="comment">// 转化为弧度</span></span><br><span class="line">  imu_roll = <span class="built_in">wrapToPmPi</span>(imu_roll);</span><br><span class="line">  imu_pitch = <span class="built_in">wrapToPmPi</span>(imu_pitch);</span><br><span class="line">  imu_yaw = <span class="built_in">wrapToPmPi</span>(imu_yaw);</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">double</span> previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> diff_imu_roll = <span class="built_in">calcDiffForRadian</span>(imu_roll, previous_imu_roll);</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> diff_imu_pitch = <span class="built_in">calcDiffForRadian</span>(imu_pitch, previous_imu_pitch);</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> diff_imu_yaw = <span class="built_in">calcDiffForRadian</span>(imu_yaw, previous_imu_yaw);</span><br><span class="line"></span><br><span class="line">  imu.header = input-&gt;header;</span><br><span class="line">  <span class="comment">// 获取imu在x方向的线性加速度</span></span><br><span class="line">  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;</span><br><span class="line">  imu.linear_acceleration.y = <span class="number">0</span>;</span><br><span class="line">  imu.linear_acceleration.z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (diff_time != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 若时间差不等于0，imu在工作，计算imu瞬时角速度</span></span><br><span class="line">    imu.angular_velocity.x = diff_imu_roll / diff_time;</span><br><span class="line">    imu.angular_velocity.y = diff_imu_pitch / diff_time;</span><br><span class="line">    imu.angular_velocity.z = diff_imu_yaw / diff_time;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 否则角速度置0</span></span><br><span class="line">    imu.angular_velocity.x = <span class="number">0</span>;</span><br><span class="line">    imu.angular_velocity.y = <span class="number">0</span>;</span><br><span class="line">    imu.angular_velocity.z = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算位置初值，提供初始位置</span></span><br><span class="line">  <span class="built_in">imu_calc</span>(input-&gt;header.stamp);</span><br><span class="line"></span><br><span class="line">  previous_time = current_time;</span><br><span class="line">  previous_imu_roll = imu_roll;</span><br><span class="line">  previous_imu_pitch = imu_pitch;</span><br><span class="line">  previous_imu_yaw = imu_yaw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump3.2"></span></p><h3 id="3-2-ndt-matching节点解析"><a href="#3-2-ndt-matching节点解析" class="headerlink" title="3.2    ndt_matching节点解析"></a>3.2 ndt_matching节点解析</h3><p>​ ndt_matching节点首先读取points_map_loader发布的点云地图，将此地图设置为target。同时，使用上述2.2小节中voxel_grid_filter将激光雷达发布的&#x2F;points_raw话题发布的&#x2F;sensor_msgs&#x2F;PointCloud2点云消息降采样，将降采样后的点云设置为source。此后利用ndt进行配准，得出齐次变换矩阵，可以得到车的几个坐标系的位置信息，从而进行定位。</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/ndt_matching.jpg" alt="ndt_matching"></p><h4 id="3-2-1-启动方法"><a href="#3-2-1-启动方法" class="headerlink" title="3.2.1    启动方法"></a>3.2.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li><code>roslaunch lidar_localizer ndt_matching.launch</code></li></ul></li><li><p>从Runtime Manager启动:</p></li></ul><p>​ 打开Runtime Manager，上方Computing 选项卡 -&gt; Localization&#x2F; lidar_localizer -&gt; <code>ndt_matching</code>，单击 [app] 按钮可更改设置等参数。</p><h4 id="3-2-2-程序路径"><a href="#3-2-2-程序路径" class="headerlink" title="3.2.2    程序路径"></a>3.2.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/lidar_localizer/nodes/ndt_matching/ndt_matching.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">//launch启动文件路径</span></span><br><span class="line">~/autoware.ai/src/autoware/core_perception/lidar_localizer/launch/ndt_matching.launch</span><br></pre></td></tr></table></figure><h4 id="3-2-3-参数详情"><a href="#3-2-3-参数详情" class="headerlink" title="3.2.3    参数详情"></a>3.2.3 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>method_type</code></td><td><em>int</em></td><td>ndt使用算法类型</td></tr><tr><td><code>use_gnss</code></td><td><em>bool</em></td><td>是否使用gnss</td></tr><tr><td><code>use_odom</code></td><td><em>bool</em></td><td>是否使用里程计减少误差</td></tr><tr><td><code>use_imu</code></td><td><em>bool</em></td><td>是否使用IMU减少误差</td></tr><tr><td><code>imu_upside_down</code></td><td><em>bool</em></td><td>IMU坐标系是否翻转</td></tr><tr><td><code>imu_topic</code></td><td><em>String</em></td><td>IMU话题名</td></tr><tr><td><code>queue_size</code></td><td><em>int</em></td><td>消息缓冲区大小</td></tr><tr><td><code>offset</code></td><td><em>String</em></td><td>位姿偏移校正</td></tr><tr><td><code>get_height</code></td><td><em>bool</em></td><td>z轴高度较正</td></tr><tr><td><code>use_local_transform</code></td><td><em>bool</em></td><td>使用本地tf</td></tr><tr><td><code>sync</code></td><td><em>bool</em></td><td>是否将话题名&#x2F;points_raw映射为&#x2F;sync_drivers&#x2F;points_raw</td></tr><tr><td><code>output_log_data</code></td><td><em>bool</em></td><td>是否输出log</td></tr><tr><td><code>output_tf_frame_id</code></td><td><em>String</em></td><td>tf frameID 默认为base_link</td></tr><tr><td><code>gnss_reinit_fitness</code></td><td><em>double</em></td><td>比较fitness_core的参考，默认值为500.0</td></tr></tbody></table><h4 id="3-2-4-订阅话题名"><a href="#3-2-4-订阅话题名" class="headerlink" title="3.2.4    订阅话题名"></a>3.2.4 订阅话题名</h4><table><thead><tr><th>话题名</th><th>消息类型</th></tr></thead><tbody><tr><td><code>/config/ndt</code></td><td><code>autoware_config_msgs/ConfigNDT</code></td></tr><tr><td><code>/gnss_pose</code></td><td><code>geometry_msgs/PoseStamped</code></td></tr><tr><td><code>/initialpose</code></td><td><code>geometry_msgs/PoseWithCovarianceStamped</code></td></tr><tr><td><code>/filtered_points</code></td><td><code>sensor_msgs/PointCloud2</code></td></tr><tr><td><code>/vehicle/odom</code></td><td><code>nav_msgs/Odometry</code></td></tr><tr><td><code>/imu_raw</code></td><td><code>sensor_msgs/Imu</code></td></tr><tr><td><code>/vehicle/twist</code></td><td><code>geometry_msgs/TwistStamped</code></td></tr></tbody></table><h4 id="3-2-5-发布话题名"><a href="#3-2-5-发布话题名" class="headerlink" title="3.2.5    发布话题名"></a>3.2.5 发布话题名</h4><table><thead><tr><th>话题名</th><th>消息类型</th></tr></thead><tbody><tr><td><code>/predict_pose</code></td><td><code>geometry_msgs::PoseStamped</code></td></tr><tr><td><code>/predict_pose_imu</code></td><td><code>geometry_msgs::PoseStamped</code></td></tr><tr><td><code>/predict_pose_odom</code></td><td><code>geometry_msgs::PoseStamped</code></td></tr><tr><td><code>/predict_pose_imu_odom</code></td><td><code>geometry_msgs::PoseStamped</code></td></tr><tr><td><code>/ndt_pose</code></td><td><code>geometry_msgs::PoseStamped</code></td></tr><tr><td><code>/localizer_pose</code></td><td><code>geometry_msgs::PoseStamped</code></td></tr><tr><td><code>/estimate_twist</code></td><td><code>geometry_msgs::TwistStamped</code></td></tr><tr><td><code>/estimated_vel_mps</code></td><td><code>std_msgs::Float32</code></td></tr><tr><td><code>/estimated_vel_kmph</code></td><td><code>std_msgs::Float32</code></td></tr><tr><td><code>/estimated_vel</code></td><td><code>geometry_msgs::Vector3Stamped</code></td></tr><tr><td><code>/time_ndt_matching</code></td><td><code>std_msgs::Float32</code></td></tr><tr><td><code>/ndt_stat</code></td><td><code>autoware_msgs::NDTStat</code></td></tr><tr><td><code>/ndt_reliability</code></td><td><code>std_msgs::Float32</code></td></tr></tbody></table><h4 id="3-2-6-代码注解"><a href="#3-2-6-代码注解" class="headerlink" title="3.2.6    代码注解"></a>3.2.6 代码注解</h4><h5 id="①-流程简介"><a href="#①-流程简介" class="headerlink" title="① 流程简介"></a>① 流程简介</h5><p>​ ndt_matching节点与ndt_mapping节点结构相似，不同之处在于ndt_matching利用scan_to_matching方法实现定位。该方法将已知的高精度地图map作为全局地图global map，利用激光雷达获取当前帧的激光点云数据scan，与固定不动的全局地图global_map进行ndt配准，求出最终车体相对于全局地图的位姿，从而实现精准定位。具体步骤如下:</p><p>​ ①由激光雷达获取的激光点云数据降采样作为 NDT 算法的输入源点云，这部分与 ndt mapping 一致<br>​ ②将全局地图 global map 作为 NDT 算法的输入目标点云；<br>​ ③此处 GNSS 的主要目标是实现重定位，当 imu 与odom 产生累计误差影响到NDT 配准算法的效果，或者是使用 gnss 时并未将 gnss 位姿初始化的时候，此时将当前gnss 位姿作为准确的车辆位姿信息，它能够及时纠正 imu 与odom 的累计误差；<br>​ ④利用 imu, odom 等传感器获取 NDT 所需的初始位姿估计；<br>​ ⑤进行 NDT 配准;<br>​ ⑥求得车辆相对于 全局地图的位姿 current pose。</p><p>​ ndt matching 节点的main 函数(源码略)与 ndt mapping 节点很相似，主要进行话题消息的发布，发布的话题有&#x2F;predict pose (预测的位姿），&#x2F;predict pose imu(利用imu 预测的位姿），&#x2F;predict_pose_odom （利用里程计预测得到的位姿），&#x2F;predict_pose_imu_odom (利用里程计与 imu 联合得到的位姿)等参数。订阅的话题有config&#x2F;ndt (ndt 配置参数），gnss_pose(使用gnss 得到的位姿)，initial_pos(初始位姿)，filtered_points（过滤处理后的激光点集），&#x2F;vehicle&#x2F;odom（里程汁消息）。</p><h5 id="②-param-callback函数-1"><a href="#②-param-callback函数-1" class="headerlink" title="② param_callback函数"></a>② param_callback函数</h5><p>​ param_callback 回调函数的参数为 NDT 配置参数消息(autoware_config_msgs::ConfigNDT.msg）。函数判断 _use_gnss 与 NDT 配置参数 init_pos_gnss 是否相等，use_gnss 表示使用 gnss 进行位姿估计，init_pos_gnss 用来表示 gnss 的初始位置。如果 use_gnss与 init_pos_gnss 不相等，则 init_pos_set&#x3D;0, 表示未进行位姿初始化。当 use_gnss&#x3D;&#x3D;0, 即不使用 gnss, 以及 NDT 参数配置中的车辆初始位姿与 initial_pose 不相等的时候，令 init_pos_set&#x3D;0。该代码主要判断 gnss 使用参数与 gnss 初始位姿是否初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">param_callback</span><span class="params">(<span class="type">const</span> autoware_config_msgs::ConfigNDT::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_use_gnss != input-&gt;init_pos_gnss)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 使用gnss时要对gnss位置初始化，如果两者不匹配，将初始位置init_pos_set置为0</span></span><br><span class="line">    init_pos_set = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_use_gnss == <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (initial_pose.x != input-&gt;x || initial_pose.y != input-&gt;y || initial_pose.z != input-&gt;z ||</span><br><span class="line">            initial_pose.roll != input-&gt;roll || initial_pose.pitch != input-&gt;pitch || initial_pose.yaw != input-&gt;yaw))</span><br><span class="line">  &#123;</span><br><span class="line">    init_pos_set = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _use_gnss = input-&gt;init_pos_gnss;</span><br></pre></td></tr></table></figure><p>​ 该代码主要对 NDT 配准的参数进行设置，根据方法类型的不同，将 ConfigNDT消息中的参数作为输入加载到 NDT 配准算法中。其中加载的 NDT 参数有:收敛条件、最大步长、分辨率(网格划分大小)以及最大迭代次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (input-&gt;step_size != step_size)</span><br><span class="line">&#123;</span><br><span class="line">  step_size = input-&gt;step_size;</span><br><span class="line">  <span class="comment">// 按照方法类型不同使用ndt.setResolution(ndt_res)函数设置NDT网格大小</span></span><br><span class="line">  <span class="keyword">if</span> (_method_type == MethodType::PCL_GENERIC)</span><br><span class="line">    ndt.<span class="built_in">setStepSize</span>(step_size);</span><br><span class="line">  <span class="comment">//...(下略)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置ndt算法收敛条件</span></span><br><span class="line"><span class="keyword">if</span> (input-&gt;trans_epsilon != trans_eps)</span><br><span class="line">&#123;</span><br><span class="line">  trans_eps = input-&gt;trans_epsilon;</span><br><span class="line">  <span class="comment">//...(下略)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置最大迭代次数</span></span><br><span class="line"><span class="keyword">if</span> (input-&gt;max_iterations != max_iter)</span><br><span class="line">&#123;</span><br><span class="line">  max_iter = input-&gt;max_iterations;</span><br><span class="line">  <span class="comment">//...(下略)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 该代码块主要判断是否使用 GNSS 、是否已初始化车辆位姿，当未使用 GNSS 并且未初始化车辆位姿时，利用 NDT 配置消息进行位姿初始化。当使用局部变换的时候，需要补偿一个局部变换矩阵 local_transform.inverse()，从而求得车辆相对于全局地图 map 的初始位姿。局部变换矩阵 local_transform 表示的是world 坐标系与地面坐标系 map 之间的变换关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (_use_gnss == <span class="number">0</span> &amp;&amp; init_pos_set == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果未使用gnss且未初始化车辆位姿，则用ndt参数配置消息中的位姿进行初始化</span></span><br><span class="line">    initial_pose.x = input-&gt;x;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">    <span class="keyword">if</span> (_use_local_transform == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 如果使用局部变换，在求初始位姿时要补偿一个局部变换矩阵local_transform.inverse()</span></span><br><span class="line">      <span class="function">tf2::Vector3 <span class="title">v</span><span class="params">(input-&gt;x, input-&gt;y, input-&gt;z)</span></span>;</span><br><span class="line">      tf2::Quaternion q;</span><br><span class="line">      q.<span class="built_in">setRPY</span>(input-&gt;roll, input-&gt;pitch, input-&gt;yaw);</span><br><span class="line">      <span class="function">tf2::Transform <span class="title">transform</span><span class="params">(q, v)</span></span>;</span><br><span class="line">      initial_pose.x = (local_transform.<span class="built_in">inverse</span>() * transform).<span class="built_in">getOrigin</span>().<span class="built_in">getX</span>();</span><br><span class="line">      initial_pose.y = (local_transform.<span class="built_in">inverse</span>() * transform).<span class="built_in">getOrigin</span>().<span class="built_in">getY</span>();</span><br><span class="line">      initial_pose.z = (local_transform.<span class="built_in">inverse</span>() * transform).<span class="built_in">getOrigin</span>().<span class="built_in">getZ</span>();</span><br><span class="line">      <span class="function">tf2::Matrix3x3 <span class="title">m</span><span class="params">(q)</span></span>;</span><br><span class="line">      m.<span class="built_in">getRPY</span>(initial_pose.roll, initial_pose.pitch, initial_pose.yaw);</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;initial_pose.x: &quot;</span> &lt;&lt; initial_pose.x &lt;&lt; std::endl;</span><br><span class="line">      <span class="comment">//...(下略)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始位姿</span></span><br><span class="line">    localizer_pose.x = initial_pose.x;</span><br><span class="line">    localizer_pose.y = initial_pose.y;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③-gnss-callback函数"><a href="#③-gnss-callback函数" class="headerlink" title="③ gnss_callback函数"></a>③ gnss_callback函数</h5><p>​ gnss_callback主要实现GNSS重定位功能，用来纠正IMU与里程计的积分累计误差，当ndt配准结果较差，也需要GNSS重定位来提供配准初值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">gnss_callback</span><span class="params">(<span class="type">const</span> geometry_msgs::PoseStamped::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 将GNSS的旋转参数保存至tf类型的旋转四元数</span></span><br><span class="line">  <span class="function">tf2::Quaternion <span class="title">gnss_q</span><span class="params">(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z,</span></span></span><br><span class="line"><span class="params"><span class="function">                        input-&gt;pose.orientation.w)</span></span>;</span><br><span class="line">  <span class="comment">// 将位置四元数转换为旋转矩阵gnss_m</span></span><br><span class="line">  <span class="function">tf2::Matrix3x3 <span class="title">gnss_m</span><span class="params">(gnss_q)</span></span>;</span><br><span class="line">  <span class="comment">// current_gnss_pose表示当前GNSS的位置</span></span><br><span class="line">  pose current_gnss_pose;</span><br><span class="line">  current_gnss_pose.x = input-&gt;pose.position.x;</span><br><span class="line">  current_gnss_pose.y = input-&gt;pose.position.y;</span><br><span class="line">  current_gnss_pose.z = input-&gt;pose.position.z;</span><br><span class="line">  <span class="comment">// 利用gnss_m.getRPY得到旋转矩阵的RPY旋转角，分别以三个参数输出</span></span><br><span class="line">  gnss_m.<span class="built_in">getRPY</span>(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> pose previous_gnss_pose = current_gnss_pose;</span><br><span class="line">  <span class="comment">//记录当前接受到GNSS消息的时间</span></span><br><span class="line">  ros::Time current_gnss_time = input-&gt;header.stamp;</span><br><span class="line">  <span class="type">static</span> ros::Time previous_gnss_time = current_gnss_time;</span><br><span class="line">  <span class="comment">//如果使用GNSS且初始位置为0或fitness_score&gt;=500,则进行GNSS重定位，并计算当前位置与先前位置的偏差</span></span><br><span class="line">  <span class="comment">//注意：ndt的fitness_score越低越好，一般小于1</span></span><br><span class="line">  <span class="keyword">if</span> ((_use_gnss == <span class="number">1</span> &amp;&amp; init_pos_set == <span class="number">0</span>) || fitness_score &gt;= _gnss_reinit_fitness)</span><br><span class="line">  &#123;</span><br><span class="line">    previous_pose.x = previous_gnss_pose.x;</span><br><span class="line">    previous_pose.y = previous_gnss_pose.y;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">  &#125;</span><br><span class="line">  previous_gnss_pose.x = current_gnss_pose.x;</span><br><span class="line">  <span class="comment">//...(下略)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-map-callback函数"><a href="#④-map-callback函数" class="headerlink" title="④ map_callback函数"></a>④ map_callback函数</h5><p>​ map_callback函数主要用于载入激光雷达数据作为初始全局地图map，并将初始全局地图map作为ndt配准算法的目标点云。函数按收到的 sensor_msgs::PointCloud2 类型的点云数据为输入参数，首先判断地图尺寸 points_map_num 与输入点云的宽度是否相等。初始状态时 points_map_num 默认为 0。车辆处于初始状态时，激光点云地图未加载，此时更新 map 地图大小为输入激光点云的大小。利用 pcl::fromROSMsg 函数将输入点云进行转换，并保存至map。最后根据方法类型的不同，对 NDT 参数进行设置，主要设置网格大小、NDT 算法的目标点云、最大迭代次数、最大迭代步长以及收敛阈值Epsilon，添加最大迭代次数能够增加程序鲁棒性，避免程序在错误迭代方向运行时间过长。最后代码利用 4 阶单位矩阵作为初始变换矩阵，来对第一帧点云进行配准，输出结果保存至output_cloud，至此地图加载成功。下面为详细代码注解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">map_callback</span><span class="params">(<span class="type">const</span> sensor_msgs::PointCloud2::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 若points_map_num不等于输入点云宽度，更新点云参数</span></span><br><span class="line">  <span class="keyword">if</span> (points_map_num != input-&gt;width)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Update points_map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    points_map_num = input-&gt;width;</span><br><span class="line">    <span class="comment">// 将输入激光点云类型从sensor_msgs::PointCloud2转换为pcl类型</span></span><br><span class="line">    pcl::<span class="built_in">fromROSMsg</span>(*input, map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_use_local_transform == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 如果局部变换存在，向外广播局部变换</span></span><br><span class="line">      <span class="comment">// local_transform表示world坐标系与map坐标系之间的变换</span></span><br><span class="line">      tf2_ros::Buffer tf_buffer;</span><br><span class="line">      <span class="function">tf2_ros::TransformListener <span class="title">tf_listener</span><span class="params">(tf_buffer)</span></span>;</span><br><span class="line">      geometry_msgs::TransformStamped local_transform_msg;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">        local_transform_msg = tf_buffer.<span class="built_in">lookupTransform</span>(<span class="string">&quot;map&quot;</span>, <span class="string">&quot;world&quot;</span>, ros::Time::<span class="built_in">now</span>(), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span> (tf2::TransformException&amp; ex)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将map坐标系转换为world坐标系</span></span><br><span class="line">      tf2::<span class="built_in">fromMsg</span>(local_transform_msg, local_transform);</span><br><span class="line">      pcl::<span class="built_in">transformPointCloud</span>(map, map, tf2::<span class="built_in">transformToEigen</span>(local_transform_msg).<span class="built_in">matrix</span>().<span class="built_in">inverse</span>().<span class="built_in">cast</span>&lt;<span class="type">float</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">map_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;(map))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据方法类型不同设置要进行ndt配准的点云</span></span><br><span class="line">    <span class="keyword">if</span> (_method_type == MethodType::PCL_GENERIC)</span><br><span class="line">    &#123;</span><br><span class="line">      pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;</span><br><span class="line">      pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">output_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">      <span class="comment">// 设置网格大小</span></span><br><span class="line">      new_ndt.<span class="built_in">setResolution</span>(ndt_res);</span><br><span class="line">      <span class="comment">// 将map_ptr作为ndt输入点云</span></span><br><span class="line">      new_ndt.<span class="built_in">setInputTarget</span>(map_ptr);</span><br><span class="line">      <span class="comment">// 设置最大迭代次数</span></span><br><span class="line">      new_ndt.<span class="built_in">setMaximumIterations</span>(max_iter);</span><br><span class="line">      <span class="comment">// 设置步长大小</span></span><br><span class="line">      new_ndt.<span class="built_in">setStepSize</span>(step_size);</span><br><span class="line">      new_ndt.<span class="built_in">setTransformationEpsilon</span>(trans_eps);</span><br><span class="line">      <span class="comment">// 利用单位矩阵作为初始坐标变换矩阵来进行ndt配准</span></span><br><span class="line">      <span class="comment">// 此时为第一帧点云配准</span></span><br><span class="line">      new_ndt.<span class="built_in">align</span>(*output_cloud, Eigen::Matrix4f::<span class="built_in">Identity</span>());</span><br><span class="line">      <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">      ndt = new_ndt;</span><br><span class="line">      <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...（下略）</span></span><br><span class="line">    <span class="comment">// 地图载入成功</span></span><br><span class="line">    map_loaded = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑤-points-callback-函数"><a href="#⑤-points-callback-函数" class="headerlink" title="⑤ points_callback 函数"></a>⑤ points_callback 函数</h5><p>​ 该回调函数主要进行多传感器之间的融合定位。函数首先融合 IMU 和odom 数据得到较为准确的位置估计，然后利用 filtered_points 将点云数据加入到 NDT 的算法内，计算得到一个 NDT 的预测位姿。最后，该位姿与 IMU 和 odom 融合得到的位姿进行比较，得出更准确的位姿。</p><p>​ Points_callback 回调函数以接收到的激光点云数据为输入参数，当全局点云地图载入成功并且车辆位姿初始化成功之后，ndt_matching 开始配准。代码利用<br>std:chrono::system_clock::now 函数来获取当前系统的时间并将其作为定位匹配的起始时间 matching_start。然后获取当前接收到的激光点云时间戳作为当前扫描时间current_scan_time。利用 pcl::fromROSMsg 函数将输入点云转换为 pcl::PointCloud&lt; pcl:PointXYZ &gt;类型的点云数据并存储于 filtered_scan。最后将filtered_scan 作为 NDT 算法的输入源点云，与 NDT 算法目标点云全局地图 map 进行匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">points_callback</span><span class="params">(<span class="type">const</span> sensor_msgs::PointCloud2::ConstPtr&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  health_checker_ptr_-&gt;<span class="built_in">CHECK_RATE</span>(<span class="string">&quot;topic_rate_filtered_points_slow&quot;</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="string">&quot;topic filtered_points subscribe rate slow.&quot;</span>);</span><br><span class="line">  <span class="comment">// 默认地图载入状态为0</span></span><br><span class="line">  <span class="keyword">if</span> (map_loaded == <span class="number">1</span> &amp;&amp; init_pos_set == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取配准开始时间</span></span><br><span class="line">    matching_start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> tf2_ros::TransformBroadcaster br;</span><br><span class="line">    tf2::Transform transform;</span><br><span class="line">    tf2::Quaternion predict_q, ndt_q, current_q, localizer_q;</span><br><span class="line"></span><br><span class="line">    pcl::PointXYZ p;</span><br><span class="line">    <span class="comment">// 声明pcl::PointCloud&lt;pcl::PointXYZ&gt;类型的点云数据用来储存过滤后的点云</span></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;</span><br><span class="line">    <span class="comment">// 获取当前接收点云的扫描时间</span></span><br><span class="line">    ros::Time current_scan_time = input-&gt;header.stamp;</span><br><span class="line">    <span class="type">static</span> ros::Time previous_scan_time = current_scan_time;</span><br><span class="line">    <span class="comment">// 将当前sensor_msgs::PointCloud2转化为PCL类型</span></span><br><span class="line">    pcl::<span class="built_in">fromROSMsg</span>(*input, filtered_scan);</span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">filtered_scan_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan))</span></span>;</span><br><span class="line">    <span class="comment">// 获取点云数量</span></span><br><span class="line">    <span class="type">int</span> scan_points_num = filtered_scan_ptr-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 单位矩阵初始化车身底盘base_link和localizer关于原点的坐标变换矩阵</span></span><br><span class="line">    <span class="function">Eigen::Matrix4f <span class="title">t</span><span class="params">(Eigen::Matrix4f::Identity())</span></span>;   <span class="comment">// base_link</span></span><br><span class="line">    <span class="function">Eigen::Matrix4f <span class="title">t2</span><span class="params">(Eigen::Matrix4f::Identity())</span></span>;  <span class="comment">// localizer</span></span><br><span class="line">    <span class="comment">// 声明配准起止时间与getFitnessScore起止时间</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; align_start, align_end, getFitnessScore_start,</span><br><span class="line">        getFitnessScore_end;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> align_time, getFitnessScore_time = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">// 按照不同方法类型将filtered_scan_ptr作为ndt输入点云</span></span><br><span class="line">    <span class="keyword">if</span> (_method_type == MethodType::PCL_GENERIC)</span><br><span class="line">      ndt.<span class="built_in">setInputSource</span>(filtered_scan_ptr);</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br></pre></td></tr></table></figure><p>​ 该代码主要计算得出 NDT 配准算法所需要的初始位姿。offset 有三种情况，当 offset 为线性值的时候，利用匀速运动模型计算出 offset 的大小;当 offset 为二次模型，即加速度不为0的时候。offset 的x与y方向的分量利用vt+(1&#x2F;2)at^2求出，y方向的分量与偏航角保持匀速运动模型；第三种情况是 offset 为 0。代码利用previous_pose (前一帧位姿)+offset(两帧时间内的偏差量)得到 predict_pose (当前预测的车辆位姿)。然后代码根据 imu、odom 的使用情况估计 NDT 所需当前初始位姿，这一步与ndt mapping 类似。最后如果使用传感器来获取位姿，则将相应传感器估计得到的当前位姿作为 predict_pose_for_ndt (ndt 配准所需的初值），否则将 predict_pose (当前预测的车辆位姿）作为 NDT 配准所需的初值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算前后两帧激光扫描时间差</span></span><br><span class="line">   <span class="type">double</span> diff_time = (current_scan_time - previous_scan_time).<span class="built_in">toSec</span>();</span><br><span class="line">   <span class="comment">// _offset为线性时，位置偏差和航向角等于速度乘前后帧时间差</span></span><br><span class="line">   <span class="keyword">if</span> (_offset == <span class="string">&quot;linear&quot;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     offset_x = current_velocity_x * diff_time;</span><br><span class="line">     offset_y = current_velocity_y * diff_time;</span><br><span class="line">     offset_z = current_velocity_z * diff_time;</span><br><span class="line">     offset_yaw = angular_velocity * diff_time;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// _offset为二次类型，则利用vt+at^2表示x、y，z、yaw与线性一致</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (_offset == <span class="string">&quot;quadratic&quot;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     offset_x = (current_velocity_x + current_accel_x * diff_time) * diff_time;</span><br><span class="line">     offset_y = (current_velocity_y + current_accel_y * diff_time) * diff_time;</span><br><span class="line">     offset_z = current_velocity_z * diff_time;</span><br><span class="line">     offset_yaw = angular_velocity * diff_time;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (_offset == <span class="string">&quot;zero&quot;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     offset_x = <span class="number">0.0</span>;</span><br><span class="line">     offset_y = <span class="number">0.0</span>;</span><br><span class="line">     offset_z = <span class="number">0.0</span>;</span><br><span class="line">     offset_yaw = <span class="number">0.0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 估计位置的坐标xyz=前一帧+偏移量、rp角度与前一帧角度相等，yaw随车变化</span></span><br><span class="line">   predict_pose.x = previous_pose.x + offset_x;</span><br><span class="line">   predict_pose.y = previous_pose.y + offset_y;</span><br><span class="line">   predict_pose.z = previous_pose.z + offset_z;</span><br><span class="line">   predict_pose.roll = previous_pose.roll;</span><br><span class="line">   predict_pose.pitch = previous_pose.pitch;</span><br><span class="line">   predict_pose.yaw = previous_pose.yaw + offset_yaw;</span><br><span class="line">   <span class="comment">// 根据imu和odom使用情况，采用不同方法对ndt配准的初始位置进行计算，与mapping保持一致</span></span><br><span class="line">   <span class="keyword">if</span> (_use_imu == <span class="literal">true</span> &amp;&amp; _use_odom == <span class="literal">true</span>)</span><br><span class="line">     <span class="built_in">imu_odom_calc</span>(current_scan_time);</span><br><span class="line">   <span class="keyword">if</span> (_use_imu == <span class="literal">true</span> &amp;&amp; _use_odom == <span class="literal">false</span>)</span><br><span class="line">     <span class="built_in">imu_calc</span>(current_scan_time);</span><br><span class="line">   <span class="keyword">if</span> (_use_imu == <span class="literal">false</span> &amp;&amp; _use_odom == <span class="literal">true</span>)</span><br><span class="line">     <span class="built_in">odom_calc</span>(current_scan_time);</span><br><span class="line">   <span class="comment">// 根据使用方法不同，赋予ndt位置预测初值</span></span><br><span class="line">   pose predict_pose_for_ndt;</span><br><span class="line">   <span class="keyword">if</span> (_use_imu == <span class="literal">true</span> &amp;&amp; _use_odom == <span class="literal">true</span>)</span><br><span class="line">     predict_pose_for_ndt = predict_pose_imu_odom;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (_use_imu == <span class="literal">true</span> &amp;&amp; _use_odom == <span class="literal">false</span>)</span><br><span class="line">     predict_pose_for_ndt = predict_pose_imu;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (_use_imu == <span class="literal">false</span> &amp;&amp; _use_odom == <span class="literal">true</span>)</span><br><span class="line">     predict_pose_for_ndt = predict_pose_odom;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     predict_pose_for_ndt = predict_pose;</span><br></pre></td></tr></table></figure><p>​ 该部分代码主要求出激光雷达坐标系相对于全局地图坐标系的初始变换矩阵init_guess, 该矩阵的计算需要补偿一个变换矩阵tf_btol,即车身底盘坐标系 base_link到激光雷达坐标系的变换矩阵，这一变换矩阵由 main 函数得出。代码获取当前系统时间戳作为 NDT 配准起始时间，然后利用 ndt.align(*output_cloud, init_guess) 函数以初始变换矩阵 init_guess 为参数，得到输出点云 output_cloud，然后计算 NDT 配准的结果，最后计算配准时间。t *tf_btol.inverse函数得到车身底盘相对于全局地图坐标系的最终变换矩阵t2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将predict_pose_for_ndt位置的xyz坐标作为init_translation初始平移的构造函数参数</span></span><br><span class="line"><span class="function">Eigen::Translation3f <span class="title">init_translation</span><span class="params">(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z)</span></span>;</span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation_x</span><span class="params">(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX())</span></span>;</span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation_y</span><span class="params">(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY())</span></span>;</span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation_z</span><span class="params">(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ())</span></span>;</span><br><span class="line"><span class="comment">// init_guess表示激光雷达坐标系相对于全局地图坐标系的坐标变换矩阵</span></span><br><span class="line">Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;</span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">output_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="comment">// 根据不同方法进行ndt配准</span></span><br><span class="line"><span class="keyword">if</span> (_method_type == MethodType::PCL_GENERIC)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取当前时间戳作为配准开始时间</span></span><br><span class="line">  align_start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="comment">// 利用初始变换矩阵init_guess进行ndt配准，将结果存到output_cloud</span></span><br><span class="line">  ndt.<span class="built_in">align</span>(*output_cloud, init_guess);</span><br><span class="line">  <span class="comment">// 获取配准结束时间</span></span><br><span class="line">  align_end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="comment">// 是否收敛</span></span><br><span class="line">  has_converged = ndt.<span class="built_in">hasConverged</span>();</span><br><span class="line">  <span class="comment">// 获取ndt配准最终变换矩阵</span></span><br><span class="line">  t = ndt.<span class="built_in">getFinalTransformation</span>();</span><br><span class="line">  <span class="comment">// 得到迭代次数</span></span><br><span class="line">  iteration = ndt.<span class="built_in">getFinalNumIteration</span>();</span><br><span class="line"></span><br><span class="line">  getFitnessScore_start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  fitness_score = ndt.<span class="built_in">getFitnessScore</span>();</span><br><span class="line">  getFitnessScore_end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  trans_probability = ndt.<span class="built_in">getTransformationProbability</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算配准时间</span></span><br><span class="line">align_time = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(align_end - align_start).<span class="built_in">count</span>() / <span class="number">1000.0</span>;</span><br><span class="line"><span class="comment">// 计算此时车身底盘相对于全局地图坐标系的最终变换矩阵</span></span><br><span class="line">t2 = t * tf_btol.<span class="built_in">inverse</span>();</span><br><span class="line">getFitnessScore_time =</span><br><span class="line">    std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).<span class="built_in">count</span>() /</span><br><span class="line">    <span class="number">1000.0</span>;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure><p>​ 该代码主要计算当前激光雷达与车身底盘相对于全局地图坐标系的位姿。激光雷达 localizer 相对于全局地图 map 的旋转矩阵mat_l和位置坐标 localizer_pose.x, localizer_pose.y, localizer_pose.z 由 NDT 配准得到的变换矩阵 <em>t</em> 求得。代码利用mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1） 函数求出激光雷达的旋转欧拉角rpy。同理，利用 <em>t2</em> (车身底盘相对于 map 的变换矩阵）求出ndt_pose(ndt 算法得到的车体相对于 map 的位姿)。然后代码将 NDT 配准算法得到的车辆定位 ndt_pose 与 ndt 算法提供的初值 predict_pose_for_ndt 进行比较，求出两者之间的误差 predict_pose_error。当误差小于阈值 PREDICT_POSE_THRESHOLD时，使用ndt_pose 作为当前位姿估计 current_pose，否则使用 predict_pose_for_ndt作为 current_pose。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localizer的旋转矩阵</span></span><br><span class="line">tf2::Matrix3x3 mat_l;</span><br><span class="line"><span class="comment">// 将ndt最终变换的矩阵赋予mat_l</span></span><br><span class="line">mat_l.<span class="built_in">setValue</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">0</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">0</span>, <span class="number">1</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">0</span>, <span class="number">2</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">1</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">1</span>, <span class="number">1</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">1</span>, <span class="number">2</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">2</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">2</span>, <span class="number">1</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t</span>(<span class="number">2</span>, <span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新localizer_pose的位置向量</span></span><br><span class="line">localizer_pose.x = <span class="built_in">t</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">localizer_pose.y = <span class="built_in">t</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">localizer_pose.z = <span class="built_in">t</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 最终变换的旋转rpy角度值赋予localizer_pose的rpy角度值</span></span><br><span class="line">mat_l.<span class="built_in">getRPY</span>(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 相对于base_link的旋转矩阵mat_b由t2变换矩阵赋值</span></span><br><span class="line">tf2::Matrix3x3 mat_b;  <span class="comment">// base_link</span></span><br><span class="line">mat_b.<span class="built_in">setValue</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">0</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">0</span>, <span class="number">1</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">0</span>, <span class="number">2</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">1</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">1</span>, <span class="number">1</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">1</span>, <span class="number">2</span>)),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">2</span>, <span class="number">0</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">2</span>, <span class="number">1</span>)), <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">t2</span>(<span class="number">2</span>, <span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ndt_pose的坐标由车身底盘相对于map的平移向量来赋值，计算车辆在全局地图坐标系下的位置</span></span><br><span class="line">ndt_pose.x = <span class="built_in">t2</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">ndt_pose.y = <span class="built_in">t2</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">ndt_pose.z = <span class="built_in">t2</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">mat_b.<span class="built_in">getRPY</span>(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算ndt_pose和predict_pose间的误差</span></span><br><span class="line">predict_pose_error = <span class="built_in">sqrt</span>((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) +</span><br><span class="line">                          (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) +</span><br><span class="line">                          (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));</span><br><span class="line"><span class="comment">//...(下略)</span></span><br></pre></td></tr></table></figure><p>​ 该部分代码主要发布 base link 坐标系到全局地图坐标系 map 之间的变换关系，主要通过 sendTransform 函数进行变换消息的广播，其中，第一个参数为 base link到 map 的坐标变换 transform，第二个参数为发布时间，第三个参数为父坐标系 map,最后一个参数为子坐标系 base_link。然后计算并发送ndt_matching 匹配定位的耗时time_ndt_matching.data，最后发布 NDT 的状态参数信息，current_scan_time, time_ndt_matching.data, iteration, fitness_score, current_velocity, current _accel.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...(上略)</span></span><br><span class="line"><span class="comment">// 注：current_pose 经由 vel_pose_mux 发布</span></span><br><span class="line"><span class="comment">// 发布车辆预测位姿</span></span><br><span class="line">predict_pose_pub.<span class="built_in">publish</span>(predict_pose_msg);</span><br><span class="line">health_checker_ptr_-&gt;<span class="built_in">CHECK_RATE</span>(<span class="string">&quot;topic_rate_ndt_pose_slow&quot;</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="string">&quot;topic ndt_pose publish rate slow.&quot;</span>);</span><br><span class="line"><span class="comment">// 发布ndt位姿</span></span><br><span class="line">ndt_pose_pub.<span class="built_in">publish</span>(ndt_pose_msg);</span><br><span class="line"><span class="comment">// 发布激光雷达当前预测位姿</span></span><br><span class="line">localizer_pose_pub.<span class="built_in">publish</span>(localizer_pose_msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布 TF &quot;base_link&quot; -&gt; &quot;map&quot;</span></span><br><span class="line">transform.<span class="built_in">setOrigin</span>(tf2::<span class="built_in">Vector3</span>(current_pose.x, current_pose.y, current_pose.z));</span><br><span class="line">transform.<span class="built_in">setRotation</span>(current_q);</span><br><span class="line"><span class="keyword">if</span> (_use_local_transform == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  transform = local_transform * transform;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tf2::Stamped&lt;tf2::Transform&gt; <span class="title">tf</span><span class="params">(transform, current_scan_time, <span class="string">&quot;map&quot;</span>)</span></span>;</span><br><span class="line">geometry_msgs::TransformStamped tf_msg = tf2::<span class="built_in">toMsg</span>(tf);</span><br><span class="line">tf_msg.child_frame_id = _output_tf_frame_id;</span><br><span class="line">br.<span class="built_in">sendTransform</span>(tf_msg);</span><br><span class="line"><span class="comment">// 记录匹配结束时间</span></span><br><span class="line">matching_end = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// 记录匹配耗时，存入time_ndt_matching.data并发布</span></span><br><span class="line">exe_time = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(matching_end - matching_start).<span class="built_in">count</span>() / <span class="number">1000.0</span>;</span><br><span class="line">time_ndt_matching.data = exe_time;</span><br><span class="line">health_checker_ptr_-&gt;<span class="built_in">CHECK_MAX_VALUE</span>(<span class="string">&quot;time_ndt_matching&quot;</span>, time_ndt_matching.data, <span class="number">50</span>, <span class="number">70</span>, <span class="number">100</span>, <span class="string">&quot;value time_ndt_matching is too high.&quot;</span>);</span><br><span class="line"><span class="comment">// 发布配准时间信息</span></span><br><span class="line">time_ndt_matching_pub.<span class="built_in">publish</span>(time_ndt_matching);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置预计速度信息/estimate_twist并发布</span></span><br><span class="line">estimate_twist_msg.header.stamp = current_scan_time;</span><br><span class="line"><span class="comment">//...(下略)</span></span><br><span class="line">estimated_vel_pub.<span class="built_in">publish</span>(estimate_vel_msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置ndt状态信息/ndt_stat并发布</span></span><br><span class="line">ndt_stat_msg.header.stamp = current_scan_time;</span><br><span class="line"><span class="comment">//...(下略)</span></span><br><span class="line">ndt_reliability_pub.<span class="built_in">publish</span>(ndt_reliability);</span><br></pre></td></tr></table></figure><p>​ 最后一部分代码更新当前位姿 current_pose 为上一帧的位姿 previous_pose，速度做同样处理，为下次的ndt_matching 匹配定位做铺垫。ndt_matching 节点的odom_callback 与 imu_callback 这两个回调函数与 ndt_mapping节点里的同名回调函数内容是相同的，这里不再赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 相邻两帧的位姿偏差归零</span></span><br><span class="line">    offset_imu_x = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">    offset_odom_x = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">    offset_imu_odom_x = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前位姿为上一帧位姿</span></span><br><span class="line">    previous_pose.x = current_pose.x;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前扫描时间为上一帧扫描时间</span></span><br><span class="line">    previous_scan_time = current_scan_time;</span><br><span class="line">    <span class="comment">// 更新速度</span></span><br><span class="line">    previous_previous_velocity = previous_velocity;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑥-thread-func函数"><a href="#⑥-thread-func函数" class="headerlink" title="⑥ thread_func函数"></a>⑥ thread_func函数</h5><p>​ thread_func函数主要是额外开启一个线程检测并更新地图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_func</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 开启一个线程检测并更新地图</span></span><br><span class="line">  ros::NodeHandle nh_map;</span><br><span class="line">  ros::CallbackQueue map_callback_queue;</span><br><span class="line">  nh_map.<span class="built_in">setCallbackQueue</span>(&amp;map_callback_queue);</span><br><span class="line"></span><br><span class="line">  ros::Subscriber map_sub = nh_map.<span class="built_in">subscribe</span>(<span class="string">&quot;points_map&quot;</span>, <span class="number">10</span>, map_callback);</span><br><span class="line">  <span class="function">ros::Rate <span class="title">ros_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (nh_map.<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    map_callback_queue.<span class="built_in">callAvailable</span>(ros::<span class="built_in">WallDuration</span>());</span><br><span class="line">    ros_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-参考文献"><a href="#3-3-参考文献" class="headerlink" title="3.3    参考文献"></a>3.3 参考文献</h3><p><a target="_blank" rel="noopener" href="https://www.researchgate.net/publication/4045903_The_Normal_Distributions_Transform_A_New_Approach_to_Laser_Scan_Matching">[1] Biber P, Straßer W. The normal distributions transform: A new approach to laser scan matching[C] IROS 2003 . IEEE, 2003, 3: 2743-2748.</a></p><p><a target="_blank" rel="noopener" href="http://130.243.105.49/Research/mro/publications/2009/Magnusson_2009-Doctoral_Thesis-3D_NDT.pdf">[2] Merten H. The three-dimensional normal-distributions transform[J]. threshold, 2008, 10: 3.</a></p><p>[3] 双愚. PCL(Point Cloud Library)学习指南&amp;资料推荐（2023版）[OB&#x2F;OL]. [2023-02-05].<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268524083">https://zhuanlan.zhihu.com/p/268524083</a>.</p><p>[4] Badue C, Guidolini R, Carneiro R V, et al. Self-driving cars: A survey [J]. arXiv: Robotics, 2019.</p><p>[5] 高翔,张涛等. 视觉 SLAM 十四讲：从理论到实践[M]，北京：电子工业出版社，2017.</p><p>[6] Adam Shan. 无人驾驶汽车系统入门(十三）一正态分布变换 (NDT) 配准与无人车定位[DB&#x2F;OL]. [2020-04-11]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/AdamShan/article/details/79230612">https://blog.csdn.net/AdamShan/article/details/79230612</a>.</p><p>[7] Martin M. The Three-dimensional normal-distributions transform - An efficient representation for registration, surface analysis, and loop detection[D]. Orebro: Orebro University, 2009.</p><p>[8] 田大新,段续庭等. Autoware与自动驾驶技术，北京：科学出版社，2020.</p><p><span id="jump4.0"></span></p><h2 id="四、Autoware-决策规划模块解析"><a href="#四、Autoware-决策规划模块解析" class="headerlink" title="四、Autoware 决策规划模块解析"></a>四、Autoware 决策规划模块解析</h2><p>​ Autoware的决策规划模块主要时基于感知的输出结果，进行全局路径规划和局部路径规划。全局路径规划在车辆启动或重启的时候被确定，局部路径根据车辆的状态实时更新。例如，如果车辆在障碍物前或在停止线前，车辆状态变为“stop”，那么车辆的速度就被规划为0。如果车辆遇到一个障碍物且状态为“avoid”，那么局部跟踪路径就会被重新规划绕过障碍物，基础节点及他们之间的关系（话题之间的订阅&#x2F;发布）如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/nodes_for_ctrl.png" alt="nodes_for_ctrl"></p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/nodes_for_vel.png" alt="nodes_for_vel"></p><p>​ 本节对Autoware决策规划模块内的基础ROS节点（waypoint_loader, waypoint_replanner, lane_rule, lane_select, astar_avoid,velocity_set, pure_pursuit等节点）做简略分析。</p><p><span id="jump4.1"></span></p><h3 id="4-1-节点waypoint-loader"><a href="#4-1-节点waypoint-loader" class="headerlink" title="4.1    节点waypoint_loader"></a>4.1 节点waypoint_loader</h3><p>​ 节点<code>waypoint_loader</code>的主要作用：从本地文件加载采集的轨迹点。</p><h4 id="4-1-1-启动方法"><a href="#4-1-1-启动方法" class="headerlink" title="4.1.1    启动方法"></a>4.1.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li>roslaunch waypoint_maker waypoint_loader.launch</li></ul></li><li><p>从Runtime Manager启动:</p></li></ul><p>​ 打开Runtime Manager，上方computing 选项卡 -&gt; Motion Planning -&gt;waypoint_maker-&gt;waypoint_loader，单击 [app] 按钮可更改设置等参数。</p><h4 id="4-1-2-程序路径"><a href="#4-1-2-程序路径" class="headerlink" title="4.1.2    程序路径"></a>4.1.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码路径</span></span><br><span class="line">src/autoware/core_planning/waypoint_maker/nodes/waypoint_loader</span><br></pre></td></tr></table></figure><h4 id="4-1-3-参数详情"><a href="#4-1-3-参数详情" class="headerlink" title="4.1.3    参数详情"></a>4.1.3 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>multi_lane_csv</code></td><td><em>string</em></td><td>路标点文件</td></tr></tbody></table><h4 id="4-1-4-主要结构体"><a href="#4-1-4-主要结构体" class="headerlink" title="4.1.4    主要结构体"></a>4.1.4 主要结构体</h4><p>​ autoware_msg::Lane结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">autoware_msgs::Lane</span><br><span class="line">&#123;</span><br><span class="line">    Header header</span><br><span class="line">    int32 increment</span><br><span class="line">    int32 lane_id</span><br><span class="line">    Waypoint[] waypoints</span><br><span class="line"></span><br><span class="line">    uint32 lane_index</span><br><span class="line">    float32 cost</span><br><span class="line">    float32 closest_object_distance</span><br><span class="line">    float32 closest_object_velocity</span><br><span class="line">    <span class="type">bool</span> is_blocked</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std_msgs::Header</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    uint32 seq</span><br><span class="line">    <span class="comment">//时间戳</span></span><br><span class="line">    time stamp</span><br><span class="line">    <span class="comment">//表示数据来源于哪一个frame</span></span><br><span class="line">    string frame_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">autoware_msgs::Waypoint</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//全局id</span></span><br><span class="line">    int32 gid </span><br><span class="line">    <span class="comment">//局部id</span></span><br><span class="line">    int32 lid </span><br><span class="line">    <span class="comment">//位姿信息</span></span><br><span class="line">    geometry_msgs/PoseStamped pose</span><br><span class="line">    <span class="comment">//速度，角速度等信息</span></span><br><span class="line">    geometry_msgs/TwistStamped twist</span><br><span class="line">    <span class="comment">//道路信息</span></span><br><span class="line">    DTLane dtlane</span><br><span class="line">    int32 change_flag</span><br><span class="line">    <span class="comment">//路点信息</span></span><br><span class="line">    WaypointState wpstate</span><br><span class="line"></span><br><span class="line">    uint32 lane_id</span><br><span class="line">    uint32 left_lane_id</span><br><span class="line">    uint32 right_lane_id</span><br><span class="line">    uint32 stop_line_id</span><br><span class="line">    float32 cost</span><br><span class="line">    float32 time_cost</span><br><span class="line"></span><br><span class="line">    # Lane Direction</span><br><span class="line">    # FORWARD        = <span class="number">0</span></span><br><span class="line">    # FORWARD_LEFT       = <span class="number">1</span></span><br><span class="line">    # FORWARD_RIGHT      = <span class="number">2</span></span><br><span class="line">    # BACKWARD        = <span class="number">3</span> </span><br><span class="line">    # BACKWARD_LEFT      = <span class="number">4</span></span><br><span class="line">    # BACKWARD_RIGHT    = <span class="number">5</span></span><br><span class="line">    # STANDSTILL       = <span class="number">6</span></span><br><span class="line">    uint32 direction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/PoseStamped</span><br><span class="line">&#123;</span><br><span class="line">    Header header</span><br><span class="line">    Pose pose</span><br><span class="line">&#125;</span><br><span class="line">geometry_msgs/Pose</span><br><span class="line">&#123;</span><br><span class="line">    Point position</span><br><span class="line">    Quaternion orientation</span><br><span class="line">&#125;</span><br><span class="line">geometry_msgs/Point</span><br><span class="line">&#123;</span><br><span class="line">    float64 x</span><br><span class="line">    float64 y</span><br><span class="line">    float64 z</span><br><span class="line">&#125;</span><br><span class="line">geometry_msgs/Quaternion</span><br><span class="line">&#123;</span><br><span class="line">    float64 x</span><br><span class="line">    float64 y</span><br><span class="line">    float64 z</span><br><span class="line">    float64 w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/TwistStamped</span><br><span class="line">&#123;</span><br><span class="line">    Header header</span><br><span class="line">    Twist twist</span><br><span class="line">&#125;</span><br><span class="line">geometry_msgs/Twist</span><br><span class="line">&#123;</span><br><span class="line">    Vector3  linear</span><br><span class="line">    Vector3  angular</span><br><span class="line">&#125;</span><br><span class="line">geometry_msgs/Vector3</span><br><span class="line">&#123;</span><br><span class="line">    float64 x</span><br><span class="line">    float64 y</span><br><span class="line">    float64 z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-5-代码注解"><a href="#4-1-5-代码注解" class="headerlink" title="4.1.5    代码注解"></a>4.1.5 代码注解</h4><h5 id="①-main函数-1"><a href="#①-main函数-1" class="headerlink" title="① main函数"></a>① main函数</h5><p>​ main函数在<code>waypoint_loader_node.cpp</code>中，节点的功能主要通过WaypointLoaderNode对象的run函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;waypoint_loader&quot;</span>);</span><br><span class="line">     waypoint_maker::WaypointLoaderNode wln;</span><br><span class="line">     wln.<span class="built_in">run</span>();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="②-run函数"><a href="#②-run函数" class="headerlink" title="② run函数"></a>② run函数</h5><p>​ 读取存储的轨迹点文件数据，并发布至话题“&#x2F;based&#x2F;lane_waypoints_raw”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaypointLoaderNode::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     multi_file_path_.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="built_in">parseColumns</span>(multi_lane_csv_, &amp;multi_file_path_);</span><br><span class="line">     autoware_msgs::LaneArray lane_array;</span><br><span class="line">     <span class="built_in">createLaneArray</span>(multi_file_path_, &amp;lane_array);</span><br><span class="line">     lane_pub_.<span class="built_in">publish</span>(lane_array);</span><br><span class="line">     output_lane_array_ = lane_array;</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③-parseColumns函数"><a href="#③-parseColumns函数" class="headerlink" title="③ parseColumns函数"></a>③ parseColumns函数</h5><p>​ parseColumns函数以”，“ 作为分隔符号将字符串line分成若干段，并将其中的空格全部去除，依次储存至字符串向量columns中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parseColumns</span><span class="params">(<span class="type">const</span> std::string&amp; line, std::vector&lt;std::string&gt;* columns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::istringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">  std::string column;</span><br><span class="line">  <span class="comment">//以”，“为分隔符截取字符串中的每一段</span></span><br><span class="line">  <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, column, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//将每段字符串中的空格删除  </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;   </span><br><span class="line">      <span class="comment">//返回区间[begin()，end()）中第一个值等于&quot; &quot;的元素位置；若未找到，返回end。返回的是迭代器或指针，即位置信息</span></span><br><span class="line">      <span class="keyword">auto</span> res = std::<span class="built_in">find</span>(column.<span class="built_in">begin</span>(), column.<span class="built_in">end</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (res == column.<span class="built_in">end</span>())</span><br><span class="line">      &#123;   </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;   </span><br><span class="line">      column.<span class="built_in">erase</span>(res);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (!column.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;   </span><br><span class="line">      columns-&gt;<span class="built_in">emplace_back</span>(column);</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-createLaneArray函数"><a href="#④-createLaneArray函数" class="headerlink" title="④ createLaneArray函数"></a>④ createLaneArray函数</h5><p>​ 将paths中各个本地路径对应文件中包含的信息分别填入lane 中，再将lane依次填入lane_array</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaypointLoaderNode::createLaneWaypoint</span><span class="params">(<span class="type">const</span> std::string&amp; file_path, autoware_msgs::Lane* lane)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//检查文件file_path中数据是否合规</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">verifyFileConsistency</span>(file_path.<span class="built_in">c_str</span>()))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;lane data is something wrong...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;lane data is valid. publishing...&quot;</span>);</span><br><span class="line">  <span class="comment">//判断文件数据存储格式</span></span><br><span class="line">  FileFormat format = <span class="built_in">checkFileFormat</span>(file_path.<span class="built_in">c_str</span>());</span><br><span class="line">  std::vector&lt;autoware_msgs::Waypoint&gt; wps;</span><br><span class="line">  <span class="keyword">if</span> (format == FileFormat::ver1)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">loadWaypointsForVer1</span>(file_path.<span class="built_in">c_str</span>(), &amp;wps);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (format == FileFormat::ver2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">loadWaypointsForVer2</span>(file_path.<span class="built_in">c_str</span>(), &amp;wps);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//读取文件内容存入waypoints中</span></span><br><span class="line">    <span class="built_in">loadWaypointsForVer3</span>(file_path.<span class="built_in">c_str</span>(), &amp;wps);</span><br><span class="line">  &#125;</span><br><span class="line">  lane-&gt;header.frame_id = <span class="string">&quot;/map&quot;</span>;</span><br><span class="line">  lane-&gt;header.stamp = ros::<span class="built_in">Time</span>(<span class="number">0</span>);</span><br><span class="line">  lane-&gt;waypoints = wps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑤-verifyFileConsistency函数"><a href="#⑤-verifyFileConsistency函数" class="headerlink" title="⑤ verifyFileConsistency函数"></a>⑤ verifyFileConsistency函数</h5><p>​ verifyFileConsistency函数的作用时“验证文件一致性”。首先ifstream以输入的方式打开filename，如果打开失败则直接返回失败；如果成功则执行checkFileFormat函数，文件格式以下图为例</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/saved_waypoints_csv.png" alt="saved_waypoints_csv"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WaypointLoaderNode::verifyFileConsistency</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;verify...&quot;</span>);</span><br><span class="line">  <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ifs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查该文件内数据的存储格式</span></span><br><span class="line">  FileFormat format = <span class="built_in">checkFileFormat</span>(filename);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;format: %d&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(format));</span><br><span class="line">  <span class="keyword">if</span> (format == FileFormat::unknown)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;unknown file format&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string line;</span><br><span class="line">  <span class="comment">//删掉第一行</span></span><br><span class="line">  std::<span class="built_in">getline</span>(ifs, line);</span><br><span class="line">  <span class="type">size_t</span> ncol = format == FileFormat::ver1 ? <span class="number">4</span>  <span class="comment">// x,y,z,velocity</span></span><br><span class="line">                                             :</span><br><span class="line">                                             format == FileFormat::ver2 ? <span class="number">5</span>  <span class="comment">// x,y,z,yaw,velocity</span></span><br><span class="line">                                                                          :</span><br><span class="line">                                                                          <span class="built_in">countColumns</span>(line);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从第二行开始，检验每一行列数是否跟第一行列数一致</span></span><br><span class="line">  <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ifs, line))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">countColumns</span>(line) != ncol)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑥-checkFileFormat函数"><a href="#⑥-checkFileFormat函数" class="headerlink" title="⑥ checkFileFormat函数"></a>⑥ checkFileFormat函数</h5><p>​ 主要作用为判断文件格式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FileFormat <span class="title">WaypointLoaderNode::checkFileFormat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ifs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FileFormat::unknown;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取第一行</span></span><br><span class="line">  std::string line;</span><br><span class="line">  std::<span class="built_in">getline</span>(ifs, line);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分析第一行</span></span><br><span class="line">  std::vector&lt;std::string&gt; parsed_columns;</span><br><span class="line">  <span class="built_in">parseColumns</span>(line, &amp;parsed_columns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查第一个元素是否由数字组成</span></span><br><span class="line">  <span class="comment">// Note: 浮点型数字因为包含小数点，所以会返回False</span></span><br><span class="line">  <span class="keyword">if</span> (!std::<span class="built_in">any_of</span>(parsed_columns.<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">cbegin</span>(), parsed_columns.<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">cend</span>(), isdigit))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FileFormat::ver3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果元素只由数字组成，则以“，”作为分隔符，计算此行有几个元素组成</span></span><br><span class="line">  <span class="type">int</span> num_of_columns = <span class="built_in">countColumns</span>(line);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;columns size: %d&quot;</span>, num_of_columns);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (num_of_columns == <span class="number">3</span> ? FileFormat::ver1  <span class="comment">// &quot;x y z (velocity)&quot;</span></span><br><span class="line">                                :</span><br><span class="line">                                num_of_columns == <span class="number">4</span> ? FileFormat::ver2  <span class="comment">// &quot;x y z yaw (velocity)</span></span><br><span class="line">                                                      :</span><br><span class="line">                                                      FileFormat::unknown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑦loadWaypointsForVer3函数"><a href="#⑦loadWaypointsForVer3函数" class="headerlink" title="⑦loadWaypointsForVer3函数"></a>⑦loadWaypointsForVer3函数</h5><p>​ 加载文件内容并解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaypointLoaderNode::loadWaypointsForVer3</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, std::vector&lt;autoware_msgs::Waypoint&gt;* wps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ifs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string line;</span><br><span class="line">  std::<span class="built_in">getline</span>(ifs, line);  <span class="comment">// 读取第一行</span></span><br><span class="line">  std::vector&lt;std::string&gt; contents;</span><br><span class="line">  <span class="built_in">parseColumns</span>(line, &amp;contents);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从第二行开始解析</span></span><br><span class="line">  <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ifs, line))</span><br><span class="line">  &#123;</span><br><span class="line">    autoware_msgs::Waypoint wp;</span><br><span class="line">    <span class="comment">// 解析该行，构造waypoint结构体</span></span><br><span class="line">    <span class="built_in">parseWaypointForVer3</span>(line, contents, &amp;wp);</span><br><span class="line">    wps-&gt;<span class="built_in">emplace_back</span>(wp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑧parseWaypointForVer3函数"><a href="#⑧parseWaypointForVer3函数" class="headerlink" title="⑧parseWaypointForVer3函数"></a>⑧parseWaypointForVer3函数</h5><p>​ 解析输入字符串，构造waypoint结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaypointLoaderNode::parseWaypointForVer3</span><span class="params">(<span class="type">const</span> std::string&amp; line, <span class="type">const</span> std::vector&lt;std::string&gt;&amp; contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              autoware_msgs::Waypoint* wp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; columns;</span><br><span class="line">  <span class="built_in">parseColumns</span>(line, &amp;columns);</span><br><span class="line">  std::unordered_map&lt;std::string, std::string&gt; map;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; contents.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    map[contents.<span class="built_in">at</span>(i)] = columns.<span class="built_in">at</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wp-&gt;pose.pose.position.x = std::<span class="built_in">stod</span>(map[<span class="string">&quot;x&quot;</span>]);</span><br><span class="line">  wp-&gt;pose.pose.position.y = std::<span class="built_in">stod</span>(map[<span class="string">&quot;y&quot;</span>]);</span><br><span class="line">  wp-&gt;pose.pose.position.z = std::<span class="built_in">stod</span>(map[<span class="string">&quot;z&quot;</span>]);</span><br><span class="line">  wp-&gt;pose.pose.orientation = tf::<span class="built_in">createQuaternionMsgFromYaw</span>(std::<span class="built_in">stod</span>(map[<span class="string">&quot;yaw&quot;</span>]));</span><br><span class="line">  wp-&gt;twist.twist.linear.x = <span class="built_in">kmph2mps</span>(std::<span class="built_in">stod</span>(map[<span class="string">&quot;velocity&quot;</span>]));</span><br><span class="line">  wp-&gt;change_flag = std::<span class="built_in">stoi</span>(map[<span class="string">&quot;change_flag&quot;</span>]);</span><br><span class="line">  wp-&gt;wpstate.steering_state = (map.<span class="built_in">find</span>(<span class="string">&quot;steering_flag&quot;</span>) != map.<span class="built_in">end</span>()) ? std::<span class="built_in">stoi</span>(map[<span class="string">&quot;steering_flag&quot;</span>]) : <span class="number">0</span>;</span><br><span class="line">  wp-&gt;wpstate.accel_state = (map.<span class="built_in">find</span>(<span class="string">&quot;accel_flag&quot;</span>) != map.<span class="built_in">end</span>()) ? std::<span class="built_in">stoi</span>(map[<span class="string">&quot;accel_flag&quot;</span>]) : <span class="number">0</span>;</span><br><span class="line">  wp-&gt;wpstate.stop_state = (map.<span class="built_in">find</span>(<span class="string">&quot;stop_flag&quot;</span>) != map.<span class="built_in">end</span>()) ? std::<span class="built_in">stoi</span>(map[<span class="string">&quot;stop_flag&quot;</span>]) : <span class="number">0</span>;</span><br><span class="line">  wp-&gt;wpstate.event_state = (map.<span class="built_in">find</span>(<span class="string">&quot;event_flag&quot;</span>) != map.<span class="built_in">end</span>()) ? std::<span class="built_in">stoi</span>(map[<span class="string">&quot;event_flag&quot;</span>]) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump4.2"></span></p><h3 id="4-2-节点waypoint-replanner"><a href="#4-2-节点waypoint-replanner" class="headerlink" title="4.2    节点waypoint_replanner"></a>4.2 节点waypoint_replanner</h3><p>​ 节点<code>waypoint_replanner</code>的主要作用：在加载的轨迹点基础上重新对他们的速度进行设置。</p><h4 id="4-2-1-启动方法"><a href="#4-2-1-启动方法" class="headerlink" title="4.2.1    启动方法"></a>4.2.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li>roslaunch waypoint_maker waypoint_loader.launch</li></ul></li><li><p>从Runtime Manager启动:</p></li></ul><p>​ 打开Runtime Manager，上方computing 选项卡 -&gt; Motion Planning -&gt;waypoint_maker-&gt;waypoint_loader，单击 [app] 按钮可更改设置等参数。</p><h4 id="4-2-2-程序路径"><a href="#4-2-2-程序路径" class="headerlink" title="4.2.2    程序路径"></a>4.2.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/autoware/core_planning/waypoint_maker/nodes/waypoint_replanner</span><br></pre></td></tr></table></figure><h4 id="4-2-3-参数详情"><a href="#4-2-3-参数详情" class="headerlink" title="4.2.3    参数详情"></a>4.2.3 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>replanning_mode</code></td><td><em>bool</em></td><td>重规划模式</td></tr><tr><td>velocity_max</td><td>double</td><td>最大速度（km&#x2F;h)</td></tr><tr><td>velocity_min</td><td>double</td><td>最小速度（km&#x2F;h)</td></tr><tr><td>accel_limit</td><td>double</td><td>加速限制</td></tr><tr><td>decel_limit</td><td>double</td><td>减速限制</td></tr><tr><td>resample_mode</td><td>bool</td><td>重采样模式</td></tr><tr><td>resample_interval</td><td>bool</td><td>重采样间隔</td></tr><tr><td>replan_curve_mode</td><td>bool</td><td>重规划曲线模式</td></tr><tr><td>replan_endpoint_mode</td><td>bool</td><td>重规划结束点模式</td></tr></tbody></table><h4 id="4-2-4-代码注解"><a href="#4-2-4-代码注解" class="headerlink" title="4.2.4    代码注解"></a>4.2.4 代码注解</h4><h5 id="①-main函数-2"><a href="#①-main函数-2" class="headerlink" title="① main函数"></a>① main函数</h5><p>​ main函数在<code>waypoint_replanner_node.cpp</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;waypoint_replanner&quot;</span>);</span><br><span class="line">  waypoint_maker::WaypointReplannerNode wr; </span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 在main函数中只做了一件事，新建WaypointReplannerNode对象<code>wr</code>， 因此转到WaypointReplannerNode类的构造函数， 构造函数内实现了话题的订阅和发布。其中订阅的“&#x2F;based&#x2F;waypoints_raw”就是前面waypoint_loader节点所发布的话题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">WaypointReplannerNode::<span class="built_in">WaypointReplannerNode</span>() : <span class="built_in">pnh_</span>(<span class="string">&quot;~&quot;</span>), <span class="built_in">is_first_publish_</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  WaypointReplannerConfig temp_config;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...(下略)</span></span><br><span class="line">  <span class="keyword">if</span> (use_decision_maker_)</span><br><span class="line">  &#123;</span><br><span class="line">    lane_pub_ = nh_.<span class="built_in">advertise</span>&lt;autoware_msgs::LaneArray&gt;(<span class="string">&quot;/based/lane_waypoints_array&quot;</span>, <span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    lane_pub_ = nh_.<span class="built_in">advertise</span>&lt;autoware_msgs::LaneArray&gt;(<span class="string">&quot;/lane_waypoints_array&quot;</span>, <span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lane_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/based/lane_waypoints_raw&quot;</span>, <span class="number">1</span>, &amp;WaypointReplannerNode::laneCallback, <span class="keyword">this</span>);</span><br><span class="line">  config_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/config/waypoint_replanner&quot;</span>, <span class="number">1</span>, &amp;WaypointReplannerNode::configCallback, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-configCallback函数"><a href="#②-configCallback函数" class="headerlink" title="② configCallback函数"></a>② configCallback函数</h5><p>​ configCallback函数为话题“&#x2F;config&#x2F;waypoint_replanner”的回调函数，主要进行一些成员变量的初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaypointReplannerNode::configCallback</span><span class="params">(<span class="type">const</span> autoware_config_msgs::ConfigWaypointReplanner::ConstPtr&amp; conf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//重规划模式</span></span><br><span class="line">     replanning_mode_ = conf-&gt;replanning_mode;</span><br><span class="line">    <span class="comment">//实时调整模式</span></span><br><span class="line">     realtime_tuning_mode_ = conf-&gt;realtime_tuning_mode;</span><br><span class="line">     use_decision_maker_ = conf-&gt;use_decision_maker;</span><br><span class="line">     replanner_.<span class="built_in">initParameter</span>(conf);</span><br><span class="line">     <span class="keyword">if</span> (!lane_array_.lanes.<span class="built_in">empty</span>() &amp;&amp; (is_first_publish_ || realtime_tuning_mode_))</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">publishLaneArray</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="③-laneCallback函数"><a href="#③-laneCallback函数" class="headerlink" title="③ laneCallback函数"></a>③ laneCallback函数</h5><p>​ laneCallback函数为话题“&#x2F;based&#x2F;lane_waypoints_raw”的回调函数，在加载的轨迹点基础上重新规划并发布话题“lane_waypoints_array”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaypointReplannerNode::laneCallback</span><span class="params">(<span class="type">const</span> autoware_msgs::LaneArray::ConstPtr&amp; lane_array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     lane_array_ = *lane_array;</span><br><span class="line">     <span class="built_in">publishLaneArray</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="④-publishLaneArray函数"><a href="#④-publishLaneArray函数" class="headerlink" title="④ publishLaneArray函数"></a>④ publishLaneArray函数</h5><p>​ 如果replanning_mode 为true，则调用replan函数重新规划。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaypointReplannerNode::publishLaneArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">autoware_msgs::LaneArray <span class="title">array</span><span class="params">(lane_array_)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (replanning_mode_)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">//重规划路径</span></span><br><span class="line">         <span class="built_in">replan</span>(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发布重新规划过的路径集合</span></span><br><span class="line">     lane_pub_.<span class="built_in">publish</span>(array);</span><br><span class="line">     is_first_publish_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑤-replan函数"><a href="#⑤-replan函数" class="headerlink" title="⑤ replan函数"></a>⑤ replan函数</h5><p>​ replan函数内遍历<code>lane_array.lanes</code>。对每一条Lane，replanner_都调replanLaneWaypointVel函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WaypointReplannerNode::replan</span><span class="params">(autoware_msgs::LaneArray&amp; lane_array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;el : lane_array.lanes)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">//重规划路标点速度</span></span><br><span class="line">          replanner_.<span class="built_in">replanLaneWaypointVel</span>(el);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑥-replanLaneWaypointVel函数"><a href="#⑥-replanLaneWaypointVel函数" class="headerlink" title="⑥ replanLaneWaypointVel函数"></a>⑥ replanLaneWaypointVel函数</h5><p>​ lanLaneWaypointVel函数用于重规轨迹点的速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">replanLaneWaypointVel</span><span class="params">(autoware_msgs::Lane&amp; lane)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//...(上略)</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> last = lane.waypoints.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">limitVelocityByRange</span>(<span class="number">0</span>, last, config_.velocity_max, lane);</span><br><span class="line">     <span class="keyword">if</span> (config_.resample_mode)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">//重采样路标点</span></span><br><span class="line">         <span class="built_in">resampleLaneWaypoint</span>(config_.resample_interval, lane, dir);</span><br><span class="line">         last = lane.waypoints.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 根据每个航路点的曲率设置速度</span></span><br><span class="line">     <span class="keyword">if</span> (config_.replan_curve_mode)</span><br><span class="line">     &#123;</span><br><span class="line">          std::vector&lt;<span class="type">double</span>&gt; curve_radius;</span><br><span class="line">          <span class="built_in">createRadiusList</span>(lane, curve_radius);</span><br><span class="line">          <span class="built_in">setVelocityByRange</span>(<span class="number">0</span>, last, config_.velocity_max, lane);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; curve_radius.<span class="built_in">size</span>(); i++)</span><br><span class="line">          &#123;  </span><br><span class="line">               lane.waypoints[i].twist.twist.linear.x = std::<span class="built_in">fmin</span>(lane.waypoints[i].twist.twist.linear.x,</span><br><span class="line">                        std::<span class="built_in">sqrt</span>(config_.lateral_accel_limit * std::<span class="built_in">fmax</span>(curve_radius[i], config_.radius_min)));</span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="built_in">limitVelocityByRange</span>(<span class="number">0</span>, last, config_.velocity_max, lane);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置车道末端的速度</span></span><br><span class="line">     <span class="keyword">if</span> (config_.replan_endpoint_mode)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 将最后一个航点的速度置0</span></span><br><span class="line">          <span class="built_in">setVelocityByRange</span>(last - <span class="number">1</span>, last, <span class="number">0.0</span>, lane);</span><br><span class="line">          <span class="comment">// 为除最后一个航点之外的其他航点设置最小速度</span></span><br><span class="line">          <span class="built_in">raiseVelocityByRange</span>(<span class="number">0</span>, last - <span class="number">1</span>, config_.velocity_min, lane);</span><br><span class="line">          <span class="comment">// 再次平滑速度</span></span><br><span class="line">          <span class="built_in">limitVelocityByRange</span>(<span class="number">0</span>, last, config_.velocity_max, lane);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (dir == LaneDirection::Backward)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">changeVelSign</span>(lane, <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑦-limitVelocityByRange函数"><a href="#⑦-limitVelocityByRange函数" class="headerlink" title="⑦ limitVelocityByRange函数"></a>⑦ limitVelocityByRange函数</h5><p>​ 代码略，通过加速度与速度之间的关系进一步对速度进行修正。</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/limit_vel.jpg" alt="img"></p><p>​ 其中，a为最大加速度，x为距离（根据前后两个轨迹点的位置算得）。由此可以计算处在最大加速度的限制条件下，下一轨迹点的速度最大&#x2F;最小值。据此进行修正。</p><h5 id="⑧-resampleLaneWaypoint函数"><a href="#⑧-resampleLaneWaypoint函数" class="headerlink" title="⑧ resampleLaneWaypoint函数"></a>⑧ resampleLaneWaypoint函数</h5><p>​ 重采样轨迹点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resampleLaneWaypoint</span><span class="params">(<span class="type">const</span> <span class="type">double</span> resample_interval, autoware_msgs::Lane&amp; lane, LaneDirection dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lane.waypoints.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">autoware_msgs::Lane <span class="title">original_lane</span><span class="params">(lane)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt; original_lane.waypoints.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//采样三个轨迹点</span></span><br><span class="line">    <span class="comment">//[0] = previous point, [1] = target point, [2] = next point</span></span><br><span class="line">    CbufGPoint curve_point = <span class="built_in">getCrvPointsOnResample</span>(lane, original_lane, i);</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; curve_param = <span class="built_in">calcCurveParam</span>(curve_point);</span><br><span class="line">    lane.waypoints.<span class="built_in">back</span>().twist.twist = original_lane.waypoints[i - <span class="number">1</span>].twist.twist;</span><br><span class="line">    lane.waypoints.<span class="built_in">back</span>().wpstate = original_lane.waypoints[i - <span class="number">1</span>].wpstate;</span><br><span class="line">    lane.waypoints.<span class="built_in">back</span>().change_flag = original_lane.waypoints[i - <span class="number">1</span>].change_flag;</span><br><span class="line">    <span class="comment">// 如果直行</span></span><br><span class="line">    <span class="keyword">if</span> (curve_param.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">resampleOnStraight</span>(curve_point, lane, dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果转弯</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">resampleOnCurve</span>(curve_point[<span class="number">1</span>], curve_param, lane, dir);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑨getCrvPointsOnResample函数"><a href="#⑨getCrvPointsOnResample函数" class="headerlink" title="⑨getCrvPointsOnResample函数"></a>⑨getCrvPointsOnResample函数</h5><p>​ 在lane和original_lane上选择三个点作为圆弧上的点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> CbufGPoint <span class="title">getCrvPointsOnResample</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autoware_msgs::Lane&amp; lane, <span class="type">const</span> autoware_msgs::Lane&amp; original_lane, <span class="type">unsigned</span> <span class="type">long</span> original_index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> id = original_index;</span><br><span class="line">  <span class="function">CbufGPoint <span class="title">curve_point</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> n = (config_.lookup_crv_width - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="type">const</span> autoware_msgs::Waypoint cp[<span class="number">3</span>] = &#123;</span><br><span class="line">    (lane.waypoints.<span class="built_in">size</span>() &lt; n) ? lane.waypoints.<span class="built_in">front</span>() : lane.waypoints[lane.waypoints.<span class="built_in">size</span>() - n],</span><br><span class="line">    original_lane.waypoints[id],</span><br><span class="line">    (id &lt; original_lane.waypoints.<span class="built_in">size</span>() - n) ? original_lane.waypoints[id + n] : original_lane.waypoints.<span class="built_in">back</span>()</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    curve_point.<span class="built_in">push_back</span>(cp[i].pose.pose.position);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curve_point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑩calcCurveParam函数"><a href="#⑩calcCurveParam函数" class="headerlink" title="⑩calcCurveParam函数"></a>⑩calcCurveParam函数</h5><p>​ 计算圆的三个参数[center_x , center_y, radius]，首先根据轨迹点p0, p1, p2，计算下面各式：</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/calCrvPama1.png" alt="calCrvPama1"></p><p>由上面各式，进一步计算得到曲线的中心点和曲率</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/calCrvPama2.png" style="zoom:90%"><p>”根据圆上三点求圆心和半径”这一问题有多种解法，主流的有两种：（1）分别通过其中两点的中垂线交点求圆心；（2）通过三个点到圆心距离相等联立方程求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; <span class="title">WaypointReplanner::calcCurveParam</span><span class="params">(CbufGPoint p)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++, p.<span class="built_in">push_back</span>(p.<span class="built_in">front</span>()))  <span class="comment">// if exception occured, change points order</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//根据向量叉乘的模的值判断是否在一条直线上，如过模值小于1e-8则近似认为三点在一条直线上，圆的参数为空</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> d = <span class="number">2</span> * ((p[<span class="number">0</span>].y - p[<span class="number">2</span>].y) * (p[<span class="number">0</span>].x - p[<span class="number">1</span>].x) - (p[<span class="number">0</span>].y - p[<span class="number">1</span>].y) * (p[<span class="number">0</span>].x - p[<span class="number">2</span>].x));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(d) &lt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; x2 = &#123; p[<span class="number">0</span>].x * p[<span class="number">0</span>].x, p[<span class="number">1</span>].x * p[<span class="number">1</span>].x, p[<span class="number">2</span>].x * p[<span class="number">2</span>].x &#125;;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; y2 = &#123; p[<span class="number">0</span>].y * p[<span class="number">0</span>].y, p[<span class="number">1</span>].y * p[<span class="number">1</span>].y, p[<span class="number">2</span>].y * p[<span class="number">2</span>].y &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> a = y2[<span class="number">0</span>] - y2[<span class="number">1</span>] + x2[<span class="number">0</span>] - x2[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> b = y2[<span class="number">0</span>] - y2[<span class="number">2</span>] + x2[<span class="number">0</span>] - x2[<span class="number">2</span>];</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">param</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> cx = param[<span class="number">0</span>] = ((p[<span class="number">0</span>].y - p[<span class="number">2</span>].y) * a - (p[<span class="number">0</span>].y - p[<span class="number">1</span>].y) * b) / d;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> cy = param[<span class="number">1</span>] = ((p[<span class="number">0</span>].x - p[<span class="number">2</span>].x) * a - (p[<span class="number">0</span>].x - p[<span class="number">1</span>].x) * b) / -d;</span><br><span class="line">    param[<span class="number">2</span>] = <span class="built_in">sqrt</span>((cx - p[<span class="number">0</span>].x) * (cx - p[<span class="number">0</span>].x) + (cy - p[<span class="number">0</span>].y) * (cy - p[<span class="number">0</span>].y));</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;();  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump4.3"></span></p><h3 id="4-3-节点lane-navi"><a href="#4-3-节点lane-navi" class="headerlink" title="4.3    节点lane_navi"></a>4.3 节点lane_navi</h3><p>​ 节点lane_navi的主要作用：根据路由请求在矢量地图中寻找通往目的地的各条可行路径，并发布至话题“&#x2F;lane_waypoints_array”。</p><h4 id="4-3-1-程序路径"><a href="#4-3-1-程序路径" class="headerlink" title="4.3.1    程序路径"></a>4.3.1 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/autoware/core_planning/lane_planner/nodes/lane_navi </span><br></pre></td></tr></table></figure><p>代码略。</p><p><span id="jump4.4"></span></p><h3 id="4-4-节点lane-rule"><a href="#4-4-节点lane-rule" class="headerlink" title="4.4    节点lane_rule"></a>4.4 节点lane_rule</h3><p>​ 节点lane_rule的主要作用：对话题“&#x2F;lane_waypoints_array”上轨迹点的速度方面进一步修正，为红灯时在停车线内减速停车等场景提供支持，发布话题“&#x2F;traffic_waypoints_array”。</p><h4 id="4-4-1-程序路径"><a href="#4-4-1-程序路径" class="headerlink" title="4.4.1    程序路径"></a>4.4.1 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/autoware/core_planning/lane_planner/nodes/lane_rule</span><br></pre></td></tr></table></figure><p>代码略。</p><p><span id="jump4.5"></span></p><h3 id="4-5-节点lane-select"><a href="#4-5-节点lane-select" class="headerlink" title="4.5    节点lane_select"></a>4.5 节点lane_select</h3><p>​ 节点lane_select的主要作用：判断当前车道，同时规划从当前车道切换至其他车道的轨迹，接着根据话题“state”中的驾驶状态（是否需要换道）发布当前车道数据&#x2F;换到轨迹数据至话题“base_waypoints”供其他节点继续规划。</p><h4 id="4-5-1-启动方法"><a href="#4-5-1-启动方法" class="headerlink" title="4.5.1    启动方法"></a>4.5.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li>roslaunch lane_planner lane_select.launch</li><li>从Runtime Manager启动:</li></ul></li></ul><p>​ 打开Runtime Manager，上方computing 选项卡 -&gt; mission_planning -&gt;lane_planner-&gt;lane_select，单击 [app] 按钮可更改设置等参数。</p><h4 id="4-5-2-程序路径"><a href="#4-5-2-程序路径" class="headerlink" title="4.5.2    程序路径"></a>4.5.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/autoware/core_planning/lane_planner/nodes/lane_select</span><br></pre></td></tr></table></figure><h4 id="4-5-3-代码注解"><a href="#4-5-3-代码注解" class="headerlink" title="4.5.3    代码注解"></a>4.5.3 代码注解</h4><h5 id="①-main函数-3"><a href="#①-main函数-3" class="headerlink" title="① main函数"></a>① main函数</h5><p>​ main函数在<code>lane_select_node.cpp</code>中。节点lane_select启动时新建LaneSelectNode对象，其构造函数中首先对一些成员变量进行赋值，接着调用initForROS函数设置订阅者&#x2F;发布者，设置参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;lane_select&quot;</span>);</span><br><span class="line"> lane_planner::LaneSelectNode lsn;</span><br><span class="line"> lsn.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-initForRos函数"><a href="#②-initForRos函数" class="headerlink" title="② initForRos函数"></a>② initForRos函数</h5><p>​ 该函数设置参数，设置订阅者和发布者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LaneSelectNode::initForROS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// setup subscriber</span></span><br><span class="line">  sub1_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;traffic_waypoints_array&quot;</span>, <span class="number">1</span>, &amp;LaneSelectNode::callbackFromLaneArray, <span class="keyword">this</span>);</span><br><span class="line">  sub2_.<span class="built_in">subscribe</span>(nh_, <span class="string">&quot;current_pose&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  sub3_.<span class="built_in">subscribe</span>(nh_, <span class="string">&quot;current_velocity&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// setup publisher</span></span><br><span class="line">  pub1_ = nh_.<span class="built_in">advertise</span>&lt;autoware_msgs::Lane&gt;(<span class="string">&quot;base_waypoints&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  pub2_ = nh_.<span class="built_in">advertise</span>&lt;std_msgs::Int32&gt;(<span class="string">&quot;closest_waypoint&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get from rosparam</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Kick off a timer to publish base_waypoints, closest_waypoint, change_flag, current_lane_id, and vehicle_location</span></span><br><span class="line">  timer_ = nh_.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>/update_rate_), &amp;LaneSelectNode::processing, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③-callbackFromLaneArray函数"><a href="#③-callbackFromLaneArray函数" class="headerlink" title="③ callbackFromLaneArray函数"></a>③ callbackFromLaneArray函数</h5><p>​ 主要功能构建tuple_vec_成员变量，使用tuple_vec_ 来存储laneArray相关变量。 tuple_vec_ 数据类型为std::vector&lt;std::tuple&lt;autoware_msgs::Lane, int32_t, ChangeFlag&gt;&gt;</p><p>tuple元素的定义依次为：lane, closest_waypoint on the lane to ego-vehicle, lane change flag ，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LaneSelectNode::callbackFromLaneArray</span><span class="params">(<span class="type">const</span> autoware_msgs::LaneArrayConstPtr &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tuple_vec_.<span class="built_in">clear</span>();</span><br><span class="line">  tuple_vec_.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">  tuple_vec_.<span class="built_in">reserve</span>(msg-&gt;lanes.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;el : msg-&gt;lanes)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> t = std::<span class="built_in">make_tuple</span>(el, <span class="number">-1</span>, ChangeFlag::unknown);</span><br><span class="line">    tuple_vec_.<span class="built_in">push_back</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lane_array_id_ = msg-&gt;id;</span><br><span class="line">  current_lane_idx_ = <span class="number">-1</span>;</span><br><span class="line">  right_lane_idx_ = <span class="number">-1</span>;</span><br><span class="line">  left_lane_idx_ = <span class="number">-1</span>;</span><br><span class="line">  is_new_lane_array_ = <span class="literal">true</span>;</span><br><span class="line">  is_lane_array_subscribed_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-processing函数"><a href="#④-processing函数" class="headerlink" title="④ processing函数"></a>④ processing函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LaneSelectNode::processing</span><span class="params">(<span class="type">const</span> ros::TimerEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//检查相关话题是否订阅成功</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isAllTopicsSubscribed</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新每条lane距离自车最近路标点,更新tuple_vec_中closest_waypoint元素的值</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">updateClosestWaypointNumberForEachLane</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">publishClosestWaypoint</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">publishVehicleLocation</span>(<span class="number">-1</span>, lane_array_id_);</span><br><span class="line">    <span class="built_in">resetLaneIdx</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_lane_idx_ == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 寻找距离自车最近的车道，更新current_lane_idx_</span></span><br><span class="line">    <span class="built_in">findCurrentLane</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//寻找相邻车道更新left_lane_idx_, right_lane_idx_</span></span><br><span class="line">  <span class="built_in">findNeighborLanes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_state_ == <span class="string">&quot;LANE_CHANGE&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//根据current_lane_idx_确定tuple_vec_中的元组，并根据该元组中change_flag值更新current_lane_idx_</span></span><br><span class="line">      <span class="comment">//然后调用findNeighborLanes更新left_lane_idx_, right_lane_idx_</span></span><br><span class="line">      <span class="built_in">changeLane</span>();</span><br><span class="line">      <span class="comment">//更新change lane中最近路标点及change flag</span></span><br><span class="line">      std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(lane_for_change_) =</span><br><span class="line">          <span class="built_in">getClosestWaypointNumber</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,</span><br><span class="line">                                   std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(lane_for_change_), distance_threshold_, search_closest_waypoint_minimum_dt_);</span><br><span class="line">      std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(lane_for_change_) = <span class="built_in">static_cast</span>&lt;ChangeFlag&gt;(</span><br><span class="line">          std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(lane_for_change_).waypoints.<span class="built_in">at</span>(std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(lane_for_change_)).change_flag);</span><br><span class="line">      <span class="comment">//发布change lane 相关信息</span></span><br><span class="line">      <span class="built_in">publishLane</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(lane_for_change_));</span><br><span class="line">      <span class="built_in">publishClosestWaypoint</span>(std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(lane_for_change_));</span><br><span class="line">      <span class="built_in">publishChangeFlag</span>(std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(lane_for_change_));</span><br><span class="line">      <span class="built_in">publishVehicleLocation</span>(std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(lane_for_change_), lane_array_id_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::out_of_range)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">ROS_WARN_THROTTLE</span>(<span class="number">2</span>, <span class="string">&quot;Failed to get closest waypoint num&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//更新tuple_vec_中每个元组内的change flag数据</span></span><br><span class="line">    <span class="built_in">updateChangeFlag</span>();</span><br><span class="line">    <span class="comment">//更新lane_for_change_ </span></span><br><span class="line">    <span class="built_in">createLaneForChange</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_new_lane_array_ || prev_lane_idx_ != current_lane_idx_)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">publishLane</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tuple_vec_.<span class="built_in">at</span>(current_lane_idx_)));</span><br><span class="line">      prev_lane_idx_ = current_lane_idx_;</span><br><span class="line">      is_new_lane_array_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="comment">//根据元组tuple_vec_.at(current_lane_idx_)中的信息发布消息到各个话题</span></span><br><span class="line">    <span class="built_in">publishClosestWaypoint</span>(std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tuple_vec_.<span class="built_in">at</span>(current_lane_idx_)));</span><br><span class="line">    <span class="built_in">publishChangeFlag</span>(std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(tuple_vec_.<span class="built_in">at</span>(current_lane_idx_)));</span><br><span class="line">    <span class="built_in">publishVehicleLocation</span>(std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tuple_vec_.<span class="built_in">at</span>(current_lane_idx_)), lane_array_id_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">publishVisualizer</span>();</span><br><span class="line">  <span class="built_in">resetSubscriptionFlag</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump4.6"></span></p><h3 id="4-6-节点-astar-avoid"><a href="#4-6-节点-astar-avoid" class="headerlink" title="4.6    节点 astar_avoid"></a>4.6 节点 astar_avoid</h3><p>​ 节点astar_avoid的主要作用：基于几点“lane_select”发布在话题“base_waypoints”上的轨迹， 利用A*算法规划壁障轨迹并发布至话题“safety_waypoints”。</p><h4 id="4-6-1-启动方法"><a href="#4-6-1-启动方法" class="headerlink" title="4.6.1    启动方法"></a>4.6.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li>roslaunch waypoint_planner astar_avoid.launch</li><li>从Runtime Manager启动:</li></ul></li></ul><p>​ 打开Runtime Manager，上方computing 选项卡 -&gt; motion_planner -&gt;waypoint_planner-&gt;astar_avoid，单击 [app] 按钮可更改设置等参数。</p><h4 id="4-6-2-程序路径"><a href="#4-6-2-程序路径" class="headerlink" title="4.6.2    程序路径"></a>4.6.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/autoware/core_planning/waypoint_planner/src/astar_avoid</span><br></pre></td></tr></table></figure><h4 id="4-6-3-参数详情"><a href="#4-6-3-参数详情" class="headerlink" title="4.6.3    参数详情"></a>4.6.3 参数详情</h4><table><thead><tr><th>参数名(astar_avoid)</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>enable_avoidance</td><td><em>bool</em></td><td>启用避障功能</td></tr><tr><td>avoid_waypoints_velocity</td><td>double</td><td>避障时最大速度（km&#x2F;h)</td></tr><tr><td>avoid_start_velocity</td><td>double</td><td>开始避障速度阈值（km&#x2F;h)</td></tr><tr><td>replan_interval</td><td>double</td><td>重规划时间间隔（s)</td></tr><tr><td>search_waypoints_delta</td><td>int</td><td>路标点下标搜索增量</td></tr></tbody></table><table><thead><tr><th>参数名(astar_search)</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>robot_length</td><td><em>double</em></td><td>机器人长度</td></tr><tr><td>robot_width</td><td>double</td><td>机器人宽度</td></tr><tr><td>robot_base2back</td><td>double</td><td>质心到车尾距离</td></tr><tr><td>minimum_turning_radius</td><td>double</td><td>最小转弯半径</td></tr><tr><td>theta_size</td><td>int</td><td>决定机器人移动时航向角变化步长,<br>移动一步航向角变化360&#x2F;theta_size 度</td></tr><tr><td>angle_goal_range</td><td>double</td><td>距离目标点角度范围</td></tr><tr><td>lateral_goal_range</td><td>double</td><td>距离目标点横向距离范围</td></tr><tr><td>longitudinal_goal_range</td><td>double</td><td>距离目标点纵向距离范围</td></tr><tr><td>obstacle_threshold</td><td>double</td><td>障碍物阈值</td></tr></tbody></table><h4 id="4-6-4-算法介绍-A-搜索算法"><a href="#4-6-4-算法介绍-A-搜索算法" class="headerlink" title="4.6.4    算法介绍-A*搜索算法"></a>4.6.4 算法介绍-A*搜索算法</h4><p>​ planAvoidWaypoints函数内调用A* 搜索算法，下面简单介绍下A*搜索算法。</p><p>​ A*搜索算法时一个被广泛应用于路径优化领域的算法，它的寻路能力基于启发式的代价函数。</p><h5 id="①-栅格化地图"><a href="#①-栅格化地图" class="headerlink" title="① 栅格化地图"></a>① 栅格化地图</h5><p>​ A*算法第一步时栅格化地图，具体来说是将连续的地图离散化，用一个大型的二位列表存储地图数据。</p><h5 id="②-评估函数"><a href="#②-评估函数" class="headerlink" title="② 评估函数"></a>② 评估函数</h5><p>​ A*算法的核心是一个评估函数：</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/eva_func.jpg" alt="img"></p><p>​ 其中，G(n)为代价函数，在该环境中G的值代表从起点移动到该方格n的距离代价。H(n)为启发式代价函数，在该环境中H的值代表该方格n到终点的距离代价。</p><h5 id="③-搜索步骤"><a href="#③-搜索步骤" class="headerlink" title="③ 搜索步骤"></a>③ 搜索步骤</h5><p>​ A*涉及两个重要的列表，openList（开放列表，存储候选节点）和closeList(关闭列表，存储已经走过的节点）。算法先把起点放入openList中，然后重复下面的步骤。</p><p>​ 遍历openlist，找到F值最小的节点当做当前搜索的起点，用P表示；</p><p>​ 将P放入closelist中， 作为已经走过的节点。</p><p>​ 探索P周围相邻节点，计算他们的H值、G值和F值，并把P设置为这些节点的父节点，将这些节点当做探索节点放到Q中。</p><p>​ 如果Q中的节点不在openlist或closelist中，则将其加入到openlist中；Q中节点已经存在于openlist中的，比较这些节点的F值和他们在openlist中的F值哪个更小（F越小说明路径更优），如果openlist中的F值更小或者二者相等，不做任何改变，否则用Q中的节点替换openlist中的节点； Q中节点已经存在于closelist中的，比较这些节点的F值和他们在closelist中的F值哪个更小，如果closelist中的F值更小或者相等，不做任何改变，否则将其加入到openlist。</p><p>​ 如果终点在openlist中，则退出搜索，最优路径可以从终点开始，沿着父节点逆向溯源直至起点而获得；如果openlist是空的，则退出，意味着起点到终点没有任何一条可行驶路径。</p><h4 id="4-6-5-代码注解"><a href="#4-6-5-代码注解" class="headerlink" title="4.6.5    代码注解"></a>4.6.5 代码注解</h4><h5 id="①-main函数-4"><a href="#①-main函数-4" class="headerlink" title="① main函数"></a>① main函数</h5><p>​ main函数在<code>astar_avoid_node.cpp</code>中，节点的主要功能通过AstarAvoid对象的run函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;astar_avoid&quot;</span>);</span><br><span class="line"> AstarAvoid node;</span><br><span class="line"> node.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-AstarAvoid构造函数"><a href="#②-AstarAvoid构造函数" class="headerlink" title="② AstarAvoid构造函数"></a>② AstarAvoid构造函数</h5><p>​ 构造函数主要功能为设置变量，发布者，订阅者。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AstarAvoid::<span class="built_in">AstarAvoid</span>()</span><br><span class="line"> : <span class="built_in">nh_</span>()</span><br><span class="line"> , <span class="built_in">private_nh_</span>(<span class="string">&quot;~&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置变量</span></span><br><span class="line">     private_nh_.<span class="built_in">param</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;closest_search_size&quot;</span>, closest_search_size_, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置发布者</span></span><br><span class="line">     safety_waypoints_pub_ = nh_.<span class="built_in">advertise</span>&lt;autoware_msgs::Lane&gt;(<span class="string">&quot;safety_waypoints&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置订阅者</span></span><br><span class="line">     base_waypoints_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;base_waypoints&quot;</span>, <span class="number">1</span>, &amp;AstarAvoid::baseWaypointsCallback, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="③-run函数"><a href="#③-run函数" class="headerlink" title="③ run函数"></a>③ run函数</h5><p>​ run函数是astar_avoid的功能主体。run函数实际上是一个有限状态机，根据条件切换state_ ，在特定状态更新avoid_waypoints_。</p><p>​ 函数内AstarAvoid::STATE的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">STATE</span></span><br><span class="line"> &#123;</span><br><span class="line">  INITIALIZING = <span class="number">-1</span>, </span><br><span class="line">  RELAYING = <span class="number">0</span>,</span><br><span class="line">  STOPPING = <span class="number">1</span>,</span><br><span class="line">  PLANNING = <span class="number">2</span>,</span><br><span class="line">  AVOIDING = <span class="number">3</span> </span><br><span class="line"> &#125; State;</span><br></pre></td></tr></table></figure><p>​ run函数代码及状态转移关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/astar_avoid.png" alt="astar_avoid"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AstarAvoid::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     state_ = AstarAvoid::STATE::INITIALIZING;</span><br><span class="line">     <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">     &#123;</span><br><span class="line">          ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        <span class="comment">// 检查各回调函数是否正确接收到对应话题的消息</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">checkInitialized</span>())</span><br><span class="line">          &#123;  </span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">          &#125;  </span><br><span class="line">          ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主循环</span></span><br><span class="line">    <span class="type">int</span> end_of_avoid_index = <span class="number">-1</span>; </span><br><span class="line">    ros::WallTime start_plan_time = ros::WallTime::<span class="built_in">now</span>();</span><br><span class="line">    ros::WallTime start_avoid_time = ros::WallTime::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置障碍物坐标</span></span><br><span class="line">    obstacle_waypoint_index_ = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动时设置为中继模式</span></span><br><span class="line">    state_ = AstarAvoid::STATE::RELAYING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动定时器发布话题</span></span><br><span class="line">    timer_ = nh_.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>/update_rate_), &amp;AstarAvoid::publishWaypoints, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        <span class="comment">// 判断是否开启避障模式</span></span><br><span class="line">        <span class="keyword">if</span> (!enable_avoidance_)</span><br><span class="line">        &#123;</span><br><span class="line">            rate_-&gt;<span class="built_in">sleep</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> found_obstacle = (obstacle_waypoint_index_ &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//avoid_star_velocity_(km/h)是开始避让时自车车速阈值</span></span><br><span class="line">        <span class="type">bool</span> avoid_velocity = (current_velocity_.twist.linear.x &lt; avoid_start_velocity_ / <span class="number">3.6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新状态state_</span></span><br><span class="line">        <span class="keyword">if</span> (state_ == AstarAvoid::STATE::RELAYING)</span><br><span class="line">        &#123;</span><br><span class="line">            avoid_waypoints_ = base_waypoints_;</span><br><span class="line">            <span class="comment">//发现障碍物，从中继模式转为停车模式</span></span><br><span class="line">            <span class="keyword">if</span> (found_obstacle)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;RELAYING -&gt; STOPPING, Decelerate for stopping&quot;</span>);</span><br><span class="line">                state_ = AstarAvoid::STATE::STOPPING;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state_ == AstarAvoid::STATE::STOPPING)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检查重规划时间间隔条件</span></span><br><span class="line">            <span class="type">bool</span> replan = ((ros::WallTime::<span class="built_in">now</span>() - start_plan_time).<span class="built_in">toSec</span>() &gt; replan_interval_);</span><br><span class="line">            <span class="comment">//障碍物消失，重新回到中继模式</span></span><br><span class="line">            <span class="keyword">if</span> (!found_obstacle)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;STOPPING -&gt; RELAYING, Obstacle disappers&quot;</span>);</span><br><span class="line">                state_ = AstarAvoid::STATE::RELAYING;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//障碍物仍然存在，且满足重规划时间间隔和速度要求，从停车模式转为规划模式</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (replan &amp;&amp; avoid_velocity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;STOPPING -&gt; PLANNING, Start A* planning&quot;</span>);</span><br><span class="line">                state_ = AstarAvoid::STATE::PLANNING;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state_ == AstarAvoid::STATE::PLANNING)</span><br><span class="line">        &#123;</span><br><span class="line">            start_plan_time = ros::WallTime::<span class="built_in">now</span>();</span><br><span class="line">            <span class="comment">//确定规避路线并相应添加到avoid_waypoints_,</span></span><br><span class="line">            <span class="comment">//同时更新传入函数的end_of_avoid_index</span></span><br><span class="line">            <span class="comment">//避障路线规划成功则从规划模式转为避障模式，否则切换为停车模式</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">planAvoidWaypoints</span>(end_of_avoid_index))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;PLANNING -&gt; AVOIDING, Found path&quot;</span>);</span><br><span class="line">                state_ = AstarAvoid::STATE::AVOIDING;</span><br><span class="line">                start_avoid_time = ros::WallTime::<span class="built_in">now</span>();</span><br><span class="line">                closest_waypoint_index_ = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;PLANNING -&gt; STOPPING, Cannot find path&quot;</span>);</span><br><span class="line">                state_ = AstarAvoid::STATE::STOPPING;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state_ == AstarAvoid::STATE::AVOIDING)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">updateClosestWaypoint</span>(avoid_waypoints_, current_pose_global_.pose, closest_search_size_);</span><br><span class="line">            <span class="comment">//如果自车位置超过避障路线终点，则从避障模式转为中继模式</span></span><br><span class="line">            <span class="keyword">if</span> (closest_waypoint_index_ &gt; end_of_avoid_index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;AVOIDING -&gt; RELAYING, Reached goal&quot;</span>);</span><br><span class="line">                state_ = AstarAvoid::STATE::RELAYING;</span><br><span class="line">                closest_waypoint_index_ = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (found_obstacle &amp;&amp; avoid_velocity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> replan = ((ros::WallTime::<span class="built_in">now</span>() - start_avoid_time).<span class="built_in">toSec</span>() &gt; replan_interval_);</span><br><span class="line">                <span class="keyword">if</span> (replan)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;AVOIDING -&gt; STOPPING, Abort avoiding&quot;</span>);</span><br><span class="line">                        state_ = AstarAvoid::STATE::STOPPING;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rate_-&gt;<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-planAvoidWaypoints函数"><a href="#④-planAvoidWaypoints函数" class="headerlink" title="④ planAvoidWaypoints函数"></a>④ planAvoidWaypoints函数</h5><p>​ 逐步更新目标位姿，并执行从当前位姿到目标位姿的基于A*算法的增量搜索，确定避障路线并相应添加进avoid_waypoints_。另外，更新传入函数的end_of_avoid_index。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AstarAvoid::planAvoidWaypoints</span><span class="params">(<span class="type">int</span>&amp; end_of_avoid_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">bool</span> found_path = <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">//获得avoid_waypoints_中的“距离最近轨迹点”的下标</span></span><br><span class="line">     <span class="built_in">updateClosestWaypoint</span>(avoid_waypoints_, current_pose_global_.pose, closest_search_size_);</span><br><span class="line">     <span class="keyword">if</span> (closest_waypoint_index_ == <span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 逐步更新目标位姿并执行A*搜索</span></span><br><span class="line">     <span class="comment">// search_waypoints_size用于跳过轨迹点以进行增量搜索</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = search_waypoints_delta_; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(search_waypoints_size_); i += search_waypoints_delta_)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 更新目标下标goal_waypoint_index</span></span><br><span class="line">          <span class="type">int</span> goal_waypoint_index = closest_waypoint_index_ + obstacle_waypoint_index_ + i;</span><br><span class="line">          <span class="keyword">if</span> (goal_waypoint_index &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(avoid_waypoints_.waypoints.<span class="built_in">size</span>()))</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新目标位姿</span></span><br><span class="line">      goal_pose_global_ = avoid_waypoints_.waypoints[goal_waypoint_index].pose;</span><br><span class="line">      goal_pose_local_.header = costmap_.header</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*指定goal_pose_local_和goal_pose_global_各自的frame_id,</span></span><br><span class="line"><span class="comment">         *就可以通过transformPose函数获得位姿goal_pose_global_.pose_</span></span><br><span class="line"><span class="comment">         *从global坐标系下转换到costmap_坐标系下的新位姿goal_pose_local_.pose</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      goal_pose_local_.pose = <span class="built_in">transformPose</span>(goal_pose_global_.pose,</span><br><span class="line">                         <span class="built_in">getTransform</span>(costmap_.header.frame_id, goal_pose_global_.header.frame_id));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// astar_的定义是 AstarSearch astar_</span></span><br><span class="line">      <span class="comment">// 根据costmap_的信息初始化astar_内A*搜索的代价地图nodes_</span></span><br><span class="line">      astar_.<span class="built_in">initialize</span>(costmap_);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动A*搜索        </span></span><br><span class="line">      found_path = astar_.<span class="built_in">makePlan</span>(current_pose_local_.pose, goal_pose_local_.pose);                                     </span><br><span class="line">      <span class="type">static</span> ros::Publisher pub = nh_.<span class="built_in">advertise</span>&lt;nav_msgs::Path&gt;(<span class="string">&quot;debug&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>); </span><br><span class="line">      <span class="keyword">if</span> (found_path)</span><br><span class="line">      &#123;</span><br><span class="line">           pub.<span class="built_in">publish</span>(astar_.<span class="built_in">getPath</span>());</span><br><span class="line">           end_of_avoid_index = goal_waypoint_index;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//将用于避障的轨迹astar_.getPath()合并进avoid_waypoints</span></span><br><span class="line">           <span class="comment">//并更新end_of_avoid_index</span></span><br><span class="line">           <span class="built_in">mergeAvoidWaypoints</span>(astar_.<span class="built_in">getPath</span>(), end_of_avoid_index);</span><br><span class="line">           <span class="keyword">if</span> (avoid_waypoints_.waypoints.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Found GOAL at index = %d&quot;</span>, goal_waypoint_index);</span><br><span class="line">                astar_.<span class="built_in">reset</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">                found_path = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      astar_.<span class="built_in">reset</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Can&#x27;t find goal...&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑤-search函数"><a href="#⑤-search函数" class="headerlink" title="⑤ search函数"></a>⑤ search函数</h5><p>​ search函数启动基于A*算法的搜索过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AstarSearch::search</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ros::WallTime begin = ros::WallTime::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 开始A*搜索</span></span><br><span class="line">     <span class="comment">// 如果openlist为空，搜索失败img</span></span><br><span class="line">     <span class="keyword">while</span> (!openlist_.<span class="built_in">empty</span>())</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="comment">// 检查时间并在搜索时间到达限制时终止</span></span><br><span class="line">      ros::WallTime now = ros::WallTime::<span class="built_in">now</span>();</span><br><span class="line">      <span class="type">double</span> msec = (now - begin).<span class="built_in">toSec</span>() * <span class="number">1000.0</span>;</span><br><span class="line">      <span class="keyword">if</span> (msec &gt; time_limit_)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Exceed time limit of %lf [ms]&quot;</span>, time_limit_);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从openlist中弹出最低代价节点</span></span><br><span class="line">      SimpleNode top_sn = openlist_.<span class="built_in">top</span>();</span><br><span class="line">      openlist_.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">      AstarNode* current_an = &amp;nodes_[top_sn.index_y][top_sn.index_x][top_sn.index_theta];</span><br><span class="line">      <span class="comment">//将该节点状态设为CLOSED，即将该节点放入closelist中</span></span><br><span class="line">      current_an-&gt;status = STATUS::CLOSED;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//目标检查</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isGoal</span>(current_an-&gt;x, current_an-&gt;y, current_an-&gt;theta))</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Search time: %lf [msec]&quot;</span>, (now - begin).<span class="built_in">toSec</span>() * <span class="number">1000.0</span>);</span><br><span class="line">       <span class="built_in">setPath</span>(top_sn);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 拓展节点</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; state : state_update_table_[top_sn.index_theta])</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="comment">//下一个节点</span></span><br><span class="line">           <span class="type">double</span> next_x = current_an-&gt;x + state.shift_x;</span><br><span class="line">           <span class="type">double</span> next_y = current_an-&gt;y + state.shift_y;</span><br><span class="line">           <span class="type">double</span> next_theta = <span class="built_in">modifyTheta</span>(current_an-&gt;theta + state.rotation);</span><br><span class="line">           <span class="type">double</span> move_cost = state.step;</span><br><span class="line">           <span class="type">double</span> move_distance = current_an-&gt;move_distance + state.step;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 增加反向代价</span></span><br><span class="line">           <span class="keyword">if</span> (state.back != current_an-&gt;back)</span><br><span class="line">                move_cost *= reverse_weight_;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 计算下一个状态的下标</span></span><br><span class="line">           SimpleNode next_sn;</span><br><span class="line">           geometry_msgs::Point next_pos;</span><br><span class="line">           next_pos.x = next_x;</span><br><span class="line">           next_pos.y = next_y;</span><br><span class="line">           <span class="built_in">pointToIndex</span>(next_pos, &amp;next_sn.index_x, &amp;next_sn.index_y);</span><br><span class="line">           next_sn.index_theta = top_sn.index_theta + state.index_theta;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 避免下标无效</span></span><br><span class="line">           next_sn.index_theta = (next_sn.index_theta + theta_size_) % theta_size_;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检查下标是否有效</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">isOutOfRange</span>(next_sn.index_x, next_sn.index_y) || <span class="built_in">detectCollision</span>(next_sn))</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           AstarNode* next_an = &amp;nodes_[next_sn.index_y][next_sn.index_x][next_sn.index_theta];</span><br><span class="line">           <span class="type">double</span> next_gc = current_an-&gt;gc + move_cost;</span><br><span class="line">           <span class="type">double</span> next_hc = nodes_[next_sn.index_y][next_sn.index_x][<span class="number">0</span>].hc;  <span class="comment">// wavefront 或距离变换启发式</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 增加欧式距离成本</span></span><br><span class="line">           <span class="keyword">if</span> (use_potential_heuristic_)</span><br><span class="line">           &#123;</span><br><span class="line">                next_gc += nodes_[next_sn.index_y][next_sn.index_x][<span class="number">0</span>].hc;</span><br><span class="line">                next_hc += <span class="built_in">calcDistance</span>(next_x, next_y, goal_pose_local_.pose.position.x, goal_pose_local_.pose.position.y);</span><br><span class="line">                distance_heuristic_weight_;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 下一个节点状态为STATUS::NONE</span></span><br><span class="line">           <span class="keyword">if</span> (next_an-&gt;status == STATUS::NONE)</span><br><span class="line">           &#123;</span><br><span class="line">                next_an-&gt;status = STATUS::OPEN;</span><br><span class="line">                next_an-&gt;x = next_x;</span><br><span class="line">                next_an-&gt;y = next_y;</span><br><span class="line">                next_an-&gt;theta = next_theta;</span><br><span class="line">                next_an-&gt;gc = next_gc;</span><br><span class="line">                next_an-&gt;hc = next_hc;</span><br><span class="line">                next_an-&gt;move_distance = move_distance;</span><br><span class="line">                next_an-&gt;back = state.back;</span><br><span class="line">                next_an-&gt;parent = current_an;</span><br><span class="line">                next_sn.cost = next_an-&gt;gc + next_an-&gt;hc;</span><br><span class="line">                openlist_.<span class="built_in">push</span>(next_sn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 下一个节点在openlist或closelist中</span></span><br><span class="line">           <span class="keyword">if</span> (next_an-&gt;status == STATUS::OPEN || next_an-&gt;status == STATUS::CLOSED)</span><br><span class="line">           &#123;</span><br><span class="line">            <span class="keyword">if</span> (next_gc &lt; next_an-&gt;gc)</span><br><span class="line">            &#123;</span><br><span class="line">                next_an-&gt;status = STATUS::OPEN;</span><br><span class="line">                next_an-&gt;x = next_x;</span><br><span class="line">                next_an-&gt;y = next_y;</span><br><span class="line">                next_an-&gt;theta = next_theta;</span><br><span class="line">                next_an-&gt;gc = next_gc;</span><br><span class="line">                next_an-&gt;hc = next_hc;  <span class="comment">// already calculated ?</span></span><br><span class="line">                next_an-&gt;move_distance = move_distance;</span><br><span class="line">                next_an-&gt;back = state.back;</span><br><span class="line">                next_an-&gt;parent = current_an;</span><br><span class="line">                next_sn.cost = next_an-&gt;gc + next_an-&gt;hc;</span><br><span class="line">                openlist_.<span class="built_in">push</span>(next_sn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;  <span class="comment">// 状态更新</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 寻路失败</span></span><br><span class="line">     <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Open list is empty...&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump4.7"></span></p><h3 id="4-7-节点velocity-set"><a href="#4-7-节点velocity-set" class="headerlink" title="4.7    节点velocity_set"></a>4.7 节点velocity_set</h3><p>​ 节点velocity_set的主要作用：在节点astar_avoid发布在话题“safety_waypoints”上的轨迹基础上，修正无人车靠近障碍物或停车线的速度。</p><h4 id="4-7-1-启动方法"><a href="#4-7-1-启动方法" class="headerlink" title="4.7.1    启动方法"></a>4.7.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li>roslaunch waypoint_planner velocity_set_option.launch</li><li>从Runtime Manager启动:</li></ul></li></ul><p>​ 打开Runtime Manager，上方computing 选项卡 -&gt; motion_planner -&gt;waypoint_planner-&gt;velocity_set，单击 [app] 按钮可更改设置等参数。</p><h4 id="4-7-2-程序路径"><a href="#4-7-2-程序路径" class="headerlink" title="4.7.2    程序路径"></a>4.7.2 程序路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/autoware/core_planning/waypoint_planner/src/velocity_set</span><br></pre></td></tr></table></figure><h4 id="4-7-3-参数详情"><a href="#4-7-3-参数详情" class="headerlink" title="4.7.3    参数详情"></a>4.7.3 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>remove_points_upto</td><td><code>double</code></td><td>删除点范围</td></tr><tr><td>stop_distance_obstacle</td><td><code>double</code></td><td>障碍物前停车距离</td></tr><tr><td>stop_distance_stopline</td><td><code>double</code></td><td>停止线前停车距离</td></tr><tr><td>detection_range</td><td><code>double</code></td><td>障碍物检测范围</td></tr><tr><td>deceleration_range</td><td><code>double</code></td><td>减速检测范围</td></tr><tr><td>points_threshold</td><td><code>int</code></td><td>点云个数阈值</td></tr><tr><td>deceleration_obstacle</td><td><code>double</code></td><td>前方存在障碍物时减速度值</td></tr><tr><td>deceleration_stopline</td><td><code>double</code></td><td>前方存在停止线时减速度值</td></tr><tr><td>velocity_change_limit</td><td><code>double</code></td><td>速度变化限制（km&#x2F;h)</td></tr></tbody></table><h4 id="4-7-4-代码注解"><a href="#4-7-4-代码注解" class="headerlink" title="4.7.4    代码注解"></a>4.7.4 代码注解</h4><h5 id="①-main函数-5"><a href="#①-main函数-5" class="headerlink" title="① main函数"></a>① main函数</h5><p>首先是main函数，main函数在velocity_set.cpp中，主要功能为：</p><p>​ 1.Crosswalk: 人行横道检测</p><p>​ 2.obstacleDetection: 检测障碍物位于当前轨迹路标点索引值，并根据距离信息判断当前需要减速还是停车（EControl::STOP、DECELERATE）</p><ol start="3"><li>changeWaypoints: 根据障碍物信息修改waypoints中的速度信息，进而在pure_pursuit节点形成减速或者停车的效果</li><li>发布路径及障碍物信息</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">     <span class="comment">//类对象</span></span><br><span class="line">     CrossWalk crosswalk;</span><br><span class="line">     VelocitySetPath vs_path;</span><br><span class="line">     VelocitySetInfo vs_info;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 速度设定路径订阅器</span></span><br><span class="line">     ros::Subscriber waypoints_sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;safety_waypoints&quot;</span>, <span class="number">1</span>, &amp;VelocitySetPath::waypointsCallback, &amp;vs_path);</span><br><span class="line">     ros::Subscriber current_vel_sub =</span><br><span class="line">      nh.<span class="built_in">subscribe</span>(<span class="string">&quot;current_velocity&quot;</span>, <span class="number">1</span>, &amp;VelocitySetPath::currentVelocityCallback, &amp;vs_path);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 速度设定信息订阅器</span></span><br><span class="line">     ros::Subscriber config_sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;config/velocity_set&quot;</span>, <span class="number">1</span>, &amp;VelocitySetInfo::configCallback, &amp;vs_info);</span><br><span class="line">     <span class="comment">// 点云订阅器</span></span><br><span class="line">     ros::Subscriber points_sub = nh.<span class="built_in">subscribe</span>(points_topic, <span class="number">1</span>, &amp;VelocitySetInfo::pointsCallback, &amp;vs_info);</span><br><span class="line">     <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 矢量地图订阅器</span></span><br><span class="line">     <span class="keyword">if</span> (enable_crosswalk_detection)</span><br><span class="line">     &#123;</span><br><span class="line">          crosswalk.<span class="built_in">setMultipleDetectionFlag</span>(enable_multiple_crosswalk_detection);</span><br><span class="line">          ros::Subscriber sub_dtlane =</span><br><span class="line">            nh.<span class="built_in">subscribe</span>(<span class="string">&quot;vector_map_info/cross_walk&quot;</span>, <span class="number">1</span>, &amp;CrossWalk::crossWalkCallback, &amp;crosswalk);</span><br><span class="line">          ros::Subscriber sub_area = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;vector_map_info/area&quot;</span>, <span class="number">1</span>, &amp;CrossWalk::areaCallback, &amp;crosswalk);</span><br><span class="line">          ros::Subscriber sub_line = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;vector_map_info/line&quot;</span>, <span class="number">1</span>, &amp;CrossWalk::lineCallback, &amp;crosswalk);</span><br><span class="line">          ros::Subscriber sub_point = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;vector_map_info/point&quot;</span>, <span class="number">1</span>, &amp;CrossWalk::pointCallback, &amp;crosswalk);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// TF监听</span></span><br><span class="line">     tf2_ros::Buffer tfBuffer;<span class="function">obstacleDetection</span></span><br><span class="line"><span class="function">     tf2_ros::TransformListener <span class="title">tfListener</span><span class="params">(tfBuffer)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//发布器</span></span><br><span class="line">     ros::Publisher detection_range_markers_pub = nh.<span class="built_in">advertise</span>&lt;visualization_msgs::MarkerArray&gt;(<span class="string">&quot;detection_range&quot;</span>, <span class="number">1</span>);</span><br><span class="line">     ros::Publisher obstacle_marker_pub = nh.<span class="built_in">advertise</span>&lt;visualization_msgs::Marker&gt;(<span class="string">&quot;obstacle&quot;</span>, <span class="number">1</span>);</span><br><span class="line">     ros::Publisher obstacle_waypoint_pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::Int32&gt;(<span class="string">&quot;obstacle_waypoint&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">     ros::Publisher stopline_waypoint_pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::Int32&gt;(<span class="string">&quot;stopline_waypoint&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">     ros::Publisher final_waypoints_pub = nh.<span class="built_in">advertise</span>&lt;autoware_msgs::Lane&gt;(<span class="string">&quot;final_waypoints&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(update_rate)</span></span>;</span><br><span class="line">     <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">     &#123;</span><br><span class="line">      ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">       geometry_msgs::TransformStamped map_to_lidar_tf = tfBuffer.<span class="built_in">lookupTransform</span>(</span><br><span class="line">            <span class="string">&quot;map&quot;</span>, <span class="string">&quot;velodyne&quot;</span>, ros::Time::<span class="built_in">now</span>(), ros::<span class="built_in">Duration</span>(<span class="number">2.0</span>));</span><br><span class="line">       vs_info.<span class="built_in">setLocalizerPose</span>(map_to_lidar_tf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span>(tf2::TransformException &amp;ex)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Failed to get map-&gt;lidar transform. skip computation: %s&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 因为safety_waypoints的第一个元素为距离自车最近轨迹点，所以设置current_closest_waypoint 为0</span></span><br><span class="line">      <span class="type">int32_t</span> current_closest_waypoint = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int32_t</span> closest_crosswalk_waypoint = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span> (!vs_info.<span class="built_in">getSetPose</span>() || !vs_path.<span class="built_in">getSetPath</span>() || vs_path.<span class="built_in">getPrevWaypointsSize</span>() == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">           loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (enable_crosswalk_detection)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//更新crosswalk内的bdID_,detection_points_和set_points</span></span><br><span class="line">           <span class="keyword">if</span> (crosswalk.loaded_all &amp;&amp; !crosswalk.set_points)</span><br><span class="line">           &#123;</span><br><span class="line">                crosswalk.<span class="built_in">setCrossWalkPoints</span>();</span><br><span class="line">           &#125;</span><br><span class="line">          <span class="comment">// 如果 crosswalk.loaded_all为false, 设置 closest_crosswalk_waypoint为 -1.</span></span><br><span class="line">          closest_crosswalk_waypoint = crosswalk.<span class="built_in">findClosestCrosswalk</span>(current_closest_waypoint, vs_path.<span class="built_in">getPrevWaypoints</span>(), STOP_SEARCH_DISTANCE);</span><br><span class="line">      &#125;</span><br><span class="line">      crosswalk.<span class="built_in">setDetectionWaypoint</span>(closest_crosswalk_waypoint);</span><br><span class="line">      <span class="type">int32_t</span> traffic_waypoint_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//障碍物检测并可视化障碍物</span></span><br><span class="line">      EControl detection_result = <span class="built_in">obstacleDetection</span>(current_closest_waypoint, vs_path.<span class="built_in">getPrevWaypoints</span>(), crosswalk, vs_info,detection_range_markers_pub, obstacle_marker_pub, &amp;traffic_waypoint_idx);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据前方障碍物/停车线情况更新vs_path中的轨迹点速度，并从vs_path中截取部分轨迹发布到话题“final_waypoints”.</span></span><br><span class="line">      <span class="built_in">changeWaypoints</span>(vs_info, detection_result, current_closest_waypoint, traffic_waypoint_idx, &amp;vs_path);</span><br><span class="line">      vs_path.<span class="built_in">setTemporalWaypoints</span>(vs_info.<span class="built_in">getTemporalWaypointsSize</span>(), current_closest_waypoint, vs_info.<span class="built_in">getControlPose</span>());</span><br><span class="line">      final_waypoints_pub.<span class="built_in">publish</span>(vs_path.<span class="built_in">getTemporalWaypoints</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 发布障碍物和停止线信息</span></span><br><span class="line">      std_msgs::Int32 obstacle_waypoint_index;</span><br><span class="line">      std_msgs::Int32 stopline_waypoint_index;</span><br><span class="line">      <span class="keyword">if</span> (detection_result == EControl::STOP)</span><br><span class="line">      &#123;</span><br><span class="line">           obstacle_waypoint_index.data = traffic_waypoint_idx;</span><br><span class="line">           stopline_waypoint_index.data = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (detection_result == EControl::STOPLINE)</span><br><span class="line">      &#123;</span><br><span class="line">           obstacle_waypoint_index.data = <span class="number">-1</span>;</span><br><span class="line">           stopline_waypoint_index.data = traffic_waypoint_idx;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">           obstacle_waypoint_index.data = <span class="number">-1</span>;</span><br><span class="line">           stopline_waypoint_index.data = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      obstacle_waypoint_pub.<span class="built_in">publish</span>(obstacle_waypoint_index);</span><br><span class="line">      stopline_waypoint_pub.<span class="built_in">publish</span>(stopline_waypoint_index);      </span><br><span class="line">      <span class="comment">//重置vs_path内的set_path_;清空vs_info中的points_</span></span><br><span class="line">      vs_path.<span class="built_in">resetFlag</span>();</span><br><span class="line">      vs_info.<span class="built_in">clearPoints</span>();</span><br><span class="line">      loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-VelocitySetPath类中的回调函数waypointsCallback和currentVelocityCallback"><a href="#②-VelocitySetPath类中的回调函数waypointsCallback和currentVelocityCallback" class="headerlink" title="② VelocitySetPath类中的回调函数waypointsCallback和currentVelocityCallback"></a>② VelocitySetPath类中的回调函数waypointsCallback和currentVelocityCallback</h5><p>​ waypointCallback函数和currentVelocityCallback函数分别是话题“safety_waypoints”和“current_velocity”的回调函数。waypointCallback函数更新vs_path内的 autoware_msgs::Lane类型变量original_waypoints_ 和updated_waypoints_ 以及bool型变量set_path_ 。currentVelocityCallback函数更新vs_path内的current_velocity_变量。</p><h5 id="③-VelocitySetInfo类中的回调函数configCallback"><a href="#③-VelocitySetInfo类中的回调函数configCallback" class="headerlink" title="③ VelocitySetInfo类中的回调函数configCallback"></a>③ VelocitySetInfo类中的回调函数configCallback</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VelocitySetInfo::configCallback</span><span class="params">(<span class="type">const</span> autoware_config_msgs::ConfigVelocitySetConstPtr &amp;config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//相距障碍物的停车距离（m)</span></span><br><span class="line">     stop_distance_obstacle_ = config-&gt;stop_distance_obstacle;</span><br><span class="line">     <span class="comment">//相距停止线的停车距离 (m)</span></span><br><span class="line">     stop_distance_stopline_ = config-&gt;stop_distance_stopline;</span><br><span class="line">     <span class="comment">//如果障碍物在此范围内，停车</span></span><br><span class="line">     stop_range_ = config-&gt;detection_range;</span><br><span class="line">     <span class="comment">//判断为障碍物的阈值</span></span><br><span class="line">     points_threshold_ = config-&gt;threshold_points;</span><br><span class="line">     detection_height_top_ = config-&gt;detection_height_top;</span><br><span class="line">     detection_height_bottom_ = config-&gt;detection_height_bottom;</span><br><span class="line">     <span class="comment">//遇到障碍物时减速的加速度</span></span><br><span class="line">     deceleration_obstacle_ = config-&gt;deceleration_obstacle;</span><br><span class="line">     <span class="comment">//遇到停止线时减速的加速度</span></span><br><span class="line">     deceleration_stopline_ = config-&gt;deceleration_stopline;</span><br><span class="line">     <span class="comment">//速度变化的限制</span></span><br><span class="line">     velocity_change_limit_ = config-&gt;velocity_change_limit / <span class="number">3.6</span>; <span class="comment">// kmph -&gt; mps</span></span><br><span class="line">     <span class="comment">//如果障碍物在此范围内，减速</span></span><br><span class="line">     deceleration_range_ = config-&gt;deceleration_range;</span><br><span class="line">     temporal_waypoints_size_ = config-&gt;temporal_waypoints_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-obstacleDetection函数"><a href="#④-obstacleDetection函数" class="headerlink" title="④ obstacleDetection函数"></a>④ obstacleDetection函数</h5><p>​ obstacleDetection函数主要功能为检测障碍物， 其中包含pointsDetection() 这个函数，而pointsDetection()又包含了detectStopObstacle() 和 detectDecelerateObstacle() 两个重要的函数</p><p>​ detectStopObstacle() 函数功能为障碍物检测，需停车， detectDecelerateObstacle() 函数功能为障碍物检测，需减速，</p><p>​ <img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/obs_det1.png" alt="obs_det1" style="zoom:100%"></p><p>​ detectStopObstacle函数：从车辆位置开始，向后遍历一定数量的路径点(蓝色点)，对每个路径点，遍历所有的点云，如果该路径点stop_range半径内不存在点云，则切换到下一个路径点，再次遍历所有点云；</p><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/obs_det2.png"></p><p>​ 当在某一路径点B的stop_range范围内检测到了点云，且点云数量在合理范围内（大于points_threshold)， 则将障碍物判定为stop_obstacle，需要停车处理。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前位置后的路径点，进行障碍物检测，如果出现points_no_ground点云聚集则视为障碍物点。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">detectStopObstacle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, <span class="type">const</span> <span class="type">int</span> closest_waypoint,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> autoware_msgs::Lane&amp; lane, <span class="type">const</span> CrossWalk&amp; crosswalk, <span class="type">double</span> stop_range,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">double</span> points_threshold, <span class="type">const</span> geometry_msgs::PoseStamped&amp; localizer_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ObstaclePoints* obstacle_points, EObstacleType* obstacle_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">int</span> wpidx_detection_result_by_other_nodes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> stop_obstacle_waypoint = <span class="number">-1</span>;</span><br><span class="line">  *obstacle_type = EObstacleType::NONE;</span><br><span class="line">  <span class="comment">// start search from the closest waypoint</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = closest_waypoint; i &lt; closest_waypoint + STOP_SEARCH_DISTANCE; i++)<span class="comment">//STOP_SEARCH_DISTANCE默认是60M,沿着当前位置向后搜索</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// waypoint seen by localizer</span></span><br><span class="line">    geometry_msgs::Point waypoint = <span class="built_in">calcRelativeCoordinate</span>(lane.waypoints[i].pose.pose.position, localizer_pose.pose);<span class="comment">//计算定位点和路径点的相对坐标</span></span><br><span class="line">    tf::Vector3 tf_waypoint = <span class="built_in">point2vector</span>(waypoint);</span><br><span class="line">    tf_waypoint.<span class="built_in">setZ</span>(<span class="number">0</span>);    <span class="comment">//不考虑z轴数据，只计算平面距离</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> stop_point_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : points)<span class="comment">//遍历points_no_ground(去除地面后的点云图)中所有的点</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">tf::Vector3 <span class="title">point_vector</span><span class="params">(p.x, p.y, <span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="comment">// 2D distance between waypoint and points (obstacle)</span></span><br><span class="line">      <span class="type">double</span> dt = tf::<span class="built_in">tfDistance</span>(point_vector, tf_waypoint);<span class="comment">//计算障碍物点云与路径点之间的距离</span></span><br><span class="line">      <span class="keyword">if</span> (dt &lt; stop_range)<span class="comment">//dt范围内的点云均视为障碍物stop_obstacle</span></span><br><span class="line">      &#123;</span><br><span class="line">        stop_point_count++;</span><br><span class="line">        geometry_msgs::Point point_temp;</span><br><span class="line">        point_temp.x = p.x;</span><br><span class="line">        point_temp.y = p.y;</span><br><span class="line">        point_temp.z = p.z;</span><br><span class="line">        obstacle_points-&gt;<span class="built_in">setStopPoint</span>(<span class="built_in">calcAbsoluteCoordinate</span>(point_temp, localizer_pose.pose));</span><br><span class="line"><span class="comment">//把所有的点云放到容器中，</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// there is an obstacle if the number of points exceeded the threshold</span></span><br><span class="line">    <span class="keyword">if</span> (stop_point_count &gt; points_threshold)<span class="comment">//如果障碍物过于庞大，则视为不可通过，把ObstacleType状态设置为ON_WAYPOINTS。</span></span><br><span class="line">    &#123;</span><br><span class="line">      stop_obstacle_waypoint = i;</span><br><span class="line">      *obstacle_type = EObstacleType::ON_WAYPOINTS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    obstacle_points-&gt;<span class="built_in">clearStopPoints</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check next waypoint...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ pointsDetection函数调用detectStopObstacle() 和 detectDecelerateObstacle()两个函数，用来检测障碍物及判断控制指令是STOP还是DECELERATION，不考虑人行横道的情况下，流程图及代码如下</p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pointsDetection.jpg" style="zoom:20%"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EControl <span class="title">pointsDetection</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; pcl_points, <span class="type">const</span> <span class="type">int</span> closest_waypoint,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> autoware_msgs::Lane&amp; lane, <span class="type">const</span> CrossWalk&amp; crosswalk, <span class="type">const</span> VelocitySetInfo&amp; vs_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">int</span>* obstacle_waypoint, ObstaclePoints* obstacle_points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// no input for detection || no closest waypoint</span></span><br><span class="line">  <span class="keyword">if</span> ((pcl_points.<span class="built_in">empty</span>() &amp;&amp; vs_info.<span class="built_in">getDetectionResultByOtherNodes</span>() == <span class="number">-1</span>) || closest_waypoint &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> EControl::KEEP;</span><br><span class="line"></span><br><span class="line">  EObstacleType obstacle_type = EObstacleType::NONE;</span><br><span class="line">  <span class="type">int</span> stop_obstacle_waypoint =</span><br><span class="line">      <span class="built_in">detectStopObstacle</span>(pcl_points, closest_waypoint, lane, crosswalk, vs_info.<span class="built_in">getStopRange</span>(),</span><br><span class="line">                         vs_info.<span class="built_in">getPointsThreshold</span>(), vs_info.<span class="built_in">getLocalizerPose</span>(),</span><br><span class="line">                         obstacle_points, &amp;obstacle_type, vs_info.<span class="built_in">getDetectionResultByOtherNodes</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// skip searching deceleration range</span></span><br><span class="line">  <span class="keyword">if</span> (vs_info.<span class="built_in">getDecelerationRange</span>() &lt; <span class="number">0.01</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *obstacle_waypoint = stop_obstacle_waypoint;</span><br><span class="line">    <span class="keyword">if</span> (stop_obstacle_waypoint &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> EControl::KEEP;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obstacle_type == EObstacleType::ON_WAYPOINTS || obstacle_type == EObstacleType::ON_CROSSWALK)</span><br><span class="line">      <span class="keyword">return</span> EControl::STOP;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obstacle_type == EObstacleType::STOPLINE)</span><br><span class="line">      <span class="keyword">return</span> EControl::STOPLINE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> EControl::OTHERS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> decelerate_obstacle_waypoint =</span><br><span class="line">      <span class="built_in">detectDecelerateObstacle</span>(pcl_points, closest_waypoint, lane, vs_info.<span class="built_in">getStopRange</span>(), vs_info.<span class="built_in">getDecelerationRange</span>(),</span><br><span class="line">                               vs_info.<span class="built_in">getPointsThreshold</span>(), vs_info.<span class="built_in">getLocalizerPose</span>(), obstacle_points);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stop obstacle was not found</span></span><br><span class="line">  <span class="keyword">if</span> (stop_obstacle_waypoint &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *obstacle_waypoint = decelerate_obstacle_waypoint;</span><br><span class="line">    <span class="keyword">return</span> decelerate_obstacle_waypoint &lt; <span class="number">0</span> ? EControl::KEEP : EControl::DECELERATE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stop obstacle was found but decelerate obstacle was not found</span></span><br><span class="line">  <span class="keyword">if</span> (decelerate_obstacle_waypoint &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *obstacle_waypoint = stop_obstacle_waypoint;</span><br><span class="line">    <span class="keyword">return</span> EControl::STOP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// about 5.0 meter</span></span><br><span class="line">  <span class="type">double</span> waypoint_interval =</span><br><span class="line">      <span class="built_in">getPlaneDistance</span>(lane.waypoints[<span class="number">0</span>].pose.pose.position, lane.waypoints[<span class="number">1</span>].pose.pose.position);</span><br><span class="line">  <span class="type">int</span> stop_decelerate_threshold = <span class="number">5</span> / waypoint_interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// both were found</span></span><br><span class="line">  <span class="keyword">if</span> (stop_obstacle_waypoint - decelerate_obstacle_waypoint &gt; stop_decelerate_threshold)</span><br><span class="line">  &#123;</span><br><span class="line">    *obstacle_waypoint = decelerate_obstacle_waypoint;</span><br><span class="line">    <span class="keyword">return</span> EControl::DECELERATE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *obstacle_waypoint = stop_obstacle_waypoint;</span><br><span class="line">    <span class="keyword">return</span> EControl::STOP;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ obstacleDetection函数调用pointsDetection函数实现障碍物检测功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EControl <span class="title">obstacleDetection</span><span class="params">(<span class="type">int</span> closest_waypoint, <span class="type">const</span> autoware_msgs::Lane&amp; lane, <span class="type">const</span> CrossWalk&amp; crosswalk,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> VelocitySetInfo vs_info, <span class="type">const</span> ros::Publisher&amp; detection_range_pub,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> ros::Publisher&amp; obstacle_pub, <span class="type">int</span>* obstacle_waypoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ObstaclePoints obstacle_points;</span><br><span class="line">  EControl detection_result = <span class="built_in">pointsDetection</span>(vs_info.<span class="built_in">getPoints</span>(), closest_waypoint, lane, crosswalk, vs_info,</span><br><span class="line">                                              obstacle_waypoint, &amp;obstacle_points);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// stop or decelerate because we found obstacles</span></span><br><span class="line">  <span class="keyword">if</span> (detection_result == EControl::STOP || detection_result == EControl::STOPLINE || detection_result == EControl::DECELERATE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">displayObstacle</span>(detection_result, obstacle_points, obstacle_pub);</span><br><span class="line">    prev_detection = detection_result;</span><br><span class="line">    false_count = <span class="number">0</span>;</span><br><span class="line">    prev_obstacle_waypoint = *obstacle_waypoint;</span><br><span class="line">    <span class="keyword">return</span> detection_result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-changeWaypoints函数"><a href="#④-changeWaypoints函数" class="headerlink" title="④ changeWaypoints函数"></a>④ changeWaypoints函数</h5><p>​ 根据前方障碍物&#x2F;停车线情况，更新vs_path内的update_waypoints_中的轨迹点速度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeWaypoints</span><span class="params">(<span class="type">const</span> VelocitySetInfo&amp; vs_info, <span class="type">const</span> EControl&amp; detection_result, <span class="type">int</span> closest_waypoint,<span class="type">int</span> obstacle_waypoint, VelocitySetPath* vs_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">double</span> deceleration = <span class="number">0.0</span>;</span><br><span class="line">     <span class="type">double</span> velocity_change_limit = vs_info.<span class="built_in">getVelocityChangeLimit</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (detection_result == EControl::STOP || detection_result == EControl::STOPLINE)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 在障碍物/停止线前停车</span></span><br><span class="line">          <span class="comment">// stop_waypoint大约距离障碍物/停车线stop_distance米远</span></span><br><span class="line">          <span class="type">int</span> stop_distance = (detection_result == EControl::STOP)</span><br><span class="line">           ? vs_info.<span class="built_in">getStopDistanceObstacle</span>() : vs_info.<span class="built_in">getStopDistanceStopline</span>();</span><br><span class="line">          deceleration = (detection_result == EControl::STOP)</span><br><span class="line">           ? vs_info.<span class="built_in">getDecelerationObstacle</span>() : vs_info.<span class="built_in">getDecelerationStopline</span>();</span><br><span class="line">          <span class="comment">//确定与obstacle_waypoint的距离为stop_distance相对应轨迹点下标</span></span><br><span class="line">          <span class="type">int</span> stop_waypoint = <span class="built_in">calcWaypointIndexReverse</span>(vs_path-&gt;<span class="built_in">getPrevWaypoints</span>(), obstacle_waypoint, stop_distance);</span><br><span class="line">          <span class="comment">//基于上述信息更新update_waypoints_中的轨迹点速度</span></span><br><span class="line">          vs_path-&gt;<span class="built_in">changeWaypointsForStopping</span>(stop_waypoint, obstacle_waypoint, closest_waypoint, deceleration);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 在障碍物前减速</span></span><br><span class="line">          vs_path-&gt;<span class="built_in">initializeNewWaypoints</span>();</span><br><span class="line">          deceleration = vs_info.<span class="built_in">getDecelerationObstacle</span>();</span><br><span class="line">          <span class="keyword">if</span> (detection_result == EControl::DECELERATE)</span><br><span class="line">          &#123;</span><br><span class="line">               vs_path-&gt;<span class="built_in">changeWaypointsForDeceleration</span>(deceleration, closest_waypoint, obstacle_waypoint);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//避免急加速和急减速</span></span><br><span class="line">     vs_path-&gt;<span class="built_in">avoidSuddenAcceleration</span>(deceleration, closest_waypoint);</span><br><span class="line">     vs_path-&gt;<span class="built_in">avoidSuddenDeceleration</span>(velocity_change_limit, deceleration, closest_waypoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-参考文献"><a href="#4-8-参考文献" class="headerlink" title="4.8    参考文献"></a>4.8 参考文献</h3><p>[1] 李柏，张友民，邵之江. 自动驾驶车辆运动规划方法综述[J]：控制与信息技术，2018(6)：1-6.</p><p>[2] 靳岚，赵莉，谢黎明．基于三次Bezier三角样条插值的工业机器人连续路径轨迹规划[J]. 机械设计与制造工程,2019,48(4)：35-39.</p><p>[3] 杜卓洋，无人驾驶车辆轨迹规划算法研究[D]. 杭州：浙江大学，2019.</p><p>[4] 创客智造. autoware 入门教程一使用rosbag数据生成路径点[DB&#x2F;OLJ.[2020-04-11].<a target="_blank" rel="noopener" href="https://www.ncnynl.com/archives/201910/3413.html">https://www.ncnynl.com/archives/201910/3413.html</a>.</p><p>[5] 创客智造. autoware 入门教程一使用rosbag数据进行路径规划[DB&#x2F;OL].[2020-04-11].<a target="_blank" rel="noopener" href="https://www.ncnynl.com/archives/201910/3414.html">https://www.ncnynl.com/archives/201910/3414.html</a>.</p><p>[6] 何武. 室内服务机器人的导航研究[D]. 合肥：中国科学技术大学,2011.</p><p>[7] 邓鹏，张杭，申有吉．基于改进 Dijkstra 算法在智能导航中的应用[J]. 新型工业化，2019,9 (12) : 91-95.</p><p>[8] 顾青，豆风铅，马飞. 基于改进A*算法的电动车能耗最优路径规划[J]. 农业机械学报，2013,46 (12): 321-327.</p><p>[9] 徐磊. 基于 EPS 的自动泊车路径规划及跟综控制研究[D]. 合肥：合肥工业大学,2017.</p><p><span id="jump5.0"></span></p><h2 id="五、Autoware-控制模块解析"><a href="#五、Autoware-控制模块解析" class="headerlink" title="五、Autoware 控制模块解析"></a>五、Autoware 控制模块解析</h2><p>​ Autoware控制模块的主要作用为获取车辆路径规划的结果，在车辆运动学和动力学约束下计算相应的控制指令，包括速度角速度等，接着发布控制指令到车辆底盘执行。</p><p>​ 在当前场景下主要讲解纯跟踪控制算法。</p><p><span id="jump5.1"></span></p><h3 id="5-1-节点pure-pursuit"><a href="#5-1-节点pure-pursuit" class="headerlink" title="5.1    节点pure_pursuit"></a>5.1 节点pure_pursuit</h3><p>​ 节点pure_pursuit主要作用：接收velocity_set节点发布的“final_waypoints”，计算自车下一时刻的速度、角速度指令并发布“twist_raw”话题</p><h4 id="5-1-1-启动方法"><a href="#5-1-1-启动方法" class="headerlink" title="5.1.1    启动方法"></a>5.1.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li>roslaunch pure_pursuit pure_pursuit.launch</li><li>从Runtime Manager启动:</li></ul></li></ul><p>​ 打开Runtime Manager，上方computing 选项卡 -&gt; motion_planner -&gt;waypoint_follower-&gt;pure_pursuit，单击 [app] 按钮可更改设置等参数。</p><h4 id="5-1-2-程序路径"><a href="#5-1-2-程序路径" class="headerlink" title="5.1.2    程序路径"></a>5.1.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/autoware/core_planning/pure_pursuit</span><br></pre></td></tr></table></figure><h4 id="5-1-3-参数详情"><a href="#5-1-3-参数详情" class="headerlink" title="5.1.3    参数详情"></a>5.1.3 参数详情</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>lookahead_ratio</td><td>double</td><td>预瞄距离系数</td></tr><tr><td>minimum_lookahead_distance</td><td>double</td><td>最小预瞄距离</td></tr></tbody></table><h4 id="5-1-4-代码注解"><a href="#5-1-4-代码注解" class="headerlink" title="5.1.4    代码注解"></a>5.1.4 代码注解</h4><h5 id="①-main函数-6"><a href="#①-main函数-6" class="headerlink" title="① main函数"></a>① main函数</h5><p>​ main函数在pure_pursuit_node.cpp中，主要功能为创建PurePursuitNode对象的实例ppn，ppn的构造函数里配置相关参数，确定相关订阅者和发布者，ppn.run函数实现主要功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pure_pursuit/pure_pursuit_core.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pure_pursuit&quot;</span>);</span><br><span class="line"> waypoint_follower::PurePursuitNode ppn;</span><br><span class="line"> ppn.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-run函数-1"><a href="#②-run函数-1" class="headerlink" title="② run函数"></a>② run函数</h5><p>​ 函数首先检测节点所需消息输入是否正常接收，If函数中的判断条件时回调函数中的是否成功接收消息的标志，在这里要求三个标志必须为true程序才能继续往下进行，否则提示必要的话题没有接收成功，并在此等待。if函数对纯跟踪节点的运行条件做了筛查，以确保输入正确。</p><p>​ 接着通过setLookaheadDistance函数对预瞄距离lookahead_distance_进行设置，其值根据computeLookaheadDistance函数获得。</p><p>​ 随后调用canGetCurvature函数寻找下一目标点与当前位置是否可以得到合理运动曲线并计算出相应的曲率。</p><p>​ 最终把得到的曲率计算出相应的指令发布出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PurePursuitNode::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(update_rate_)</span></span>;</span><br><span class="line">     <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">     &#123;</span><br><span class="line">      ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">      <span class="comment">//判断消息是否正常接收</span></span><br><span class="line">      <span class="keyword">if</span> (!is_pose_set_ || !is_waypoint_set_ || !is_velocity_set_)</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="keyword">if</span> (!is_pose_set_)</span><br><span class="line">           &#123; </span><br><span class="line">                <span class="built_in">ROS_WARN_THROTTLE</span>(<span class="number">5</span>, <span class="string">&quot;Waiting for current_pose topic ...&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!is_waypoint_set_)</span><br><span class="line">           &#123; </span><br><span class="line">                <span class="built_in">ROS_WARN_THROTTLE</span>(<span class="number">5</span>, <span class="string">&quot;Waiting for final_waypoints topic ...&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!is_velocity_set_)</span><br><span class="line">           &#123; </span><br><span class="line">                <span class="built_in">ROS_WARN_THROTTLE</span>(<span class="number">5</span>, <span class="string">&quot;Waiting for current_velocity topic ...&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置预瞄距离</span></span><br><span class="line">      pp_.<span class="built_in">setLookaheadDistance</span>(<span class="built_in">computeLookaheadDistance</span>());</span><br><span class="line">      pp_.<span class="built_in">setMinimumLookaheadDistance</span>(minimum_lookahead_distance_);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//寻找下一目标点并计算曲率判断是否是有效曲线</span></span><br><span class="line">      <span class="type">double</span> kappa = <span class="number">0</span>;</span><br><span class="line">      <span class="type">bool</span> can_get_curvature = pp_.<span class="built_in">canGetCurvature</span>(&amp;kappa);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//发布控制命令</span></span><br><span class="line">      <span class="built_in">publishControlCommands</span>(can_get_curvature, kappa);</span><br><span class="line">      health_checker_ptr_-&gt;<span class="built_in">NODE_ACTIVATE</span>();</span><br><span class="line">      health_checker_ptr_-&gt;<span class="built_in">CHECK_RATE</span>(<span class="string">&quot;topic_rate_vehicle_cmd_slow&quot;</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="string">&quot;topic vehicle_cmd publish rate slow.&quot;</span>);</span><br><span class="line">      <span class="comment">// Rviz中可视化</span></span><br><span class="line">      pub11_.<span class="built_in">publish</span>(<span class="built_in">displayNextWaypoint</span>(pp_.<span class="built_in">getPoseOfNextWaypoint</span>()));</span><br><span class="line">      pub13_.<span class="built_in">publish</span>(<span class="built_in">displaySearchRadius</span>(pp_.<span class="built_in">getCurrentPose</span>().position, pp_.<span class="built_in">getLookaheadDistance</span>()));</span><br><span class="line">      pub12_.<span class="built_in">publish</span>(<span class="built_in">displayNextTarget</span>(pp_.<span class="built_in">getPoseOfNextTarget</span>()));</span><br><span class="line">      pub15_.<span class="built_in">publish</span>(<span class="built_in">displayTrajectoryCircle</span>(</span><br><span class="line">        waypoint_follower::<span class="built_in">generateTrajectoryCircle</span>(pp_.<span class="built_in">getPoseOfNextTarget</span>(), pp_.<span class="built_in">getCurrentPose</span>())));</span><br><span class="line">      <span class="keyword">if</span> (add_virtual_end_waypoints_)</span><br><span class="line">      &#123;</span><br><span class="line">           pub18_.<span class="built_in">publish</span>(<span class="built_in">displayExpandWaypoints</span>(pp_.<span class="built_in">getCurrentWaypoints</span>(), expand_size_));</span><br><span class="line">      &#125;</span><br><span class="line">      std_msgs::Float32 angular_gravity_msg;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//计算横向加速并发布</span></span><br><span class="line">      angular_gravity_msg.data = <span class="built_in">computeAngularGravity</span>(<span class="built_in">computeCommandVelocity</span>(), kappa);</span><br><span class="line">      pub16_.<span class="built_in">publish</span>(angular_gravity_msg);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//计算自车与跟踪路径曲线的横向误差</span></span><br><span class="line">      <span class="built_in">publishDeviationCurrentPosition</span>(pp_.<span class="built_in">getCurrentPose</span>().position, pp_.<span class="built_in">getCurrentWaypoints</span>());</span><br><span class="line"></span><br><span class="line">      is_pose_set_ = <span class="literal">false</span>;</span><br><span class="line">      is_velocity_set_ = <span class="literal">false</span>;</span><br><span class="line">      loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="③-computeLookaheadDistance函数"><a href="#③-computeLookaheadDistance函数" class="headerlink" title="③ computeLookaheadDistance函数"></a>③ computeLookaheadDistance函数</h5><p>​ computeLookaheadDistance函数利用车速的倍数作为预瞄距离，速度越大预瞄距离越远，速度越小预瞄准距离越近。在最小预瞄距离，参考值，最大预瞄距离中的中间值作为返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">PurePursuitNode::computeLookaheadDistance</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (velocity_source_ == <span class="built_in">enumToInteger</span>(Mode::dialog))</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> const_lookahead_distance_;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">const</span> <span class="type">double</span> maximum_lookahead_distance = current_linear_velocity_ * <span class="number">10</span>;</span><br><span class="line">     <span class="type">const</span> <span class="type">double</span> ld = current_linear_velocity_ * lookahead_distance_ratio_;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ld &lt; minimum_lookahead_distance_ ? minimum_lookahead_distance_ :</span><br><span class="line">                         ld &gt; maximum_lookahead_distance ? maximum_lookahead_distance : ld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④-canGetCurvature函数"><a href="#④-canGetCurvature函数" class="headerlink" title="④ canGetCurvature函数"></a>④ canGetCurvature函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PurePursuit::canGetCurvature</span><span class="params">(<span class="type">double</span>* output_kappa)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="comment">// 寻找下一个跟踪路径点</span></span><br><span class="line">     <span class="built_in">getNextWaypoint</span>();</span><br><span class="line">     <span class="keyword">if</span> (next_waypoint_number_ == <span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">ROS_INFO</span>(<span class="string">&quot;lost next waypoint&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="comment">// 遍历路径点序列中的每一个点到当前位置的距离是否大于预瞄距离从而判断曲线是否合理</span></span><br><span class="line">     <span class="type">bool</span> is_valid_curve = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; el : current_waypoints_)</span><br><span class="line">     &#123; </span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">getPlaneDistance</span>(el.pose.pose.position, current_pose_.position) &gt; minimum_lookahead_distance_)</span><br><span class="line">          &#123;</span><br><span class="line">               is_valid_curve = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span> (!is_valid_curve)</span><br><span class="line">     &#123; </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 检查是否是第一个点、最后一个点或者不能线性插值的情况</span></span><br><span class="line">     <span class="keyword">if</span> (!is_linear_interpolation_ || next_waypoint_number_ == <span class="number">0</span> ||</span><br><span class="line">       next_waypoint_number_ == (<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(current_waypoints_.<span class="built_in">size</span>() - <span class="number">1</span>)))</span><br><span class="line">     &#123;</span><br><span class="line">          next_target_position_ = current_waypoints_.<span class="built_in">at</span>(next_waypoint_number_).pose.pose.position;</span><br><span class="line">          *output_kappa = <span class="built_in">calcCurvature</span>(next_target_position_);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 线性插值</span></span><br><span class="line">     <span class="type">const</span> <span class="type">bool</span> interpolation = <span class="built_in">interpolateNextTarget</span>(next_waypoint_number_, &amp;next_target_position_);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!interpolation)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">ROS_INFO</span>(<span class="string">&quot;lost target!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//计算曲率</span></span><br><span class="line">    *output_kappa = <span class="built_in">calcCurvature</span>(next_target_position_);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="⑤-calcCurvature函数"><a href="#⑤-calcCurvature函数" class="headerlink" title="⑤ calcCurvature函数"></a>⑤ calcCurvature函数</h5><p><img src="https://cdn.jsdelivr.net/gh/cyhasuka/image_cdn@blog/img/autoware/pure_pursuit.png" alt="pure_pursuit"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">PurePursuit::calcCurvature</span><span class="params">(<span class="type">const</span> geometry_msgs::Point&amp; target)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">double</span> kappa;</span><br><span class="line">     <span class="type">const</span> geometry_msgs::Point pt = <span class="built_in">calcRelativeCoordinate</span>(target, current_pose_);</span><br><span class="line">     <span class="type">const</span> <span class="type">double</span> denominator = pt.x * pt.x + pt.y * pt.y;</span><br><span class="line">     <span class="type">const</span> <span class="type">double</span> numerator = <span class="number">2.0</span> * pt.y;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (denominator != <span class="number">0.0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          kappa = numerator / denominator;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          kappa = numerator &gt; <span class="number">0.0</span> ? KAPPA_MIN_ : -KAPPA_MIN_;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> kappa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑥-publishTwistStamped函数"><a href="#⑥-publishTwistStamped函数" class="headerlink" title="⑥ publishTwistStamped函数"></a>⑥ publishTwistStamped函数</h5><p>​ publishTwistStamped函数用来发布twist_cmd话题，发布消息主要包含线速度（linear.x)和角速度（angular.z），其值分别为computeCommandVelocity函数的结果和曲率与速度的乘积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PurePursuitNode::publishTwistStamped</span><span class="params">(<span class="type">const</span> <span class="type">bool</span>&amp; can_get_curvature, <span class="type">const</span> <span class="type">double</span>&amp; kappa)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     geometry_msgs::TwistStamped ts;</span><br><span class="line">     ts.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">     <span class="comment">//计算速度和角速度的值</span></span><br><span class="line">     ts.twist.linear.x = can_get_curvature ? <span class="built_in">computeCommandVelocity</span>() : <span class="number">0</span>;</span><br><span class="line">     ts.twist.angular.z = can_get_curvature ? kappa * ts.twist.linear.x : <span class="number">0</span>;</span><br><span class="line">     pub1_.<span class="built_in">publish</span>(ts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PurePursuitNode::computeCommandVelocity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (velocity_source_ == <span class="built_in">enumToInteger</span>(Mode::dialog))</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">getSgn</span>() * <span class="built_in">kmph2mps</span>(const_velocity_);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> command_linear_velocity_;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><span id="jump5.2"></span></p><h3 id="5-2-节点twist-filter"><a href="#5-2-节点twist-filter" class="headerlink" title="5.2    节点twist_filter"></a>5.2 节点twist_filter</h3><p>​ 节点twist_filter的主要作用：对pure_pursuit节点发布的速度进行滤波处理。</p><h4 id="5-2-1-启动方法"><a href="#5-2-1-启动方法" class="headerlink" title="5.2.1    启动方法"></a>5.2.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li>roslaunch twist_filter twist_filter.launch</li><li>从Runtime Manager启动:</li></ul></li></ul><p>​ 打开Runtime Manager，上方computing 选项卡 -&gt; motion_planner -&gt;waypoint_follower-&gt;twist_filter，单击 [app] 按钮可更改设置等参数。</p><h4 id="5-2-2-程序路径"><a href="#5-2-2-程序路径" class="headerlink" title="5.2.2    程序路径"></a>5.2.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/autoware/core_planning/twist_filter</span><br></pre></td></tr></table></figure><h4 id="5-2-3-代码注解"><a href="#5-2-3-代码注解" class="headerlink" title="5.2.3    代码注解"></a>5.2.3 代码注解</h4><h5 id="①-main函数-7"><a href="#①-main函数-7" class="headerlink" title="① main函数"></a>① main函数</h5><p>​ main函数在twist_filter_node.cpp中,主要作用为构造TwistFilterNode对象node。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;twist_filter&quot;</span>);</span><br><span class="line">     twist_filter_node::TwistFilterNode node;</span><br><span class="line">     ros::<span class="built_in">spin</span>();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-TwistFilterNode构造函数"><a href="#②-TwistFilterNode构造函数" class="headerlink" title="② TwistFilterNode构造函数"></a>② TwistFilterNode构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TwistFilterNode::<span class="built_in">TwistFilterNode</span>() : <span class="built_in">nh_</span>(), <span class="built_in">pnh_</span>(<span class="string">&quot;~&quot;</span>), <span class="built_in">health_checker_</span>(nh_, pnh_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    twist_filter::Configuration twist_filter_config;</span><br><span class="line">    nh_.<span class="built_in">param</span>(<span class="string">&quot;vehicle_info/wheel_base&quot;</span>, twist_filter_config.wheel_base, <span class="number">2.7</span>); </span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅者</span></span><br><span class="line">    twist_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;twist_raw&quot;</span>, <span class="number">1</span>, &amp;TwistFilterNode::twistCmdCallback, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布者</span></span><br><span class="line">    twist_pub_ = nh_.<span class="built_in">advertise</span>&lt;geometry_msgs::TwistStamped&gt;(<span class="string">&quot;twist_cmd&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    ctrl_pub_ = nh_.<span class="built_in">advertise</span>&lt;autoware_msgs::ControlCommandStamped&gt;(<span class="string">&quot;ctrl_cmd&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③-twistCmdCallback函数"><a href="#③-twistCmdCallback函数" class="headerlink" title="③ twistCmdCallback函数"></a>③ twistCmdCallback函数</h5><p>​ 接收的消息包含速度v和角速度Omega,根据v和Omega进行横向加速度的约束限制，接着对输出的速度和角速度进行一阶低通滤波处理并发布。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TwistFilterNode::twistCmdCallback</span><span class="params">(<span class="type">const</span> geometry_msgs::TwistStampedConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> twist_filter::Twist twist = &#123; msg-&gt;twist.linear.x, msg-&gt;twist.angular.z &#125;;</span><br><span class="line">    ros::Time current_time = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> ros::Time last_callback_time = current_time;</span><br><span class="line">    <span class="type">static</span> twist_filter::Twist twist_prev = twist;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> time_elapsed = (current_time - last_callback_time).<span class="built_in">toSec</span>();</span><br><span class="line">    health_checker_.<span class="built_in">NODE_ACTIVATE</span>();</span><br><span class="line">    <span class="built_in">checkTwist</span>(twist, twist_prev, time_elapsed);</span><br><span class="line">    twist_filter::Twist twist_out = twist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 横向加速度限制</span></span><br><span class="line">    <span class="keyword">auto</span> twist_limit_result = twist_filter_ptr_-&gt;<span class="built_in">lateralLimitTwist</span>(twist, twist_prev, time_elapsed);</span><br><span class="line">    <span class="keyword">if</span> (twist_limit_result)</span><br><span class="line">    &#123;</span><br><span class="line">        twist_out = twist_limit_result.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line">    <span class="keyword">if</span> (enable_smoothing_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 平滑处理</span></span><br><span class="line">        twist_out = twist_filter_ptr_-&gt;<span class="built_in">smoothTwist</span>(twist_out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布滤波后的twist指令</span></span><br><span class="line">    geometry_msgs::TwistStamped out_msg = *msg;</span><br><span class="line">    out_msg.twist.linear.x = twist_out.lx;</span><br><span class="line">    out_msg.twist.angular.z = twist_out.az;</span><br><span class="line">    twist_pub_.<span class="built_in">publish</span>(out_msg);</span><br><span class="line">    <span class="comment">//...(下略)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前指令和时间</span></span><br><span class="line">    twist_prev = twist_out;</span><br><span class="line">    last_callback_time = current_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="jump5.3"></span></p><h3 id="5-3-节点listener-car-drive"><a href="#5-3-节点listener-car-drive" class="headerlink" title="5.3    节点listener_car_drive"></a>5.3 节点listener_car_drive</h3><p>​ listener_car_drive节点主要作用：将Autoware发布的速度信息发送给底盘单片机，控制底盘运动。</p><h4 id="5-3-1-启动方法"><a href="#5-3-1-启动方法" class="headerlink" title="5.3.1    启动方法"></a>5.3.1 启动方法</h4><ul><li><p>终端启动:</p><ul><li>python3 listener_car_drive.py</li></ul></li></ul><h4 id="5-3-2-程序路径"><a href="#5-3-2-程序路径" class="headerlink" title="5.3.2    程序路径"></a>5.3.2 程序路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/car_av/listener_car_drive.py</span><br></pre></td></tr></table></figure><h4 id="5-3-通信协议"><a href="#5-3-通信协议" class="headerlink" title="5.3.    通信协议"></a>5.3. 通信协议</h4><p>​ 电脑与底盘通信时，电脑上位机发送14位16进制数据。</p><p>​ 帧头为<code>a5 11 01</code>，帧尾为<code>0d 0a</code>，第10位为控制位，<code>01</code>为刹车，<code>02</code>为前进，<code>03</code>为电机初始化。第11、12位为校验位，采用crc16校验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a5 11 01 &#x27;</span> + speed_direction + speed + angle_direction + angle + <span class="string">&#x27;02&#x27;</span> + check_1 + check_2 + <span class="string">&#x27; 0d 0a&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="①-速度方向控制"><a href="#①-速度方向控制" class="headerlink" title="① 速度方向控制"></a>① 速度方向控制</h5><p>​ 速度方向控制speed_direction代表线速度方向，<code>01</code>为前进，<code>00</code>为后退。共1位。</p><h5 id="②-速度控制"><a href="#②-速度控制" class="headerlink" title="② 速度控制"></a>② 速度控制</h5><p>​ 速度控制speed代表线速度(车速)，原始单位为<code>m/s</code>，此处将电脑控制端发送的速度值乘以100，便于单片机以<code>int</code>形式接收。共两位。</p><h5 id="③-角速度方向控制"><a href="#③-角速度方向控制" class="headerlink" title="③ 角速度方向控制"></a>③ 角速度方向控制</h5><p>​ 角速度方向控制angle_direction代表角速度方向，<code>01</code>为正向，<code>00</code>为反向。共1位。</p><h5 id="④角速度控制"><a href="#④角速度控制" class="headerlink" title="④角速度控制"></a>④角速度控制</h5><p>​ 角速度控制angle代表车辆角速度，原始单位为<code>rad/s</code>,此处将电脑控制端发送的角速度值乘以100，便于单片机以<code>int</code>形式接收。共两位。</p><p>通信协议demo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a5 11 01 01 1f ff 01 0f ff 02 check_1 check_2 0d 0a</span><br></pre></td></tr></table></figure><h4 id="5-3-3-代码注解"><a href="#5-3-3-代码注解" class="headerlink" title="5.3.3    代码注解"></a>5.3.3 代码注解</h4><h5 id="①-main函数-8"><a href="#①-main函数-8" class="headerlink" title="① main函数"></a>① main函数</h5><p>​ main函数启动了三个独立的线程来接收转换过的控制命令、获取车辆速度、将速度发送给底盘单片机控制线控底盘运动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    rosrun_start = Thread(target=start_rosrun)</span><br><span class="line">    speed_angle = Thread(target=get_value)</span><br><span class="line">    car = Thread(target=car_control)</span><br><span class="line"></span><br><span class="line">    rosrun_start.start()</span><br><span class="line">    speed_angle.start()</span><br><span class="line">    car.start()</span><br><span class="line"></span><br><span class="line">    rosrun_start.join()</span><br><span class="line">    speed_angle.join()</span><br><span class="line">    car.join()</span><br></pre></td></tr></table></figure><h5 id="②-start-rosrun函数"><a href="#②-start-rosrun函数" class="headerlink" title="② start_rosrun函数"></a>② start_rosrun函数</h5><p>​ start_rosrun函数相当于在终端启动了<code>rosrun vehicle_ctl vehicle_cmd_</code>命令来转换速度消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动控制命令转换节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_rosrun</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;rosrun vehicle_ctl vehicle_cmd_&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="③-get-value函数"><a href="#③-get-value函数" class="headerlink" title="③ get_value函数"></a>③ get_value函数</h5><p>​ get_value函数初始化了ros节点，并定义了callback回调函数接收车辆速度及角速度信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>():</span><br><span class="line">    <span class="keyword">global</span> break_f</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">data</span>):</span><br><span class="line">        <span class="keyword">global</span> angle</span><br><span class="line">        <span class="keyword">global</span> speed</span><br><span class="line">        <span class="keyword">global</span> break_f</span><br><span class="line">        value = data.v_cmd</span><br><span class="line">        speed = value[<span class="number">0</span>]</span><br><span class="line">        speed = <span class="built_in">round</span>(<span class="built_in">float</span>(speed), <span class="number">4</span>)</span><br><span class="line">        angle = value[<span class="number">1</span>]</span><br><span class="line">        angle = <span class="built_in">round</span>(<span class="built_in">float</span>(angle), <span class="number">4</span>)</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;listener&#x27;</span>, anonymous=<span class="literal">True</span>, disable_signals=<span class="literal">True</span>)</span><br><span class="line">    rospy.Subscriber(<span class="string">&#x27;speed_pub&#x27;</span>, cmd, callback)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><h5 id="④-car-control函数"><a href="#④-car-control函数" class="headerlink" title="④ car_control函数"></a>④ car_control函数</h5><p>​ car_control函数打开名为&#x2F;dev&#x2F;car的串口，将速度、角速度信息发送给线控底盘单片机，控制车辆运动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">car_control</span>():</span><br><span class="line">    <span class="keyword">global</span> speed</span><br><span class="line">    <span class="keyword">global</span> angle</span><br><span class="line">    <span class="keyword">global</span> break_f</span><br><span class="line">    ser = car_drive()</span><br><span class="line">    <span class="comment"># 打开串口</span></span><br><span class="line">    ret = ser.open_car(<span class="string">&#x27;/dev/car&#x27;</span>, <span class="number">115200</span>)</span><br><span class="line">    <span class="comment"># 判断串口是否打开，当串口成功打开，则将接收到Autoware反馈的速度信息发送给串口</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;速度=&#x27;</span>, speed)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;角速度=&#x27;</span>, angle)</span><br><span class="line">            <span class="keyword">if</span> break_f == <span class="number">0</span>:</span><br><span class="line">                ret = ser.write_car(run(speed, angle))</span><br><span class="line">                <span class="keyword">if</span> ret == <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;write ok&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;write error&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">0.033</span>)</span><br></pre></td></tr></table></figure><h3 id="5-4-参考文献"><a href="#5-4-参考文献" class="headerlink" title="5.4    参考文献"></a>5.4 参考文献</h3><p>[1] 龚建伟，姜岩，徐威. 无人驾驶车辆模型预测控制[M]，北京：北京理工大学出版社，2014.</p><p>[2] 田大新,段续庭等. Autoware与自动驾驶技术，北京：科学出版社，2020.</p><p>[3] Jarrod M S. Automatic steering methods for autonomous automobile path tracking[R]. Pittsburgh: Catnegie Mellon University, 2009.</p><p>[4] 陈宁，周志峰，王永泉，等. 一种纯追踪模型改进算法. 轻工机械[J] ,2014,32(4):69-72.</p><p>[5] 韩亚奇. 高速公路环境中智能车辆路径规划与跟踪[D]. 南宁：广西大学，2019.</p><p>[6] ShinpeiKato.Autoware_TierIV_Academy_v1.1[DB&#x2F;OLJ.[2020-04-22]]. <a target="_blank" rel="noopener" href="https://github.com/CPFL/Autoware-Manuals/blob/master/en/Autoware_TierIV_Academy_v1.1.pdf">https://github.com/CPFL/Autoware-Manuals/blob/master/en/Autoware_TierIV_Academy_v1.1.pdf</a>.</p></div><div class="article-licensing box"><div class="licensing-title"><p>Autoware 软件开发指南</p><p><a href="https://cyhasuka.github.io/posts/15d39967/">https://cyhasuka.github.io/posts/15d39967/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>cyhasuka</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-12-27</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-01-03</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/ROS/">ROS</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/">激光雷达</a><a class="link-muted mr-2" rel="tag" href="/tags/Autoware/">Autoware</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/">自动驾驶</a></div></article></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/9d5b9135/"><span class="level-item">解决hexo博客不能显示图床图片问题</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js"></script><script>twikoo.init({envId:"https://cyhasuka.netlify.app/.netlify/functions/twikoo",lang:"zh-CN"})</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profilewbp.webp" alt="Yuhao Cui"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Yuhao Cui</p><p class="is-size-6 is-block">Lidar Perception Algorithm &amp; Robotics</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Suzhou,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/cyhasuka" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/cyhasuka"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="ZhiHu" href="https://www.zhihu.com/people/cui-yu-hao-77"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Mail" href="mailto:mail@cuiyuhao.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="GMail" href="mailto:cyhasuka@gmail.com"><i class="fab fa-google"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%86%99%E7%82%B9%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">写点教程</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%A5%E7%82%B9%E5%B9%B2%E8%B4%A7/"><span class="level-start"><span class="level-item">来点干货</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%8E%A9%E7%89%A9%E6%9C%89%E5%BF%97/"><span class="level-start"><span class="level-item">玩物有志</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2023-12-27T02:33:40.000Z">2023-12-27</time></p><p class="title"><a href="/posts/15d39967/">Autoware 软件开发指南</a></p><p class="categories"><a href="/categories/%E6%9D%A5%E7%82%B9%E5%B9%B2%E8%B4%A7/">来点干货</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-12-25T08:16:32.000Z">2023-12-25</time></p><p class="title"><a href="/posts/9d5b9135/">解决hexo博客不能显示图床图片问题</a></p><p class="categories"><a href="/categories/%E5%86%99%E7%82%B9%E6%95%99%E7%A8%8B/">写点教程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-01-09T07:25:31.000Z">2023-01-09</time></p><p class="title"><a href="/posts/727a344e/">WiFi 6终章？ROG旗舰万兆路由GT-AX11000Pro开箱评测</a></p><p class="categories"><a href="/categories/%E7%8E%A9%E7%89%A9%E6%9C%89%E5%BF%97/">玩物有志</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2022-12-14T08:22:32.000Z">2022-12-14</time></p><p class="title"><a href="/posts/21f2167c/">手感、颜值、性能兼具？ROG月刃AimPoint月耀白拆解评测</a></p><p class="categories"><a href="/categories/%E7%8E%A9%E7%89%A9%E6%9C%89%E5%BF%97/">玩物有志</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2022-11-16T07:25:12.000Z">2022-11-16</time></p><p class="title"><a href="/posts/5dcb1f53/">三防铠甲，坚若磐石-华硕TUF Gaming铠甲固态硬盘盒体验评测</a></p><p class="categories"><a href="/categories/%E7%8E%A9%E7%89%A9%E6%9C%89%E5%BF%97/">玩物有志</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">文章</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Autoware/"><span class="tag">Autoware</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROG/"><span class="tag">ROG</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROS/"><span class="tag">ROS</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%96%E8%AE%BE/"><span class="tag">外设</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87/"><span class="tag">存储设备</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%91%84%E5%83%8F%E5%A4%B4/"><span class="tag">摄像头</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/"><span class="tag">激光雷达</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"><span class="tag">系统安装</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98/"><span class="tag">系统问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"><span class="tag">网络设备</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"><span class="tag">自动驾驶</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/toplogo.jpg" alt="CuiYuhao&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 cyhasuka</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="知识共享" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="我的GitHub" href="https://github.com/cyhasuka"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load",()=>{window.cookieconsent.initialise({type:"info",theme:"edgeless",static:!1,position:"bottom-left",content:{message:"我们会使用Cookies来改善您的体验。",dismiss:"知道了！",allow:"允许使用Cookies",deny:"拒绝",link:"了解更多",policy:"Cookies政策",href:"https://www.cookiesandyou.com/"},palette:{popup:{background:"#edeff5",text:"#838391"},button:{background:"#4b81e8"}}})})</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load",()=>{"function"==typeof $.fn.lightGallery&&$(".article").lightGallery({selector:".gallery-item"}),"function"==typeof $.fn.justifiedGallery&&($(".justified-gallery > p > .gallery-item").length&&$(".justified-gallery > p > .gallery-item").unwrap(),$(".justified-gallery").justifiedGallery())})</script><script src="/js/tianli_gpt.min.js"></script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",(function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})}))</script></body></html>